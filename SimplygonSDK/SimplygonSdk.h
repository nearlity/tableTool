#ifndef __SimplygonSDK_h__
#define __SimplygonSDK_h__

#include <string.h>

#ifdef SGDEPRECATED
#undef SGDEPRECATED
#endif

#if defined(SGSDK) || defined(WITH_SIMPLYGON_DLL) || defined(SGDEPRECATED_OFF)
// internal Simplygon, Unreal Engine, or deprecation warning disabled
#define SGDEPRECATED 
#else
#ifdef _WIN32 // Microsoft compiler
#if (_MSC_VER >= 1300) // 7.1
#define SGDEPRECATED __declspec(deprecated)
#else
#define SGDEPRECATED
#endif
#else
#define SGDEPRECATED
#endif
#endif
	
namespace SimplygonSDK
{

	/** 
	 * CountedPointer is a template class for pointers to API objects. All API interface classes have typedefs for counted pointers that points at the specific class. 
	 * All such typedefs are prefixed with 'sp'. An example of this is 'spObject', which is a typedef for CountedPointer<IObject>. The CountedPointer can be used
	 * for any object that supports reference counting, and exports the AddRef and Release methods. See the IObject class for an example.
	 */ 
	template <class T> class CountedPointer
		{
		public:
			/**
			 * Constructs a CountedPointer from a standard pointer. If the source pointer points at an API object, a reference to the API object is added.
			 * @param p is a pointer to an API object, or NULL to make the CountedPointer point at nothing.
			 */
			CountedPointer( T *p=NULL ) : ptr(p)
				{
				addref_ptr();
				}
				
			/**
			 * Constructs a CountedPointer from another CountedPointer. If the source pointer points at an API object, a reference to the API object is added.
			 * @param p is a CountedPointer that points at an API object.
			 */
			CountedPointer( const CountedPointer<T> &p ) : ptr(p.ptr)
				{
				addref_ptr();
				}
				
			/**
			 * Destructs the CountedPointer, and releases one reference to the API object, if the CountedPointer does currently point at an object.
			 */
			~CountedPointer()
				{
				release_ptr();
				}
		
			/** 
			 * Tells whether the CountedPointer points at an object, or nothing.
			 * @return true if the pointer points at nothing, of false if the pointer points at an object
			 */
			bool IsNull() const
				{
				return (ptr == NULL);
				}
				
			/**
			 * Sets the pointer to point at the same object as another CountedPointer
			 * @param p is the source CountedPointer object
			 * @return a referece to this object
			 */
			CountedPointer<T>& operator=( const CountedPointer<T> &p ) 
				{
				if( this != &p ) 
					{
					release_ptr();
					ptr = p.ptr;
					addref_ptr();
					}
				return *this;
				}

			/**
			 * Operator that returns the reference of the object the pointer is pointing at. Note! Do not use this operator if the pointer is not pointing at an object. 
			 * @return a referece to the object the pointer is pointing at
			 */
		    T& operator*() const 
				{
		        return *ptr;
				}
				
			/**
			 * Operator that returns a standard pointer to the object the pointer is pointing at. 
			 * @return a pointer to the object the pointer is pointing at
			 */
		    T* operator->() const 
				{
		        return ptr;
				}
								
			/**
			 * Operator that returns a standard pointer to the object the pointer is pointing at. 
			 * @return a pointer to the object the pointer is pointing at
			 */
			operator T* () const
				{
				return ptr;
				}
				
			/**
			 * Method that returns a standard pointer to the object the pointer is pointing at. 
			 * @return a pointer to the object the pointer is pointing at
			 */
			T* GetPointer() const
				{
				return ptr;
				}
				
		private:
			void addref_ptr()
				{
				if( ptr!=NULL )
					{
					ptr->AddRef();
					}
				}
		
			void release_ptr()
				{
				if( ptr!=NULL )
					{
					ptr->Release();
					ptr = NULL;
					}
				}
		
			T *ptr;	
	    };
		

	class IObject;
	
	/** 
	 * rhandle are used to represent opaque handles returned from and used by the API
	 */
	typedef void* rhandle;
	
	/** 
	 * rid represents ids within the API
	 */
	typedef int rid;

	/**
	 * real represents generic floating point values, depending on API floating point
	 * precision version, reals are either typedef:ed as floats or doubles
	 */
	typedef float real;
			
	const real REAL_MIN = 1.175494351e-38F;
	const real REAL_MAX = 3.402823466e+38F;

	/** 
	 * rchar represents text characters within the API. 
	 */
	typedef char rchar;

	/** 
	 * The robserver class is used to receive events from an interface, by creating a class that
	 * implements the Execute method. By adding an object of the class into an interface using 
	 * the AddObserver method, the Execute method will receive all events of the specified EventId
	 */
	class robserver
		{
		public:
			/** 
			 * The Execute method will receive all events that the robserver is registered to receive.
			 * @param subject is the object that is sending the event
			 * @param EventId is the id of the sent event
			 * @param EventParameterBlock points at a event-specific parameter data block
			 * @param EventParameterBlockSize is the size of the event-specific data block, 
			 * which is useful if the Execute method passes the information on to another handler. Please
			 * note that if the block data is copied to another handler, the data may have to be copied
			 * back into the original block to be able to pass data back to the API class. This is 
			 * however event-specific.
			 */
			virtual void Execute( IObject *subject , rid EventId , void *EventParameterBlock , unsigned int EventParameterBlockSize ) = 0;	
		};

	/**
	 * The rerrorhandler class is used to receive error messages from the interface, by by creating a class that
	 * implements the HandleError method. By setting an object of the class into the main interface using 
	 * the SetErrorHandler method, the HandleError method will receive all error messages from the interface.
	 * Please note that errors may not be recoverable, and could leave objects in an intermediate state. Errors
	 * should in most cases be considered fatal, and will not occur i standard use. 
	 */
	class rerrorhandler
		{
		public:
			/** 
			 * The HandleError method will receive all error messages from the interface.
			 * @param object is the interface object that raised the error message
			 * @param interfacename is the name of the interface 
			 * @param methodname is the name of the method in the object that was called when the error occurred
			 * @param errortype is the type of error that has occurred
			 * @param errortext is a description of the error that has occurred
			 */
			virtual void HandleError( IObject *object , const char *interfacename , const char *methodname , rid errortype , const char *errortext ) = 0;
		};

	/**
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 */
	class IData
		{
		public:
			virtual void AddRef() = 0;
			virtual void Release() = 0;
			virtual void SetItemCount( unsigned int size ) = 0;
			virtual unsigned int GetItemCount() const = 0;
		};

	/**
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.
	 */
	template<class I> class rdata : public CountedPointer<I>
		{
		public:
			typedef typename I::value_type value_type;

			/** 
			 * ctor, that creates the rdata from a pointer to an IArrayData interface
			 */
			rdata( I *ptr = NULL ) : CountedPointer<I>( ptr ) {}
			rdata( const CountedPointer<I> &other ) : CountedPointer<I>( other ) {}
			rdata( const rdata<I> &other ) : CountedPointer<I>( other ) {}
			
			/** 
			 * Operator that sets the rdata to point at the same rdata as the source rdata
			 */
			rdata<I>& operator=( const rdata<I> &p ) 
				{
				CountedPointer<I>::operator=( p );
				return *this;
				}

			/** 
			 * Method to retrieve the data pointer. 
			 */
			value_type *Data()
				{
				return this->GetPointer()->GetData();
				}

			/** 
			 * Method to retrieve the const data pointer. 
			 */
			const value_type *Data() const
				{
				return this->GetPointer()->GetData();
				}

			/** 
			 * Operator to retrieve the data.
			 */
			operator const value_type *() const
				{
				return this->GetData();
				}

			/** 
			 * Method to retrieve the data size.
			 */
			unsigned int GetItemCount() const
				{
				return this->GetPointer()->GetItemCount();
				}

			/** 
			 * Method to retrieve a data item value
			 */
			const value_type& GetItem( rid index ) const
				{
				return this->GetPointer()->GetItem(index);
				}

			/** 
			 * Operator to retrieve a data item value
			 */
			const value_type& operator [] ( rid index ) const
				{
				return this->GetItem( index );
				}
		};


	/** IBoolData is the bool implementation of IData. Do not use directly, instead use spBoolData. */
	class IBoolData : public IData
		{
		protected:
			bool *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef bool value_type;
		
			virtual const bool *GetData() const = 0;
			virtual bool *GetData() = 0;
			virtual const bool & GetItem( rid item_index ) const = 0;
			virtual bool & GetItem( rid item_index ) = 0;
		};
		
	/** spBoolData is the alias for rdata<IBoolData,bool> 
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IBoolData> spBoolData;
	
	/** ICharData is the char implementation of IData. Do not use directly, instead use spCharData. */
	class ICharData : public IData
		{
		protected:
			char *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef char value_type;
		
			virtual const char *GetData() const = 0;
			virtual char *GetData() = 0;
			virtual const char & GetItem( rid item_index ) const = 0;
			virtual char & GetItem( rid item_index ) = 0;
		};
		
	/** spCharData is the alias for rdata<ICharData,char>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<ICharData> spCharData;
	
	/** IDoubleData is the double implementation of IData. Do not use directly, instead use spDoubleData. */
	class IDoubleData : public IData
		{
		protected:
			double *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef double value_type;
		
			virtual const double *GetData() const = 0;
			virtual double *GetData() = 0;
			virtual const double & GetItem( rid item_index ) const = 0;
			virtual double & GetItem( rid item_index ) = 0;
		};
		
	/** spDoubleData is the alias for rdata<IDoubleData,double>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IDoubleData> spDoubleData;
	
	/** IFloatData is the float implementation of IData. Do not use directly, instead use spFloatData. */
	class IFloatData : public IData
		{
		protected:
			float *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef float value_type;
		
			virtual const float *GetData() const = 0;
			virtual float *GetData() = 0;
			virtual const float & GetItem( rid item_index ) const = 0;
			virtual float & GetItem( rid item_index ) = 0;
		};
		
	/** spFloatData is the alias for rdata<IFloatData,float>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IFloatData> spFloatData;
	
	/** IIntData is the int implementation of IData. Do not use directly, instead use spIntData. */
	class IIntData : public IData
		{
		protected:
			int *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef int value_type;
		
			virtual const int *GetData() const = 0;
			virtual int *GetData() = 0;
			virtual const int & GetItem( rid item_index ) const = 0;
			virtual int & GetItem( rid item_index ) = 0;
		};
		
	/** spIntData is the alias for rdata<IIntData,int>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IIntData> spIntData;
	
	/** ILongData is the long implementation of IData. Do not use directly, instead use spLongData. */
	class ILongData : public IData
		{
		protected:
			long *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef long value_type;
		
			virtual const long *GetData() const = 0;
			virtual long *GetData() = 0;
			virtual const long & GetItem( rid item_index ) const = 0;
			virtual long & GetItem( rid item_index ) = 0;
		};
		
	/** spLongData is the alias for rdata<ILongData,long>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<ILongData> spLongData;
	
	/** IRealData is the real implementation of IData. Do not use directly, instead use spRealData. */
	class IRealData : public IData
		{
		protected:
			real *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef real value_type;
		
			virtual const real *GetData() const = 0;
			virtual real *GetData() = 0;
			virtual const real & GetItem( rid item_index ) const = 0;
			virtual real & GetItem( rid item_index ) = 0;
		};
		
	/** spRealData is the alias for rdata<IRealData,real>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IRealData> spRealData;
	
	/** IRidData is the rid implementation of IData. Do not use directly, instead use spRidData. */
	class IRidData : public IData
		{
		protected:
			rid *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef rid value_type;
		
			virtual const rid *GetData() const = 0;
			virtual rid *GetData() = 0;
			virtual const rid & GetItem( rid item_index ) const = 0;
			virtual rid & GetItem( rid item_index ) = 0;
		};
		
	/** spRidData is the alias for rdata<IRidData,rid>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IRidData> spRidData;
	
	/** IShortData is the short implementation of IData. Do not use directly, instead use spShortData. */
	class IShortData : public IData
		{
		protected:
			short *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef short value_type;
		
			virtual const short *GetData() const = 0;
			virtual short *GetData() = 0;
			virtual const short & GetItem( rid item_index ) const = 0;
			virtual short & GetItem( rid item_index ) = 0;
		};
		
	/** spShortData is the alias for rdata<IShortData,short>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IShortData> spShortData;
	
	/** IUnsignedCharData is the unsigned char implementation of IData. Do not use directly, instead use spUnsignedCharData. */
	class IUnsignedCharData : public IData
		{
		protected:
			unsigned char *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef unsigned char value_type;
		
			virtual const unsigned char *GetData() const = 0;
			virtual unsigned char *GetData() = 0;
			virtual const unsigned char & GetItem( rid item_index ) const = 0;
			virtual unsigned char & GetItem( rid item_index ) = 0;
		};
		
	/** spUnsignedCharData is the alias for rdata<IUnsignedCharData,unsigned char>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IUnsignedCharData> spUnsignedCharData;
	
	/** IUnsignedIntData is the unsigned int implementation of IData. Do not use directly, instead use spUnsignedIntData. */
	class IUnsignedIntData : public IData
		{
		protected:
			unsigned int *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef unsigned int value_type;
		
			virtual const unsigned int *GetData() const = 0;
			virtual unsigned int *GetData() = 0;
			virtual const unsigned int & GetItem( rid item_index ) const = 0;
			virtual unsigned int & GetItem( rid item_index ) = 0;
		};
		
	/** spUnsignedIntData is the alias for rdata<IUnsignedIntData,unsigned int>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IUnsignedIntData> spUnsignedIntData;
	
	/** IUnsignedLongData is the unsigned long implementation of IData. Do not use directly, instead use spUnsignedLongData. */
	class IUnsignedLongData : public IData
		{
		protected:
			unsigned long *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef unsigned long value_type;
		
			virtual const unsigned long *GetData() const = 0;
			virtual unsigned long *GetData() = 0;
			virtual const unsigned long & GetItem( rid item_index ) const = 0;
			virtual unsigned long & GetItem( rid item_index ) = 0;
		};
		
	/** spUnsignedLongData is the alias for rdata<IUnsignedLongData,unsigned long>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IUnsignedLongData> spUnsignedLongData;
	
	/** IUnsignedShortData is the unsigned short implementation of IData. Do not use directly, instead use spUnsignedShortData. */
	class IUnsignedShortData : public IData
		{
		protected:
			unsigned short *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef unsigned short value_type;
		
			virtual const unsigned short *GetData() const = 0;
			virtual unsigned short *GetData() = 0;
			virtual const unsigned short & GetItem( rid item_index ) const = 0;
			virtual unsigned short & GetItem( rid item_index ) = 0;
		};
		
	/** spUnsignedShortData is the alias for rdata<IUnsignedShortData,unsigned short>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IUnsignedShortData> spUnsignedShortData;
	
	/** IRcharData is the rchar implementation of IData. Do not use directly, instead use spRcharData. */
	class IRcharData : public IData
		{
		protected:
			rchar *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef rchar value_type;
		
			virtual const rchar *GetData() const = 0;
			virtual rchar *GetData() = 0;
			virtual const rchar & GetItem( rid item_index ) const = 0;
			virtual rchar & GetItem( rid item_index ) = 0;
		};
		
	/** spRcharData is the alias for rdata<IRcharData,rchar>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IRcharData> spRcharData;
	
	/** IRhandleData is the rhandle implementation of IData. Do not use directly, instead use spRhandleData. */
	class IRhandleData : public IData
		{
		protected:
			rhandle *Data; // the data pointer. only use the pointer for debugging purposes
			unsigned int DataCount; // the number of items. only use the pointer for debugging purposes
			unsigned int DataAllocation; // the number of allocated items. only use the pointer for debugging purposes
			
			int RefCount; // the reference count. only use for debugging purposes
		
		public:
			typedef rhandle value_type;
		
			virtual const rhandle *GetData() const = 0;
			virtual rhandle *GetData() = 0;
			virtual const rhandle & GetItem( rid item_index ) const = 0;
			virtual rhandle & GetItem( rid item_index ) = 0;
		};
		
	/** spRhandleData is the alias for rdata<IRhandleData,rhandle>  
	 * The IData class is used to represent data that is created by the API objects, and returned to the caller.
	 * The data arrays are created in the same address space as the caller application, and the data can be accessed directly.
	 * For ease of use, it is recommended to never use the IData interface directly, but instead through an 
	 * sp[...]Data (e.g. spBoolData, spRidData etc) object, which inherits from a CountedPointer of IData, 
	 * and that also adds help code and conversions.
	 * The rdata class is used to retrieve array data from the interface. Use this rather than the
	 * IData objects, as this is based on a CountedPointer of the interface and adds help methods.	
	 */
	typedef rdata<IRhandleData> spRhandleData;
	
	/**
	 * The IString class is used to represent strings that are created by the API objects, and returned to the caller.
	 * The strings are reference counted and constant strings, and can be retrieved, but not modified. All
	 * methods that input a string value does this using basic null-terminated rchar-pointers.
	 * For simplicity it is recommended to never use the IString interface directly, but instead through an 
	 * rstring object, which inherits from a CountedPointer of IString, and that also adds help code and conversions.
	 */
	class IString
		{
		protected:
			rchar *Text; // the text of the string (warning: never modify this pointer directly)

		public:
			/**
			* Never used directly, use rstring objects and functions instead.
			*/
			virtual void AddRef() = 0;
			/**
			* Never used directly, use rstring objects and functions instead.
			*/
			virtual void Release() = 0;
			/**
			* Never used directly, use rstring objects and functions instead.
			*/
			virtual const rchar *GetText() const = 0;
			/**
			* Never used directly, use rstring objects and functions instead.
			*/
			virtual bool IsEmpty() const = 0;
		};
	
	/**
	 * The IString class is used to represent strings that are created by the API objects, and returned to the caller.
	 * The strings are reference counted and constant strings, and can be retrieved, but not modified. All
	 * methods that input a string value does this using basic null-terminated rchar-pointers.
	 * For simplicity it is recommended to never use the IString interface directly, but instead through an 
	 * rstring object, which inherits from a CountedPointer of IString, and that also adds help code and conversions.
	 */
	 typedef CountedPointer<IString> spString;
	
	/**
	 * The rstring is a help class that handles type conversion and reference counting for the IString 
	 * interface.
	 * The IString class is used to represent strings that are created by the API objects, and returned to the caller.
	 * The strings are reference counted and constant strings, and can be retrieved, but not modified. All
	 * methods that input a string value does this using basic null-terminated rchar-pointers.
	 * For simplicity it is recommended to never use the IString interface directly, but instead through an 
	 * rstring object, which inherits from a CountedPointer of IString, and that also adds help code and conversions.
	 */
	class rstring : public CountedPointer<IString>
		{
		public:
			rstring( IString *ptr = NULL ) : CountedPointer<IString>( ptr ) {}
			rstring( const CountedPointer<IString> &other ) : CountedPointer<IString>( other ) {}
			rstring( const rstring &other ) : CountedPointer<IString>( other ) {}
			
			/** 
			 * Operator that sets the rstring to point at the same IString as the source rstring
			 */
			rstring& operator=( const rstring &p ) 
				{
				CountedPointer<IString>::operator=( p );
				return *this;
				}

			/** 
			 * Method to retrieve the string value as a const rchar *. If the rstring does not point at an object, NULL is returned
			 */
			const rchar *GetText() const
				{
				IString *p = this->GetPointer();
				if( !p )
					{
					return NULL;
					}
				return p->GetText();
				}

			/** 
			 * Operator to cast the rstring into a const rchar *. If the rstring does not point at an object, NULL is returned
			 */
			operator const rchar *() const
				{
				return this->GetText();
				}
				
			/**
			 * Method to check if the rstring is empty, which is the case if the rstring does not point at an IString object,
			 * the IString object does not contain a string, or the string exists, but has zero length.
			 */
			bool IsEmpty() const 
				{
				IString *p = this->GetPointer();
				if( !p )
					{
					return true;
					}
				return p->IsEmpty();
				}
				
		};

	/**
	 * BaseTypes are ids of the base types used by data containers (arrays etc.) within
	 * Simplygon.
	 */
	enum BaseTypes
	{
		TYPES_ID_BOOL = 1,
		TYPES_ID_CHAR = 2,
		TYPES_ID_UCHAR = 3,
		TYPES_ID_SHORT = 4,
		TYPES_ID_USHORT = 5,
		TYPES_ID_INT = 6,
		TYPES_ID_UINT = 7,
		TYPES_ID_LONG = 8,
		TYPES_ID_ULONG = 9,
		TYPES_ID_FLOAT = 10,
		TYPES_ID_DOUBLE = 11,
		TYPES_ID_REAL = 12,
		TYPES_ID_RID = 13,
		TYPES_ID_RCHAR = 14,
		TYPES_ID_RHANDLE = 15,
		TYPES_ID_OBJECT = 16
	};

	/**
	 * EventCodes are used by the event system to specify what kind of event to listen for
	 */
	enum EventCodes
	{
		SG_EVENT_PROGRESS = 0x1000001, /// updates the current progress, in percent
		SG_EVENT_PROCESS_STARTED = 0x1000002, /// The evaluate event is triggered from the custom shading node
		SG_EVENT_CUSTOM_NODE_EVALUATE = 0x1, /// The evaluate event is triggered from the custom shading node
		SG_EVENT_CUSTOM_NODE_GENERATE_SHADER_CODE = 0x2 /// The generate shader code event is triggered from the custom shading node
	};

	/**
	 * Error codes that are returned on initialization/finalization of the library
	 */
	enum ErrorCodes
	{
		SG_ERROR_NOERROR = 0, /// no error
		SG_ERROR_NOLICENSE = -1, /// no license was found (or licence expired)
		SG_ERROR_NOTINITIALIZED = -2, /// the SDK is not initialized, or no process object has been loaded/created
		SG_ERROR_ALREADYINITIALIZED = -3, /// the SDK is already initialized
		SG_ERROR_FILENOTFOUND = -4, /// the specified file was not found
		SG_ERROR_INVALIDPARAM = -5, /// an invalid parameter was passed to the method
		SG_ERROR_FAILEDTESTING = -6, /// the reduction failed post-testing
		SG_ERROR_WRONGVERSION = -7, /// the Simplygon DLL and header file interface versions do not match
		SG_ERROR_LOADFAILED = -8, /// the Simplygon DLL failed loading, probably because of a missing dependency
		SG_ERROR_FAILEDLOOKUP = -10001, /// cannot reach the licensing server, cant look up server, check DNS
		SG_ERROR_FAILEDCONTACT = -10002, /// cannot contact the licensing server, check firewall/proxy server
		SG_ERROR_FAILEDSEND = -10003, /// cannot send data to the licensing server, check firewall/proxy server
		SG_ERROR_FAILEDRCV = -10004, /// cannot receive data from the licensing server, check firewall/proxy server
		SG_ERROR_CORRUPTED = -10005, /// data from licensing server is corrupted, try again, check connection
		SG_ERROR_EXPIRED = -10006, /// the license has expired
		SG_ERROR_INVALIDLICENSE = -10007, /// the license data is corrupted, please reinstall the license key
		SG_ERROR_WRONGLICENSE = -10008, /// the license is not for this product, please contact licensing, and replace license key
		SG_ERROR_NONWCARD = -10009, /// no network card was found on the machine
		SG_ERROR_DECODEFAILED = -10010, /// could not decode license, it is corrupted
		SG_ERROR_WRONGMACHINE = -10011, /// the license is locked to another machine
		SG_ERROR_DECODEFAILED2 = -10012, /// could not decode license, it is corrupted
		SG_ERROR_DECODEFAILED3 = -10013, /// could not decode license, it is corrupted
		SG_ERROR_INVALIDLICENSE2 = -10014, /// the license is invalid, please contact licensing 
		SG_ERROR_EXPIRED2 = -10015, /// the license has expired
		SG_ERROR_INVALID_LICENSE2 = -10016, /// the license data is corrupted, please reinstall the license key
		SG_ERROR_WRONG_LICENSE2 = -10017, /// the license is not for this product, please contact licensing, and replace license key
		SG_ERROR_NO_NWCARD = -10018, /// no network card was found on the machine
		SG_ERROR_DECODE_FAILED = -10019, /// could not decode license, it is corrupted
		SG_ERROR_WRONG_MACHINE2 = -10020, /// the license is locked to another machine
		SG_ERROR_DECODEFAILED4 = -10021, /// could not decode license, it is corrupted
		SG_ERROR_DECODEFAILED5 = -10022, /// could not decode license, it is corrupted
		SG_ERROR_INVALIDLICENSE3 = -10023 /// the license is invalid, please contact licensing 
	};

	/**
	 * GeometryValidationCodes are used by the Geometry Validation system to report errors
	 * in a setup geometry.
	 */
	enum GeometryValidationCodes
	{
		SG_VALIDATIONERROR_NOERROR = 0, ///  no error
		SG_VALIDATIONERROR_ILLEGAL_TRIANGLECOUNT = -1, ///  the triangle count is illegal (probably 0)
		SG_VALIDATIONERROR_ILLEGAL_VERTEXCOUNT = -2, ///  the vertex count is illegal (probably 0)
		SG_VALIDATIONERROR_ILLEGAL_INDICES = -3, ///  the vertex indices are illegal
		SG_VALIDATIONERROR_ILLEGAL_TRIANGLE = -4, ///  a found triangle has illegal index setup
		SG_VALIDATIONERROR_ILLEGAL_FIELD_ITEMCOUNT = -5, ///  a field has illegal number of items
		SG_VALIDATIONERROR_ILLEGAL_FIELD_TUPLECOUNT = -6, ///  a field has illegal number of tuples
		SG_VALIDATIONERROR_ILLEGAL_FIELD_TUPLESIZE = -7, ///  a field has illegal size of tuples
		SG_VALIDATIONERROR_ILLEGAL_FIELD_ITEMVALUE = -8, ///  a field has illegal values (probably an index out of bounds)
		SG_VALIDATIONERROR_ZEROAREA_TRIANGLE = -9, ///  a found triangle has no area
		SG_VALIDATIONERROR_ILLEGAL_BONETUPLESIZE = -10, ///  the skinning field has illegal values (probably an index out of bounds)
		SG_VALIDATIONERROR_MISSING_OBJECT = -11, ///  there is a missing object in the scene/geometry that should never be missing
		SG_VALIDATIONERROR_ILLEGAL_BONE = -12 ///  a found bone is illegal within the scene 
	};

	/**
	 * FeatureFlags are used to mask what different features to consider when processing.
	 */
	enum FeatureFlags
	{
		SG_FEATUREFLAGS_GEOMETRYBOUNDARY = 0x1,
		SG_FEATUREFLAGS_MATERIAL = 0x2,
		SG_FEATUREFLAGS_SHADING = 0x4,
		SG_FEATUREFLAGS_USER = 0x8,
		SG_FEATUREFLAGS_GROUP = 0x10,
		SG_FEATUREFLAGS_NONMANIFOLD = 0x20, /// contains edges connecting more than 2 triangles
		SG_FEATUREFLAGS_FLIPPEDTRIANGLE = 0x40,
		SG_FEATUREFLAGS_NORMALCHART = 0x80,
		SG_FEATUREFLAGS_COLORS = 0x100,
		SG_FEATUREFLAGS_SYMMETRY = 0x200,
		SG_FEATUREFLAGS_BORDEREND = 0x400, /// only contains border on 1 edge (2 half-edges) for example, end of a sharp-edge
		SG_FEATUREFLAGS_BORDERJUNCTION = 0x800, /// contains atleast 3 border-edges
		SG_FEATUREFLAGS_COMPONENTCONNECTOR = 0x1000, /// connects 2 or more triangle-groups that arent edge-connected
		SG_FEATUREFLAGS_NONCONNECTED = 0x2000, /// not used in any triangle
		SG_FEATUREFLAGS_TEXTURE0 = 0x10000,
		SG_FEATUREFLAGS_TEXTURE1 = 0x20000,
		SG_FEATUREFLAGS_TEXTURE2 = 0x40000,
		SG_FEATUREFLAGS_TEXTURE3 = 0x80000,
		SG_FEATUREFLAGS_TEXTURE4 = 0x100000,
		SG_FEATUREFLAGS_TEXTURE5 = 0x200000,
		SG_FEATUREFLAGS_TEXTURE6 = 0x400000,
		SG_FEATUREFLAGS_TEXTURE7 = 0x800000,
		SG_FEATUREFLAGS_TEXTURE_ALL = 0xff0000,
		SG_FEATUREFLAGS_ALL = 0xffffffff
	};

	/**
	 * StopCondition tells if reducer will stop when trianglecount and/or deviation has
	 * been reached
	 */
	enum StopCondition
	{
		SG_STOPCONDITION_REDUCTIONRATIO = 0x0,
		SG_STOPCONDITION_MAXDEVIATION = 0x1,
		SG_STOPCONDITION_BOTH_ARE_REACHED = 0x2,
		SG_STOPCONDITION_EITHER_IS_REACHED = 0x3
	};

	enum ReductionHeuristics
	{
		SG_REDUCTIONHEURISTICS_FAST = 0x0,
		SG_REDUCTIONHEURISTICS_CONSISTENT = 0x1
	};

	enum DataCreationPreferences
	{
		SG_DATACREATIONPREFERENCES_ONLY_USE_ORIGINAL_DATA = 0x0,
		SG_DATACREATIONPREFERENCES_PREFER_ORIGINAL_DATA = 0x1,
		SG_DATACREATIONPREFERENCES_PREFER_OPTIMIZED_RESULT = 0x2
	};

	enum RemeshingSurfaceTransferMode
	{
		SG_SURFACETRANSFER_FAST = 0x0,
		SG_SURFACETRANSFER_ACCURATE = 0x1
	};

	enum AtlasFillMode
	{
		SG_ATLASFILLMODE_INTERPOLATE = 0x0,
		SG_ATLASFILLMODE_NEARESTNEIGHBOR = 0x1,
		SG_ATLASFILLMODE_NONE = 0x2
	};

	/**
	 * BoneProcessing tells if the number of bones that the vertices are linked to should
	 * be reduced or not, and in what way that should happen. It can either calculate with
	 * the help of pixelsize how many bonesshould be removed, or a set percentage (ratio,
	 * 0.0 - 1.0 * the original bonescount) of the bones can be removed.It is also possible
	 * to not touch the number of bones used, but only reduce the number of bones that each
	 * vertex can be linked to.
	 */
	enum BoneRemovalProcessing
	{
		SG_BONEPROCESSING_NO_PROCESSING = 0x0,
		SG_BONEPROCESSING_NO_BONE_REMOVAL = 0x1,
		SG_BONEPROCESSING_RATIO_PROCESSING = 0x2,
		SG_BONEPROCESSING_PIXELSIZE_PROCESSING = 0x3
	};

	/**
	 * TangentSpaceMethod is used to specify which tangent space method is usedto generate
	 * tangent spaces when processing. Use SG_TANGENTSPACEMETHOD_ORTHONORMAL_LEFTHANDEDto
	 * generate tangents that are D3D compatible (left-handed coordinate system).
	 */
	enum TangentSpaceMethod
	{
		SG_TANGENTSPACEMETHOD_ORTHONORMAL = 0x0, /// Standard method, creates an orthonormal tangent space (right-handed)
		SG_TANGENTSPACEMETHOD_3DSMAX = 0x1, /// 3dsMax compatible method, creates tangent space that is compatible with the 3dsMax renderer
		SG_TANGENTSPACEMETHOD_ORTHONORMAL_LEFTHANDED = 0x2 /// Creates an orthonormal tangent space (left-handed, D3D compatible)
	};

	/**
	 * Validation level is used to specify how often validation is done on geometries when
	 * debugging integrations.
	 */
	enum ValidationFrequency
	{
		SG_VALIDATIONFREQUENCY_NORMAL = 0x0, /// Normal level, validation will hardly be noticeable at all
		SG_VALIDATIONFREQUENCY_CORE = 0x1, /// Core debugging level, validation will be carried out before each processing step, and increase processing times significantly
		SG_VALIDATIONFREQUENCY_ULTRA = 0x2 /// Ultra level, validation will be carried out very often, multiple times per processing step. This will increase processing times with orders of magnitudes.
	};

	/**
	 * TextureBlendType specifies which type of blend function to use to blend textures.
	 * The blend type function will be used while casting channels during material casting.
	 */
	enum TextureBlendType
	{
		SG_TEXTUREBLEND_REPLACE = 0x0,
		SG_TEXTUREBLEND_ADD = 0x1,
		SG_TEXTUREBLEND_SUBTRACT = 0x2,
		SG_TEXTUREBLEND_MULTIPLY = 0x3,
		SG_TEXTUREBLEND_ALPHA = 0x4,
		SG_TEXTUREBLEND_PRE_MULTIPLIED_ALPHA = 0x5,
		SG_TEXTUREBLEND_OVER = 0x6,
		SG_TEXTUREBLEND_IN = 0x7,
		SG_TEXTUREBLEND_OUT = 0x8,
		SG_TEXTUREBLEND_ADD_W_ALPHA = 0x9,
		SG_TEXTUREBLEND_SUBTRACT_W_ALPHA = 0xa,
		SG_TEXTUREBLEND_MULTIPLY_W_ALPHA = 0xb
	};

	/**
	 * ImageFileType specifies types of image files
	 */
	enum ImageFileType
	{
		SG_IMAGEFILETYPE_UNSUPPORTED = -1, /// and unknown or unsupported file type
		SG_IMAGEFILETYPE_BMP = 0,
		SG_IMAGEFILETYPE_DDS = 1,
		SG_IMAGEFILETYPE_GIF = 2,
		SG_IMAGEFILETYPE_JPEG = 3,
		SG_IMAGEFILETYPE_PNG = 4,
		SG_IMAGEFILETYPE_TGA = 5,
		SG_IMAGEFILETYPE_TIFF = 6,
		SG_IMAGEFILETYPE_PSD = 7
	};

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_AMBIENT = "Ambient";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_DIFFUSE = "Diffuse";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_SPECULAR = "Specular";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_OPACITY = "Opacity";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_EMISSIVE = "Emissive";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_NORMALS = "Normals";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_GROUPIDS = "GroupIds";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_DISPLACEMENT = "Displacement";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_BASECOLOR = "Basecolor";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_ROUGHNESS = "Roughness";

	/**
	 * The SG_MATERIAL_CHANNEL_[...] defines the default names of standard material textures
	 * in Simplygon.
	 */
	static const char *SG_MATERIAL_CHANNEL_METALLIC = "Metallic";

	/**
	 * The SG_IMAGEDATA_FORMAT_[...] defines the default names of standard image formats
	 * in Simplygon. L is a grayscale light
	 */
	static const char *SG_IMAGEDATA_FORMAT_L = "L";

	/**
	 * The SG_IMAGEDATA_FORMAT_[...] defines the default names of standard image formats
	 * in Simplygon. RGB is 3-component red, green, blue
	 */
	static const char *SG_IMAGEDATA_FORMAT_RGB = "RGB";

	/**
	 * The SG_IMAGEDATA_FORMAT_[...] defines the default names of standard image formats
	 * in Simplygon. RGBA is 4-component red, green, blue, alpha
	 */
	static const char *SG_IMAGEDATA_FORMAT_RGBA = "RGBA";

	/**
	 * The maximum number of texture channels supported within Simplygon.
	 */
	static const unsigned int SG_NUM_SUPPORTED_TEXTURE_CHANNELS = 256;

	/**
	 * The maximum number of color channels supported within Simplygon.
	 */
	static const unsigned int SG_NUM_SUPPORTED_COLOR_CHANNELS = 256;

	/**
	 * The maximum number of bones that can be references by one vertex within Simplygon.
	 */
	static const unsigned int SG_NUM_SUPPORTED_BONES_PER_VERTEX = 16;

	/**
	 * The maximum number of mapping layers that are supported internally by Simplygon
	 */
	static const unsigned int SG_NUM_SUPPORTED_MAPPING_LAYERS = 32;

	/**
	 * The maximum number of inputs that can be connected to any custom node within Simplygon
	 */
	static const unsigned int SG_NUM_SUPPORTED_CUSTOM_NODE_INPUTS = 16;

	/**
	 * The maximum size of shader output that can be generated by a custom node within Simplygon
	 */
	static const unsigned int SG_SUPPORTED_CUSTOM_NODE_SHADER_CODE_SIZE = 2048;


	/**
	 * \deprecated SG_BONES_PER_VERTEX is deprecated, use SG_NUM_SUPPORTED_BONES_PER_VERTEX instead
	 */
	static const unsigned int SG_BONES_PER_VERTEX = SG_NUM_SUPPORTED_BONES_PER_VERTEX;

	/** 
	 * \deprecated Deprecated values, use SG_MATERIAL_CHANNEL_[...] instead
	 */
	static const char *SG_MATERIAL_TEXTURE_AMBIENT = SG_MATERIAL_CHANNEL_AMBIENT;
	static const char *SG_MATERIAL_TEXTURE_DIFFUSE = SG_MATERIAL_CHANNEL_DIFFUSE;
	static const char *SG_MATERIAL_TEXTURE_SPECULAR = SG_MATERIAL_CHANNEL_SPECULAR;
	static const char *SG_MATERIAL_TEXTURE_OPACITY = SG_MATERIAL_CHANNEL_OPACITY;
	static const char *SG_MATERIAL_TEXTURE_EMISSIVE = SG_MATERIAL_CHANNEL_EMISSIVE;
	static const char *SG_MATERIAL_TEXTURE_NORMALS = SG_MATERIAL_CHANNEL_NORMALS;
	static const char *SG_MATERIAL_TEXTURE_GROUPIDS = SG_MATERIAL_CHANNEL_GROUPIDS;
	static const char *SG_MATERIAL_TEXTURE_DISPLACEMENT = SG_MATERIAL_CHANNEL_DISPLACEMENT;

	#ifdef _WIN32 
	#pragma deprecated( SG_BONES_PER_VERTEX )
	#pragma deprecated( SG_MATERIAL_TEXTURE_AMBIENT , SG_MATERIAL_TEXTURE_DIFFUSE , SG_MATERIAL_TEXTURE_SPECULAR )
	#pragma deprecated( SG_MATERIAL_TEXTURE_OPACITY , SG_MATERIAL_TEXTURE_EMISSIVE , SG_MATERIAL_TEXTURE_NORMALS )
	#pragma deprecated( SG_MATERIAL_TEXTURE_GROUPIDS , SG_MATERIAL_TEXTURE_DISPLACEMENT )
	#endif
	
	/**
	 * IObject is the base class for all normal classes defined within the API. The class adds safe casting into any API object, reference counting support
	 * (best used with the CountedPointer reference counted pointer class), basic names for all objects, and event handling, using observers (using objects
	 * derived from robserver)
	 */
	class IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();
		
		/** 
		 * The IsA function returns true if the object is a or is a descendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a descendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;
		
		/**
		 * The IsClassA function returns true if the class is a or is a descendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a descendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( type && (strcmp("IObject",type)==0) )
				return true;
			return false;
			}
			
		/** 
		* SafeCast makes sure the pointer is of a class that can be cast into IObject, and if this is the case, returns the pointer cast into an IObject 
		* @param ptr is the pointer to be cast into a pointer to an object of type IObject
		* @return a pointer to IObject, if the cast can be made
		*/
		static IObject *SafeCast( IObject *ptr ) { return ptr; }

		/**
		 * PrintInfo prints the contents/info of the object to the log
		 */
		virtual void PrintInfo() = 0;

		/**
		 * Adds one reference to the object.
		 */
		virtual void AddRef() = 0;

		/**
		 * Releases one reference to the object. When all references have been removed, the object is removed from memory.
		 */
		virtual void Release() = 0;
		
		/** 
		 * Sets the name of the object.
		 * @param Name is the new name of the object
		 */
		virtual void SetName( const rchar *Name ) = 0;
		
		/** 
		 * Gets the name of the object.
		 * @return The name of the object
		 */
		virtual rstring GetName() = 0;
	
		/** 
		 * Adds a user-defined observer object to the interface, that will receive any event with the specified EventId from the interface.
		 * @param Observer is the object that will receive events
		 * @param EventId the event id to listen for
		 * @return the id of the observer within the API object
		 */
		virtual rid AddObserver( robserver *Observer , rid EventId ) = 0;
		
		/** 
		 * Removes a previously added observer object
		 * @param ObserverId the id returned by AddObserver when the observer was added
		 */
		virtual void RemoveObserver( rid ObserverId ) = 0;

		virtual void *GetUserComponentArea( rid userid ) = 0;
	};

	/**
	 * a CounterPointer smart pointer to an IObject
	 */
	typedef CountedPointer<IObject> spObject;
	class IArray;
	class IRidArray;

	/**
	 * IArray is the base class for the array objects. The  object contains a dynamically
	 * allocated list of tuples of the same  length, which can be specified before the list
	 * is filled with values.
	 */
	class IArray : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IArray",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IArray pointer
		 * @return a pointer to the IArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IArray") )
				return static_cast<IArray*>(ptr);
			return NULL;
			}
		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to 1,
		 * i.e.  when the tuples are exactly one component each. Also note that  the item count
		 * should be a multiple of TupleSize. @param count the new item count
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array to copy from
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Clears the array and sets the tuple count to 0. Tuple size and name remains the same
		 * though.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Extracts tuples from this array. Note that the destination array must have the same
		 * class type and have the same tuple size as the source array. (If both arrays are
		 * descendants of ReValueArray, they can be of  different types, but the conversion
		 * is slow). @param dest the array that will store the extracted tuples @param start
		 * this array tuple index where the extraction starts @param count the number of tuples
		 * to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Returns the number of items in the array. Warning: Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same underlying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array will contain indices to the new packed
		 * array's values @return a new array with the same properties as this array but only
		 * with its unique values<br />Description of IArray: IArray is the base class for the
		 * array objects. The  object contains a dynamically allocated list of tuples of the
		 * same  length, which can be specified before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the SimplygonSDK::BaseTypes enumeration. @return the id of the array
		 * type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Appends an array to this array. Note that both arrays must be of  the same class
		 * type and have the same tuple size. (If both arrays are  descendants of ReValueArray,
		 * they can be of different types, but the  conversion is slow). @param source the array
		 * to append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Creates a new array with the same underlying data type and tuple settings as this
		 * array. To also copy the actual data, set copy_data to true. @param copy_data specify
		 * whether the data of this array should be copied along with its properties @return
		 * a copy of this array<br />Description of IArray: IArray is the base class for the
		 * array objects. The  object contains a dynamically allocated list of tuples of the
		 * same  length, which can be specified before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IArray
	 * IArray is the base class for the array objects. The  object contains a dynamically
	 * allocated list of tuples of the same  length, which can be specified before the list
	 * is filled with values.
	 */
	typedef CountedPointer<IArray> spArray;

	class IArray;
	class IRidArray;
	class IValueArray;
	class IRealArray;

	/**
	 * ReValueArray adds methods to arrays to generically  add, set and get tuples, through
	 * real values.
	 */
	class IValueArray : public IArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IValueArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IValueArray",type)==0 )
				return true;
			return IArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IValueArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IValueArray pointer
		 * @return a pointer to the IValueArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IValueArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IValueArray") )
				return static_cast<IValueArray*>(ptr);
			return NULL;
			}
		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to 1,
		 * i.e.  when the tuples are exactly one component each. Also note that  the item count
		 * should be a multiple of TupleSize. @param count the new item count
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the SimplygonSDK::BaseTypes enumeration. @return the id of the array
		 * type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array to copy from
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Returns the number of items in the array. Warning: Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Creates a new array with the same underlying data type and tuple settings as this
		 * array. To also copy the actual data, set copy_data to true. @param copy_data specify
		 * whether the data of this array should be copied along with its properties @return
		 * a copy of this array<br />Description of IArray: IArray is the base class for the
		 * array objects. The  object contains a dynamically allocated list of tuples of the
		 * same  length, which can be specified before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Appends an array to this array. Note that both arrays must be of  the same class
		 * type and have the same tuple size. (If both arrays are  descendants of ReValueArray,
		 * they can be of different types, but the  conversion is slow). @param source the array
		 * to append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Extracts tuples from this array. Note that the destination array must have the same
		 * class type and have the same tuple size as the source array. (If both arrays are
		 * descendants of ReValueArray, they can be of  different types, but the conversion
		 * is slow). @param dest the array that will store the extracted tuples @param start
		 * this array tuple index where the extraction starts @param count the number of tuples
		 * to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Clears the array and sets the tuple count to 0. Tuple size and name remains the same
		 * though.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same underlying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array will contain indices to the new packed
		 * array's values @return a new array with the same properties as this array but only
		 * with its unique values<br />Description of IArray: IArray is the base class for the
		 * array objects. The  object contains a dynamically allocated list of tuples of the
		 * same  length, which can be specified before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IValueArray
	 * ReValueArray adds methods to arrays to generically  add, set and get tuples, through
	 * real values.
	 */
	typedef CountedPointer<IValueArray> spValueArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * ReStringArray is the string implementation of ReValueArray. See ReValueArray for
	 * a description. Please note that conversions to/from real values will not work on
	 * string arrays.
	 */
	class IStringArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IStringArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IStringArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IStringArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IStringArray pointer
		 * @return a pointer to the IStringArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IStringArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IStringArray") )
				return static_cast<IStringArray*>(ptr);
			return NULL;
			}
		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items is being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem / SetRealTuple to set the items directly.
		 * @param value - the value of the item
		 */
		virtual	void AddItem( const char * value ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. The arrays must be of the same type.
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type.
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each.
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * GetBaseType returns the id of the type that the array is based on
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id - the id of the item  @param value - the new value of the item
		 */
		virtual	void SetItem( rid id , const char * value ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each.
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow).
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * SetRealItem retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to.
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id - the id of the item 
		 */
		virtual	rstring GetItem( rid id ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * SetRealItem sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to.
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IStringArray
	 * ReStringArray is the string implementation of ReValueArray. See ReValueArray for
	 * a description. Please note that conversions to/from real values will not work on
	 * string arrays.
	 */
	typedef CountedPointer<IStringArray> spStringArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IBoolArray is the bool implementation of IValueArray. See IValueArray for a description.
	 */
	class IBoolArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IBoolArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IBoolArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBoolArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBoolArray pointer
		 * @return a pointer to the IBoolArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IBoolArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IBoolArray") )
				return static_cast<IBoolArray*>(ptr);
			return NULL;
			}
		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IBoolData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , bool *dest_param ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( bool *tuple ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( bool value ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IBoolData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( bool *dest_param ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , bool value ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IBoolData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , bool *dest_param ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	bool GetItem( rid id ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , bool *tuple ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( bool *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , bool *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IBoolArray
	 * IBoolArray is the bool implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IBoolArray> spBoolArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * ICharArray is the char implementation of IValueArray. See IValueArray for a description.
	 */
	class ICharArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ICharArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ICharArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ICharArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ICharArray pointer
		 * @return a pointer to the ICharArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ICharArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ICharArray") )
				return static_cast<ICharArray*>(ptr);
			return NULL;
			}
		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	char GetItem( rid id ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , char *tuple ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( char *tuple ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( char *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::ICharData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( char *dest_param ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( char value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , char value ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::ICharData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , char *dest_param ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , char *source_items , unsigned int source_item_count ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::ICharData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , char *dest_param ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ICharArray
	 * ICharArray is the char implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<ICharArray> spCharArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IDoubleArray is the double implementation of IValueArray. See IValueArray for a description.
	 */
	class IDoubleArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IDoubleArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IDoubleArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDoubleArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDoubleArray pointer
		 * @return a pointer to the IDoubleArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IDoubleArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IDoubleArray") )
				return static_cast<IDoubleArray*>(ptr);
			return NULL;
			}
		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( double *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IDoubleData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , double *dest_param ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	double GetItem( rid id ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , double *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( double *tuple ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IDoubleData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( double *dest_param ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( double value ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IDoubleData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , double *dest_param ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , double *tuple ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , double value ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IDoubleArray
	 * IDoubleArray is the double implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IDoubleArray> spDoubleArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IFloatArray is the float implementation of IValueArray. See IValueArray for a description.
	 */
	class IFloatArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IFloatArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IFloatArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFloatArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFloatArray pointer
		 * @return a pointer to the IFloatArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IFloatArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IFloatArray") )
				return static_cast<IFloatArray*>(ptr);
			return NULL;
			}
		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , float value ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( float value ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IFloatData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , float *dest_param ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	float GetItem( rid id ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IFloatData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , float *dest_param ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , float *tuple ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( float *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IFloatData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( float *dest_param ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , float *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( float *tuple ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IFloatArray
	 * IFloatArray is the float implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IFloatArray> spFloatArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IIntArray is the int implementation of IValueArray. See IValueArray for a description.
	 */
	class IIntArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IIntArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IIntArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IIntArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IIntArray pointer
		 * @return a pointer to the IIntArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IIntArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IIntArray") )
				return static_cast<IIntArray*>(ptr);
			return NULL;
			}
		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( int *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , int *tuple ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , int *source_items , unsigned int source_item_count ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IIntData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , int *dest_param ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , int value ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( int value ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IIntData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , int *dest_param ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	int GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( int *tuple ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IIntData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( int *dest_param ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IIntArray
	 * IIntArray is the int implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IIntArray> spIntArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * ILongArray is the long implementation of IValueArray. See IValueArray for a description.
	 */
	class ILongArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ILongArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ILongArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ILongArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ILongArray pointer
		 * @return a pointer to the ILongArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ILongArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ILongArray") )
				return static_cast<ILongArray*>(ptr);
			return NULL;
			}
		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::ILongData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( long *dest_param ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( long *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , long *tuple ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::ILongData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , long *dest_param ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , long *source_items , unsigned int source_item_count ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( long *tuple ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::ILongData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , long *dest_param ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( long value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , long value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	long GetItem( rid id ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ILongArray
	 * ILongArray is the long implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<ILongArray> spLongArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IRcharArray is the rchar implementation of IValueArray. See IValueArray for a description.
	 */
	class IRcharArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRcharArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRcharArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRcharArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRcharArray pointer
		 * @return a pointer to the IRcharArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRcharArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRcharArray") )
				return static_cast<IRcharArray*>(ptr);
			return NULL;
			}
		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRcharArray
	 * IRcharArray is the rchar implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IRcharArray> spRcharArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
	 */
	class IRealArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRealArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRealArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRealArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRealArray pointer
		 * @return a pointer to the IRealArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRealArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRealArray") )
				return static_cast<IRealArray*>(ptr);
			return NULL;
			}
		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( real *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IRealData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , real *dest_param ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( real *tuple ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , real *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( real value ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IRealData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , real *dest_param ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	real GetItem( rid id ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , real value ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , real *tuple ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IRealData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( real *dest_param ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRealArray
	 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IRealArray> spRealArray;

	class IArray;
	class IRidArray;

	/**
	 * IRhandleArray is the rhandle implementation of IArray. See IArray for a description.
	 */
	class IRhandleArray : public IArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRhandleArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRhandleArray",type)==0 )
				return true;
			return IArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRhandleArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRhandleArray pointer
		 * @return a pointer to the IRhandleArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRhandleArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRhandleArray") )
				return static_cast<IRhandleArray*>(ptr);
			return NULL;
			}
		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples.
		 */
		virtual	void SetData( rhandle *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IRhandleData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , rhandle *dest_param ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array.
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Returns a range of tuples in the array.@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IRhandleData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , rhandle *dest_param ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. The arrays must be of the same type.
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items is being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem / SetTuple to set the items directly.
		 */
		virtual	void AddItem( rhandle value ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same underlying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IRhandleData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( rhandle *dest_param ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly on component each.
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items is being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem / SetTuple to set the items directly.
		 */
		virtual	void AddTuple( rhandle *tuple ) = 0;

		/**
		 * GetBaseType returns the id of the type that the array is based on
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Creates a new array with the same underlying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode.
		 */
		virtual	void SetItem( rid id , rhandle value ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns the id of the last item that is in the array. Warning! Do not confuse this
		 * id with the id of a tuple, they are only the same if TupleSize is equal to one, i.e.
		 * when the tuples are exactly on component each.
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each.
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update.
		 */
		virtual	void SetDataRange( rid start_tuple_id , rhandle *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode.
		 */
		virtual	rhandle GetItem( rid id ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode.
		 */
		virtual	void SetTuple( rid id , rhandle *tuple ) = 0;

		/**
		 * Appends an array to this array. The array must be of the  same type as this one.
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRhandleArray
	 * IRhandleArray is the rhandle implementation of IArray. See IArray for a description.
	 */
	typedef CountedPointer<IRhandleArray> spRhandleArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IRidArray is the rid implementation of IValueArray. See IValueArray for a description.
	 */
	class IRidArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRidArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRidArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRidArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRidArray pointer
		 * @return a pointer to the IRidArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRidArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRidArray") )
				return static_cast<IRidArray*>(ptr);
			return NULL;
			}
		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	rid GetItem( rid id ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( rid *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , rid *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( rid value ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( rid *tuple ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , rid value ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , rid *tuple ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IRidData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , rid *dest_param ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IRidData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( rid *dest_param ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IRidData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , rid *dest_param ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRidArray
	 * IRidArray is the rid implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IRidArray> spRidArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IShortArray is the short implementation of IValueArray. See IValueArray for a description.
	 */
	class IShortArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShortArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShortArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShortArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShortArray pointer
		 * @return a pointer to the IShortArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShortArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShortArray") )
				return static_cast<IShortArray*>(ptr);
			return NULL;
			}
		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , short *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IShortData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , short *dest_param ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( short *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IShortData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , short *dest_param ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IShortData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( short *dest_param ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( short value ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , short value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	short GetItem( rid id ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( short *tuple ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , short *tuple ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShortArray
	 * IShortArray is the short implementation of IValueArray. See IValueArray for a description.
	 */
	typedef CountedPointer<IShortArray> spShortArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IUnsignedCharArray is the uchar implementation of IValueArray. See IValueArray for
	 * a description.
	 */
	class IUnsignedCharArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedCharArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IUnsignedCharArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedCharArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedCharArray pointer
		 * @return a pointer to the IUnsignedCharArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IUnsignedCharArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IUnsignedCharArray") )
				return static_cast<IUnsignedCharArray*>(ptr);
			return NULL;
			}
		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( unsigned char *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( unsigned char value ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IUnsignedCharData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( unsigned char *dest_param ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IUnsignedCharData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , unsigned char *dest_param ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , unsigned char *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , unsigned char value ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( unsigned char *tuple ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , unsigned char *tuple ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	unsigned char GetItem( rid id ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IUnsignedCharData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , unsigned char *dest_param ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IUnsignedCharArray
	 * IUnsignedCharArray is the uchar implementation of IValueArray. See IValueArray for
	 * a description.
	 */
	typedef CountedPointer<IUnsignedCharArray> spUnsignedCharArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IUnsignedIntArray is the uint implementation of IValueArray. See IValueArray for
	 * a description.
	 */
	class IUnsignedIntArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedIntArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IUnsignedIntArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedIntArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedIntArray pointer
		 * @return a pointer to the IUnsignedIntArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IUnsignedIntArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IUnsignedIntArray") )
				return static_cast<IUnsignedIntArray*>(ptr);
			return NULL;
			}
		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , unsigned int *tuple ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( unsigned int *tuple ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IUnsignedIntData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , unsigned int *dest_param ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( unsigned int value ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IUnsignedIntData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( unsigned int *dest_param ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , unsigned int value ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , unsigned int *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IUnsignedIntData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , unsigned int *dest_param ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	unsigned int GetItem( rid id ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( unsigned int *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IUnsignedIntArray
	 * IUnsignedIntArray is the uint implementation of IValueArray. See IValueArray for
	 * a description.
	 */
	typedef CountedPointer<IUnsignedIntArray> spUnsignedIntArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IUnsignedLongArray is the ulong implementation of IValueArray. See IValueArray for
	 * a description.
	 */
	class IUnsignedLongArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedLongArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IUnsignedLongArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedLongArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedLongArray pointer
		 * @return a pointer to the IUnsignedLongArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IUnsignedLongArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IUnsignedLongArray") )
				return static_cast<IUnsignedLongArray*>(ptr);
			return NULL;
			}
		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( unsigned long value ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , unsigned long value ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , unsigned long *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( unsigned long *tuple ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	unsigned long GetItem( rid id ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , unsigned long *tuple ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IUnsignedLongData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( unsigned long *dest_param ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IUnsignedLongData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , unsigned long *dest_param ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IUnsignedLongData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , unsigned long *dest_param ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( unsigned long *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IUnsignedLongArray
	 * IUnsignedLongArray is the ulong implementation of IValueArray. See IValueArray for
	 * a description.
	 */
	typedef CountedPointer<IUnsignedLongArray> spUnsignedLongArray;

	class IValueArray;
	class IRidArray;
	class IRealArray;
	class IArray;

	/**
	 * IUnsignedShortArray is the ushort implementation of IValueArray. See IValueArray
	 * for a description.
	 */
	class IUnsignedShortArray : public IValueArray
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IUnsignedShortArray is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IUnsignedShortArray",type)==0 )
				return true;
			return IValueArray::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUnsignedShortArray pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUnsignedShortArray pointer
		 * @return a pointer to the IUnsignedShortArray object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IUnsignedShortArray *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IUnsignedShortArray") )
				return static_cast<IUnsignedShortArray*>(ptr);
			return NULL;
			}
		/**
		 * Returns all tuples in the array as a single item array.@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetData( SimplygonSDK::IUnsignedShortData *dest_param ) = 0;

		/**
		 * \deprecated GetData() with the old way to return array data is deprecated, use GetData()
		 * with the rarray interface instead.
		 */
		virtual	void GetData( unsigned short *dest_param ) = 0;

		/**
		 * CopyCombine3Tuples() combines the data from three tuples into a destination tuple.
		 * The call works like CopyCombineTuples(), but  there is three source tuples, and two
		 * alpha values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> The source
		 * array must be of the same type as this array, and have the same number of items in
		 * each tuple. This array can be used as the source array to copy within the array.
		 * @param sourceArray the array to copy from @param dest_id the tuple index to copy
		 * to @param src_id_1 the first source array tuple to copy from @param src_id_2 the
		 * second source array tuple to copy from @param src_id_3 the third source array tuple
		 * to copy from @param alpha_1 the first interpolation value @param alpha_2 the second
		 * interpolation value
		 */
		virtual	void CopyCombine3Tuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Gets a tuple in the list. The id is the id of the tuple that is being fetched. Warning!
		 * No range checking is done in  release mode @param id the id of the tuple  @param
		 * dest_param the destination tuple@param dest_param a pointer to the destination memory
		 * area
		 */
		virtual	void GetTuple( rid id , SimplygonSDK::IUnsignedShortData *dest_param ) = 0;

		/**
		 * \deprecated GetTuple() with the old way to return array data is deprecated, use GetTuple()
		 * with the rarray interface instead.
		 */
		virtual	void GetTuple( rid id , unsigned short *dest_param ) = 0;

		/**
		 * Returns a range of tuples in the array. @param start_tuple_id the first id in the
		 * range @param tuple_count the number of tuples in the range@param dest_param a pointer
		 * to the destination memory area
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , SimplygonSDK::IUnsignedShortData *dest_param ) = 0;

		/**
		 * \deprecated GetDataRange() with the old way to return array data is deprecated, use
		 * GetDataRange() with the rarray interface instead.
		 */
		virtual	void GetDataRange( rid start_tuple_id , unsigned int tuple_count , unsigned short *dest_param ) = 0;

		/**
		 * SetRealItem() sets the item at position id.  The id is the id of the item, not the
		 * tuple the item belongs to. SetRealItem() converts the value from real to the actual
		 * underlying data type. @param id the item to set @param value the real value to set
		 * the item to
		 */
		virtual	void SetRealItem( rid id , real value ) = 0;

		/**
		 * CopyRange copies a range of tuples from a source array into this  array. The arrays
		 * must have the same tuple size and base type. This array must be resized to hold the
		 * tuples before copying. The basetypes are listed in SimplygonSDK::BaseTypes. @param
		 * source_array the source array to copy from @param start_dest_id the first destination
		 * tuple id @param start_src_id the first source tuple id @param count the number of
		 * tuples to copy
		 */
		virtual	void CopyRange( IArray *source_array , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * Used to set the tuple size. Warning! Only use SetTupleSize before filling the list
		 * with values, as any  added data in the array will be trashed. @param newsize the
		 * new tuple size
		 */
		virtual	void SetTupleSize( unsigned int newsize ) = 0;

		/**
		 * Used to get the tuple size. @return the tuple size
		 */
		virtual	unsigned int GetTupleSize(  ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples from a source array into a
		 * destination tuple in this array. If InterpolateTuples id  set to true, dest_id will
		 * receive a linear interpolation of the values,  using the alpha value. If InterpolateTuples
		 * is set to false, then if alpha is less than 0.5 the contents of src_id_1 will end
		 * up in dest, else the  contents of src_id_2 will be copied. <br> dest = src_1*(1-alpha)
		 * + src_2*alpha <br> The source array must be of the same type as this array, and have
		 * the same number of items in each tuple. This array can be used as the source array
		 * to copy within the array. @param sourceArray the array to copy from @param dest_id
		 * the tuple index to copy to @param src_id_1 the first source array tuple to copy from
		 * @param src_id_2 the second source array tuple to copy from @param alpha the interpolation
		 * value
		 */
		virtual	void CopyCombineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set the array from a range of data values. Note that the array will be resized to
		 * the size of the items. Note that the source_item_count is the number of items to
		 * set, NOT the number of tuples. @param source_items the array to copy from @param
		 * source_item_count the number of items in the array
		 */
		virtual	void SetData( unsigned short *source_items , unsigned int source_item_count ) = 0;

		/**
		 * Returns true if the list is empty. @return true if empty
		 */
		virtual	bool IsEmpty(  ) = 0;

		/**
		 * CopyTuple copies one tuple in a source array to a tuple in this array. Both the dest_id
		 * and the source_id must exist in the arrays.  This array can be used as the source
		 * array to copy within the array. @param sourceArray the source array to copy from
		 * @param dest_id the tuple index in this array to copy into @param src_id the tuple
		 * index in the source array to copy from	
		 */
		virtual	void CopyTuple( IArray *sourceArray , rid dest_id , rid src_id ) = 0;

		/**
		 * Gets the value of an item in the list. The id of the item  is the exact location
		 * of the item (TupleId * TupleSize + Index  of item in tuple) Warning! No range checking
		 * is done in release mode. @param id the id of the item 
		 */
		virtual	unsigned short GetItem( rid id ) = 0;

		/**
		 * Returns the number of tuples in the list. @return the tuple count
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * Returns the number of items in the array Warning! Do not confuse this count with
		 * the count of tuples, they are only the same if TupleSize is equal to one, i.e.  when
		 * the tuples are exactly one component each. @return the number of items in the array
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Set a part of the array from a range of data values. Note that the array will be
		 * resized to contain the size of the items. Note that the source_item_count is the
		 * number of items to set, NOT the number of tuples, but start_tuple_id IS the first
		 * tuple index to update. @param start_tuple_id where to start copy to in this array
		 * @param source_items the array to copy from @param source_item_count the number of
		 * items in the array
		 */
		virtual	void SetDataRange( rid start_tuple_id , unsigned short *source_items , unsigned int source_item_count ) = 0;

		/**
		 * CompareTuples compares a tuple in this array with a tuple in another array @param
		 * otherArray the other array to compare with @param tuple_id the tuple from this array
		 * to use for comparison @param other_tuple_id the tuple from the other array to use
		 * for comparison @return 0 if the tuples are identical, 1 if an element in this array
		 * tuple in ascending order is larger and -1 if smaller
		 */
		virtual	int CompareTuples( IArray *otherArray , rid tuple_id , rid other_tuple_id ) = 0;

		/**
		 * Appends an array to this array. The array must be a descendant of ReValueArray. For
		 * best performance, append arrays of the same basic type. @param source the array to
		 * append to this array
		 */
		virtual	void AppendTuples( IArray *source ) = 0;

		/**
		 * Sets a tuple in the list. The id is the id of the tuple that is being updated. Warning!
		 * No range checking is done in  release mode. @param id the id of the tuple  @param
		 * tuple the new value(s) of the tuple 
		 */
		virtual	void SetTuple( rid id , unsigned short *tuple ) = 0;

		/**
		 * Resizes the list to the specified tuple count. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the new tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Set the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @param value the new alternative
		 * name
		 */
		virtual	void SetAlternativeName( const char * value ) = 0;

		/**
		 * Returns the id of the tuple last in the list. If the array is empty, the value is
		 * unspecified. Note: GetMaxTupleId() always returns (GetTupleCount()-1) as a signed
		 * id @return the id of the tuple last in the list
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Get the AlternativeName, which can be used by users to set an alternative name to
		 * the array, when used as field data or in a collection.  @return the alternative name
		 */
		virtual	rstring GetAlternativeName(  ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. Note! The array must be large enough to hold
		 * the copied data. @param source the source array to combine from @param idtable is
		 * the array with the tuple indices to use for combining @param blendtable the array
		 * with (alpha) blend values @param startId is the first tuple that will receive the
		 * combined values
		 */
		virtual	void IndexedCombine3( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Creates a new array with the same undelaying data type as this array. To also copy
		 * the actual data, set copy_data to true. @return the new copy of the array<br />Description
		 * of IArray: IArray is the base class for the array objects. The  object contains a
		 * dynamically allocated list of tuples of the same  length, which can be specified
		 * before the list is filled with values.
		 */
		virtual	CountedPointer<IArray> NewCopy( bool copy_data ) = 0;

		/**
		 * Works like IndexedCopy(), but uses two consecutive ids in the idtable, and a blend
		 * value from the blend table. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. Note! The array must be large enough to hold the
		 * copied data. @param source the source array to combine from @param idtable is the
		 * array with the tuple indices to use for combining @param blendtable the array with
		 * (alpha) blend values @param startId is the first tuple that will receive the combined
		 * values
		 */
		virtual	void IndexedCombine( IValueArray *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * GetRealItem() retrieves the item at position id.  The id is the id of the item, not
		 * the tuple the item belongs to. GetRealItem() converts the value from  the actual
		 * underlying data type to a real. @param id the item to get @return the converted real
		 * value of the item
		 */
		virtual	real GetRealItem( rid id ) = 0;

		/**
		 * Returns the id of the last item that is in the array. The id returned is equal to
		 * (ItemCount - 1).  Warning! Do not confuse this id with the id of a tuple, they are
		 * only the same if TupleSize is equal to one, i.e.  when the tuples are exactly one
		 * component each. @return the max item id
		 */
		virtual	rid GetMaxItemId(  ) = 0;

		/**
		 * Extracts tuples from the array. Note that the destination array must have the same
		 * classtype and have the same tuple size as the source array. (If both arrays are descendants
		 * of ReValueArray, they can be of  different types, but the conversion is slow). @param
		 * dest the array that will store the extracted tuples @param start this array tuple
		 * index where the extraction starts @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IArray *dest , rid start , unsigned int count ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates an array with the same undelying data and tuple
		 * settings as the source array.  However, NewPackedCopy only copies unique tuples,
		 * and if the index_array parameter is set, this index array will contain the same number
		 * of tuples as the source array, and  with the ids of a specific tuples within the
		 * new copy of the array.  @param index_array the optional array that will receive the
		 * indices of the remapped tuples @return the new packed array<br />Description of IArray:
		 * IArray is the base class for the array objects. The  object contains a dynamically
		 * allocated list of tuples of the same  length, which can be specified before the list
		 * is filled with values.
		 */
		virtual	CountedPointer<IArray> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Adds a tuple to the list. Reallocates the list if needed. If many items are being
		 * put into the list, use Resize to set the  size of the new list (only one reallocation
		 * needed) and then use  SetItem() / SetRealTuple() to set the items directly. @param
		 * tuple the value(s) of the tuple 
		 */
		virtual	void AddTuple( unsigned short *tuple ) = 0;

		/**
		 * GetBaseType() returns the id of the basic type that the array is based on The ids
		 * are listed in the BaseTypes enumeration @return the id of the array type
		 */
		virtual	rid GetBaseType(  ) = 0;

		/**
		 * Copies data from another array. The arrays must have the same underlying data types.
		 * @param source the source array
		 */
		virtual	void DeepCopy( IArray *source ) = 0;

		/**
		 * \deprecated fixed spelling error, use CopyCombineTuples() instead
		 */
		virtual	void CopyCobineTuples( IValueArray *sourceArray , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @param value set to true if tuples should be interpolated
		 */
		virtual	void SetInterpolateTuples( bool value ) = 0;

		/**
		 * Resizes the list of items to the exact count specified. Warning! Do not confuse this
		 * count with the count of tuples, they are only the same if TupleSize is equal to one,
		 * i.e.  when the tuples are exactly on component each. Also note that  the item count
		 * should be a multiple of TupleSize, as  TupleCount = ItemCount / TupleSize. @param
		 * count - the new number of items
		 */
		virtual	void SetItemCount( unsigned int count ) = 0;

		/**
		 * Set the interpolation flag. If set, the tuple values will be  interpolated by calls
		 * to CopyCombineTuples and CopyCombine3Tuples. If not set, then CopyCombineTuples and
		 * CopyCombine3Tuples will copy data from the tuple with the highest alpha blend value.
		 * @return the interpolation flag
		 */
		virtual	bool GetInterpolateTuples(  ) = 0;

		/**
		 * Clears the array.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Adds an item to the list, allocates memory as needed to enlarge the list. If many
		 * items are being put into the list, use Resize to set the size of the new list (only
		 * one reallocation needed) and then use SetItem() / SetTuple() to set the items directly.
		 * @param value the value of the item
		 */
		virtual	void AddItem( unsigned short value ) = 0;

		/**
		 * Copies tuples from a source array through an id table. The  id table dictates the
		 * order in which the tuples are to be copied to  this array. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  Note: All ids in the id table must
		 * be valid ids of tuples in the  source array. The id table is assumed to have a tuple
		 * size of 1. The source array and this array must have the same underlying data type,
		 * and have the same tuple size. The array must be large enough to hold the copied data.
		 * @param source is the array from which to copy tuples @param idtable is the array
		 * with the tuple indices to copy @param startId is the first tuple that will receive
		 * the copied values
		 */
		virtual	void IndexedCopy( IArray *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Sets an item in the list. The id of the item is the exact location of the item (TupleId
		 * * TupleSize + Index of item in tuple) Warning! No range checking is done in release
		 * mode. @param id the id of the item  @param value the new value of the item
		 */
		virtual	void SetItem( rid id , unsigned short value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IUnsignedShortArray
	 * IUnsignedShortArray is the ushort implementation of IValueArray. See IValueArray
	 * for a description.
	 */
	typedef CountedPointer<IUnsignedShortArray> spUnsignedShortArray;

	class IChunkedImageData;
	class IImageData;

	/**
	 * ReChunkedImageData holds chunks for ReImageData objects. ReImageData objects can
	 * be referenced, and swapped in/out of memory,  to secondary storage. This is useful
	 * for very large images that cannot be stored in-memory. ReImageData objects can be
	 * indexed in 1-,2- or 3D, and each ReImageData chunk is cloned from a source ReImageData
	 * object, at setup. Fields added to ReImageData chunks after setup will only be added
	 * into that chunk, and is not recommended.
	 */
	class IChunkedImageData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IChunkedImageData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IChunkedImageData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IChunkedImageData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IChunkedImageData pointer
		 * @return a pointer to the IChunkedImageData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IChunkedImageData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IChunkedImageData") )
				return static_cast<IChunkedImageData*>(ptr);
			return NULL;
			}
		/**
		 * Unlocks a previously referenced chunk. All references to the object should be released.
		 * The method is thread-safe.  
		 */
		virtual	void UnlockChunk3D( rid x , rid y , rid z ) = 0;

		/**
		 * Returns true if a chunk is locked. The method is thread-safe.  
		 */
		virtual	bool IsChunkLocked2D( rid x , rid y ) = 0;

		/**
		 * Returns true if a chunk is locked. The method is thread-safe.  
		 */
		virtual	bool IsChunkLocked1D( rid x ) = 0;

		/**
		 * Makes a new copy of the chunked image data This image must be fully unlocked before
		 * copying.<br />Description of IChunkedImageData: ReChunkedImageData holds chunks for
		 * ReImageData objects. ReImageData objects can be referenced, and swapped in/out of
		 * memory,  to secondary storage. This is useful for very large images that cannot be
		 * stored in-memory. ReImageData objects can be indexed in 1-,2- or 3D, and each ReImageData
		 * chunk is cloned from a source ReImageData object, at setup. Fields added to ReImageData
		 * chunks after setup will only be added into that chunk, and is not recommended.
		 */
		virtual	CountedPointer<IChunkedImageData> NewCopy( bool copy_data ) = 0;

		/**
		 * Sets the template image to use as template for creating new chunks. The template
		 * image is cloned, it can be released  after the setup. Note that SetTemplateImage
		 * must be called  before allocating image chunks.
		 */
		virtual	void SetTemplateImage( IImageData *_template ) = 0;

		/**
		 * Locks a chunk for editing, and returns an image object to the caller.  Only one lock
		 * is allowed per chunk. Use IsChunkLocked to check if a chunk is  locked before trying
		 * to lock it. If the Lock failed, because the chunk is already locked, NULL is returned.
		 * The method is thread-safe. <br />Description of IImageData: IImageData holds unpacked
		 * image data. The data is  stored in an IFieldData object as value fields. For simplicity
		 * all  images are implemented as 3D images, but has an extent of 1 in Z for 2D images,
		 * and an extent of 1 in both Y and Z for 1D images. Cube maps are stored as a 3D image
		 * with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> LockChunk3D( rid x , rid y , rid z ) = 0;

		/**
		 * Get the total X dimension size of the full image. @return the total X dimension size
		 * of the full image.
		 */
		virtual	unsigned int GetTotalXSize(  ) = 0;

		/**
		 * Returns true if a chunk is locked. The method is thread-safe.  
		 */
		virtual	bool IsChunkLocked3D( rid x , rid y , rid z ) = 0;

		/**
		 * Get the number of image chunks in the Y dimension. @return the number of image chunks
		 * in the Y dimension.
		 */
		virtual	unsigned int GetYSize(  ) = 0;

		/**
		 * Get the X dimension size of the template image used to create the chunks. @return
		 * the X dimension size of the template image used to create the chunks.
		 */
		virtual	unsigned int GetTemplateXSize(  ) = 0;

		/**
		 * Get the Y dimension size of the template image used to create the chunks. @return
		 * the Y dimension size of the template image used to create the chunks.
		 */
		virtual	unsigned int GetTemplateYSize(  ) = 0;

		/**
		 * Locks a chunk for editing, and returns an image object to the caller.  Only one lock
		 * is allowed per chunk. Use IsChunkLocked to check if a chunk is  locked before trying
		 * to lock it. If the Lock failed, because the chunk is already locked, NULL is returned.
		 * The method is thread-safe. <br />Description of IImageData: IImageData holds unpacked
		 * image data. The data is  stored in an IFieldData object as value fields. For simplicity
		 * all  images are implemented as 3D images, but has an extent of 1 in Z for 2D images,
		 * and an extent of 1 in both Y and Z for 1D images. Cube maps are stored as a 3D image
		 * with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> LockChunk2D( rid x , rid y ) = 0;

		/**
		 * Unlocks a previously referenced chunk. All references to the object should be released.
		 * The method is thread-safe.  
		 */
		virtual	void UnlockChunk1D( rid x ) = 0;

		/**
		 * Unlocks a previously referenced chunk. All references to the object should be released.
		 * The method is thread-safe.  
		 */
		virtual	void UnlockChunk2D( rid x , rid y ) = 0;

		/**
		 * Get the total Y dimension size of the full image. @return the total Y dimension size
		 * of the full image.
		 */
		virtual	unsigned int GetTotalYSize(  ) = 0;

		/**
		 * Set the number of image chunks in the X dimension. @param _xs the desired number
		 * of chunks in the X dimension.
		 */
		virtual	void Set1DSize( unsigned int _xs ) = 0;

		/**
		 * Deep copies (with template) the data from another image. The source image must be
		 * fully unlocked before copying.
		 */
		virtual	void DeepCopy( IChunkedImageData *source , bool copy_data ) = 0;

		/**
		 * Get the Z dimension size of the template image used to create the chunks. @return
		 * the Z dimension size of the template image used to create the chunks.
		 */
		virtual	unsigned int GetTemplateZSize(  ) = 0;

		/**
		 * Clears all data from the image, and removes all data fields. The template image is
		 * kept, but can be replaced using SetTemplateImage  before calling one of the SetXDSize
		 * methods. Any lock that was hold in the image is automatically released.
		 */
		virtual	void Reset(  ) = 0;

		/**
		 * Get the number of image chunks in the X dimension. @return the number of image chunks
		 * in the X dimension.
		 */
		virtual	unsigned int GetXSize(  ) = 0;

		/**
		 * Get the number of image chunks in the Z dimension. @return the number of image chunks
		 * in the Z dimension.
		 */
		virtual	unsigned int GetZSize(  ) = 0;

		/**
		 * Locks a chunk for editing, and returns an image object to the caller.  Only one lock
		 * is allowed per chunk. Use IsChunkLocked to check if a chunk is  locked before trying
		 * to lock it. If the Lock failed, because the chunk is already locked, NULL is returned.
		 * The method is thread-safe. <br />Description of IImageData: IImageData holds unpacked
		 * image data. The data is  stored in an IFieldData object as value fields. For simplicity
		 * all  images are implemented as 3D images, but has an extent of 1 in Z for 2D images,
		 * and an extent of 1 in both Y and Z for 1D images. Cube maps are stored as a 3D image
		 * with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> LockChunk1D( rid x ) = 0;

		/**
		 * Set the number of image chunks in the X and Y dimensions. @param _xs the desired
		 * number of chunks in the X dimension. @param _ys the desired number of chunks in the
		 * X dimension.
		 */
		virtual	void Set2DSize( unsigned int _xs , unsigned int _ys ) = 0;

		/**
		 * Set the number of image chunks in the X, Y and Z dimensions. @param _xs the desired
		 * number of chunks in the X dimension. @param _ys the desired number of chunks in the
		 * X dimension. @param _zs the desired number of chunks in the X dimension.
		 */
		virtual	void Set3DSize( unsigned int _xs , unsigned int _ys , unsigned int _zs ) = 0;

		/**
		 * Get the total Z dimension size of the full image. @return the total Z dimension size
		 * of the full image.
		 */
		virtual	unsigned int GetTotalZSize(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IChunkedImageData
	 * ReChunkedImageData holds chunks for ReImageData objects. ReImageData objects can
	 * be referenced, and swapped in/out of memory,  to secondary storage. This is useful
	 * for very large images that cannot be stored in-memory. ReImageData objects can be
	 * indexed in 1-,2- or 3D, and each ReImageData chunk is cloned from a source ReImageData
	 * object, at setup. Fields added to ReImageData chunks after setup will only be added
	 * into that chunk, and is not recommended.
	 */
	typedef CountedPointer<IChunkedImageData> spChunkedImageData;

	class IFieldData;
	class IRidArray;
	class IRealArray;
	class IValueArray;

	/**
	 * IFieldData represents multiple fields of data. Each  field is implemented as an IValueArray
	 * object, that has a unique  name, and can have complex components (such as scalars,
	 * vectors,  quaternions, tensors or matrices).  All fields are assumed to be of the
	 * same length. IFieldData can be  seen as an array with complex tuples, where the component
	 * can be of  different types.
	 */
	class IFieldData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IFieldData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IFieldData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IFieldData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IFieldData pointer
		 * @return a pointer to the IFieldData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IFieldData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IFieldData") )
				return static_cast<IFieldData*>(ptr);
			return NULL;
			}
		/**
		 * Returns the handle of the first field. If no  fields are added to the object, NULL
		 * is returned. @return the handle of the first field
		 */
		virtual	rhandle GetFirstFieldHandle(  ) = 0;

		/**
		 * Appends another field data object to this object. The fields are allowed to be setup
		 * differently, but then comes at a significant performance penalty. If fields in the
		 * other field data object is missing in this object, these will be added, and the items
		 * in the old tuples will be set to 0.  @param other the field data object that is appended
		 * @param add_missing_fields if set to true, missing fields will be added to this field
		 * data object.
		 */
		virtual	void AppendTuples( IFieldData *other , bool add_missing_fields ) = 0;

		/**
		 * Returns the id of the last tuple in the array. If the array is empty, the value is
		 * undefined. @return the id of the last tuple in the array
		 */
		virtual	rid GetMaxTupleId(  ) = 0;

		/**
		 * Compares the field setup of this field data object to another  field data object.
		 * If the setups are not identical, false is returned.  Note! IsSetupIdenticalTo will
		 * return false even if the same fields  exist in both field data objects, but are not
		 * in the same order.  @param other The other field data object used for comparison
		 * @return true if the field data objects are identical
		 */
		virtual	bool IsSetupIdenticalTo( IFieldData *other ) = 0;

		/**
		 * Adds a field based on a base type. Only IValueArray objects are allowed. The created
		 * and added object is returned. @param base_type should be a base type listed in SimplygonSDK::BaseTypes
		 * @param tuple_size the desired tuple size @param name the name of the new field @return
		 * a pointer to the new field<br />Description of IValueArray: ReValueArray adds methods
		 * to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeField( rid base_type , unsigned int tuple_size , const char * name ) = 0;

		/**
		 * CopyRange() copies a range of tuples from a source field object into this  field
		 * object. The field objects must have the same field setup. This field object must
		 * be resized to hold the tuples before copying. @param source the source field object
		 * to copy from @param start_dest_id the first destination tuple id @param start_src_id
		 * the first source tuple id @param count the number of tuples to copy
		 */
		virtual	void CopyRange( IFieldData *source , rid start_dest_id , rid start_src_id , unsigned int count ) = 0;

		/**
		 * CopyCombine3Tuples combines the data from three tuples into a destination tuple.
		 * The call works like CobineTuples, but  there is three source tuples, and two alpha
		 * values. the destination will be weighted by the values: <br> alpha_3 = 1-(alpha_1
		 * + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> This field
		 * data object can be used as the source field data object  to copy within the object.
		 * @param source the field data source to combine from @param dest_id the tuple index
		 * to put the combined results into in this field data @param src_id_1 the first tuple
		 * index to use for combining from the field data source @param src_id_2 the second
		 * tuple index to use for combining from the field data source @param src_id_3 the third
		 * tuple index to use for combining from the field data source @param alpha_1 the first
		 * interpolation value used for combining the source tuples @param alpha_2 the second
		 * interpolation value used for combining the source tuples
		 */
		virtual	void CopyCombine3Tuples( IFieldData *source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Returns the next handle, or NULL if no more fields exist in the object. @param hand
		 * the current handle @return the handle after the parameter handle
		 */
		virtual	rhandle GetNextFieldHandle( rhandle hand ) = 0;

		/**
		 * Returns the id of the field with the highest id. NOTE! If no fields exist in the
		 * field data object, the return is undefined. @return the id of the field with the
		 * highest id
		 */
		virtual	rid GetMaxFieldId(  ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. <br> Does the blend: dest = src1*blend1 +
		 * src2*blend2 + src3*(1-(blend1+blend2)) <br> The FieldData must have enough tuples
		 * to hold the new data. @param source the field data to combine from @param idtable
		 * array containing the tuple indices to combine @param blendtable array containing
		 * the blend weights @param startId the tuple to begin putting the combinations into
		 */
		virtual	void IndexedCombine3( IFieldData *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Adds a field. The field must have a unique name set. @param field the array to add
		 * to the field data
		 */
		virtual	void AddField( IValueArray *field ) = 0;

		/**
		 * Returns the number of fields in the field data object. The ids of the fields range
		 * from 0 through (GetFieldCount()-1) @return the number of fields in the field data
		 * object
		 */
		virtual	unsigned int GetFieldCount(  ) = 0;

		/**
		 * Copies tuples from a source field data object through an  id table. The id table
		 * dictates the order in which the tuples are  to be copied. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  <br> Note! All ids in the id table
		 * must be valid ids of tuples in the  source field data object. The id table is assumed
		 * to have a tuple  size of 1. The source and this field data object must have the 
		 * same underlaying data fields, of the same type and the same tuple sizes. The FieldData
		 * must have enough tuples to hold the new data. @param source the source field data
		 * object to copy from @param idtable array containing the tuple indices to copy @param
		 * startId the first tuple to begin copy into
		 */
		virtual	void IndexedCopy( IFieldData *source , IRidArray *idtable , rid startId ) = 0;

		/**
		 * Creates another field data object with the same field  setup. To also copy the data
		 * to the new object, set copy_data to true. @param copy_data true if data should be
		 * copied along with the field properties @return A copy of this field data<br />Description
		 * of IFieldData: IFieldData represents multiple fields of data. Each  field is implemented
		 * as an IValueArray object, that has a unique  name, and can have complex components
		 * (such as scalars, vectors,  quaternions, tensors or matrices).  All fields are assumed
		 * to be of the same length. IFieldData can be  seen as an array with complex tuples,
		 * where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> NewCopy( bool copy_data ) = 0;

		/**
		 * Removes a field. Removing a field causes the remaining fields to be remapped to new
		 * ids. @param name the name of the field
		 */
		virtual	void SafeRemoveField( const char * name ) = 0;

		/**
		 * Retrieves a field from its index in the field data. @param id the id of the field
		 * @return the field if it exists, otherwise NULL <br />Description of IValueArray:
		 * ReValueArray adds methods to arrays to generically  add, set and get tuples, through
		 * real values.
		 */
		virtual	CountedPointer<IValueArray> GetFieldWithId( rid id ) = 0;

		/**
		 * Copies tuples from a source field data object through an  id table. The id table
		 * dictates the order in which the tuples are  to be copied. E.g. If the first item
		 * in the id table has the value 14, then the tuple with id 14 in the source array will
		 * be copied  to the first tuple in this array.  <br> Note! All ids in the id table
		 * must be valid ids of tuples in the  source field data object. The id table is assumed
		 * to have a tuple  size of 1. The source and this field data object must have the 
		 * same underlaying data fields, of the same type and the same tuple sizes. The FieldData
		 * must have enough tuples to hold the new data. @param source the source field data
		 * object to copy from @param idtable pointer to indices of tuples to copy @param idtable_cnt
		 * the number of indices to copy @param startId the first tuple to begin copy into
		 */
		virtual	void IndexedCopy( IFieldData *source , rid *idtable , unsigned int idtable_cnt , rid startId ) = 0;

		/**
		 * Clears all tuples from the fields. The fields,  however, are not removed.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * CopyCombineTuples() combines the data from two tuples into a  destination tuple.
		 * This field data object can be used as the source  field data object to copy within
		 * the object. @param source the field data source to combine from @param dest_id the
		 * tuple index to put the combined results into in this field data @param src_id_1 the
		 * first tuple index to use for combining from the field data source @param src_id_2
		 * the second tuple index to use for combining from the field data source @param alpha
		 * the interpolation value used for combining the source tuples
		 */
		virtual	void CopyCombineTuples( IFieldData *source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Retrieves a field. If the field was not found, the return is NULL. @param name the
		 * name of the field to fetch @return the field if it exists, otherwise NULL<br />Description
		 * of IValueArray: ReValueArray adds methods to arrays to generically  add, set and
		 * get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetField( const char * name ) = 0;

		/**
		 * Works like IndexedCombine(), but with three ids that are combined through two blend
		 * values in the blendtable. The idtable contains (idtable_cnt*3) indices and blendtable
		 * contains (idtable_cnt*2) blend values. <br> Does the blend: dest = src1*blend1 +
		 * src2*blend2 + src3*(1-(blend1+blend2)) <br> The FieldData must have enough tuples
		 * to hold the new data. @param source the field data to combine from @param idtable
		 * array containing the tuple indices to combine @param blendtable pointer to the blend
		 * weights @param idtable_cnt the number of sets of indices to combine @param startId
		 * the tuple to begin putting the combinations into
		 */
		virtual	void IndexedCombine3( IFieldData *source , rid *idtable , real *blendtable , unsigned int idtable_cnt , rid startId ) = 0;

		/**
		 * Returns 1 if no tuples exist in the field data. @return 1 if empty, else 0
		 */
		virtual	int IsEmpty(  ) = 0;

		/**
		 * Returns the field associated with the specified handle. @param hand the handle to
		 * the requested field @return the requested field<br />Description of IValueArray:
		 * ReValueArray adds methods to arrays to generically  add, set and get tuples, through
		 * real values.
		 */
		virtual	CountedPointer<IValueArray> GetFieldWithHandle( rhandle hand ) = 0;

		/**
		 * Removes a field. Removing a field causes the remaining fields to be remapped to new
		 * ids. Note that the field must  exist. If not, the method will return error. To remove
		 * a field that may not exist, use SafeRemoveField @param name the name of the field
		 */
		virtual	void RemoveField( const char * name ) = 0;

		/**
		 * Resizes the list to the specified tuplecount. If the list is enlarged, the new tuples
		 * will contain unspecified data. @param tuplecount the desired tuple count
		 */
		virtual	void SetTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Adds a number of tuples to the current tuple count. @param tuplecount the desired
		 * number of tuples to add
		 */
		virtual	void AddTupleCount( unsigned int tuplecount ) = 0;

		/**
		 * Returns the number of tuples. @return the number of tuples in the field data
		 */
		virtual	unsigned int GetTupleCount(  ) = 0;

		/**
		 * CopyTuple() copies one tuple to another. Both the dest_id and the source_id must
		 * exist in the array. This field data object can be used as the source field data object
		 * to copy within the object. @param source the source field data to copy from @param
		 * dest_id the tuple index to copy into in this field data @param src_id the tuple index
		 * to copy from in the source field data
		 */
		virtual	void CopyTuple( IFieldData *source , rid dest_id , rid src_id ) = 0;

		/**
		 * Clears all fields from the object. Releases all data in the object.
		 */
		virtual	void RemoveAllFields(  ) = 0;

		/**
		 * Like NewCopy, NewPackedCopy creates a field data object with the same underlying
		 * data and tuple settings as the source field data object.  However, NewPackedCopy
		 * only copies unique tuples, and if the index_array parameter is set, this index array
		 * will contain the same number of tuples as the source  field data object, and with
		 * the ids of a specific tuples within the new copy of the  field data object.  @param
		 * index_array will contain indices to the new packed field data values @return A packed
		 * copy of this field data<br />Description of IFieldData: IFieldData represents multiple
		 * fields of data. Each  field is implemented as an IValueArray object, that has a unique
		 * name, and can have complex components (such as scalars, vectors,  quaternions, tensors
		 * or matrices).  All fields are assumed to be of the same length. IFieldData can be
		 * seen as an array with complex tuples, where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> NewPackedCopy( IRidArray *index_array ) = 0;

		/**
		 * Copies the field setup and data from another object. To only copy the setup, set
		 * copy_data to false. @param source the source array to copy from @param copy_data
		 * true if the data should be copied along with the field data properties
		 */
		virtual	void DeepCopy( IFieldData *source , bool copy_data ) = 0;

		/**
		 * Works like IndexedCopy, but uses two consecutive ids in the idtable, and a blend
		 * value from the blendtable. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. <br> Does the blend: dest = src1*(1-blend) + src2*blend
		 * <br> The FieldData must have enough tuples to hold the new data. @param source the
		 * field data to combine from @param idtable array containing the tuple indices to combine
		 * @param blendtable array containing the blend weights @param startId the tuple to
		 * begin putting the combinations into
		 */
		virtual	void IndexedCombine( IFieldData *source , IRidArray *idtable , IRealArray *blendtable , rid startId ) = 0;

		/**
		 * Works like IndexedCopy, but uses two consecutive ids in the idtable, and a blend
		 * value from the blendtable. The idtable contains (idtable_cnt*2) indices and blendtable
		 * contains idtable_cnt blend values. <br> Does the blend: dest = src1*(1-blend) + src2*blend
		 * <br> The FieldData must have enough tuples to hold the new data. @param source the
		 * field data to combine from @param idtable array containing the tuple indices to combine
		 * @param blendtable pointer to the blend weights @param idtable_cnt the number of indices
		 * to combine @param startId the tuple to begin putting the combinations into
		 */
		virtual	void IndexedCombine( IFieldData *source , rid *idtable , real *blendtable , unsigned int idtable_cnt , rid startId ) = 0;

		/**
		 * Extracts a range of tuples from this object. The receiving object is assumed to have
		 * exactly the same data fields as this object.  @param start the id of the first tuple
		 * that is extracted @param count the number of tuples to extract
		 */
		virtual	void ExtractTuples( IFieldData *dest , rid start , unsigned int count ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IFieldData
	 * IFieldData represents multiple fields of data. Each  field is implemented as an IValueArray
	 * object, that has a unique  name, and can have complex components (such as scalars,
	 * vectors,  quaternions, tensors or matrices).  All fields are assumed to be of the
	 * same length. IFieldData can be  seen as an array with complex tuples, where the component
	 * can be of  different types.
	 */
	typedef CountedPointer<IFieldData> spFieldData;

	class IGeometryData;
	class IPackedGeometryData;
	class IRidArray;
	class IRealArray;
	class IBoolArray;
	class IValueArray;
	class IFieldData;
	class IMatrix4x4;

	/**
	 * IGeometryData represents a geometric structure  consisting of point data (Vertices)
	 * and topological data (Triangles). IGeometryData may represent a whole geometric object,
	 * but can also be used by streaming data filters, and in this way, only represents
	 * a part of the object. <br><br> Different fields in the Vertices and Triangles fields
	 * data  objects will contain point data and topological data. The standard  naming
	 * convention used in the filters/renderers are as follows: (Case sensitive naming,
	 * other fields may also be present) <br><br> 'Coords' <br> Positional coordinates of
	 * a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0' -
	 * 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
	 * real field. By convention, the existing fields must be sequential, and  must start
	 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
	 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
	 * <br> The id of the primitive's current vertex.  This field is present even if the
	 * vertex data	is directly specified in the  primitive's data, to specify topology.
	 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
	 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
	 * in the object, but the other fields are optional. Also, there can exist user fields.
	 */
	class IGeometryData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGeometryData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryData pointer
		 * @return a pointer to the IGeometryData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGeometryData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGeometryData") )
				return static_cast<IGeometryData*>(ptr);
			return NULL;
			}
		/**
		 * \deprecated RemoveBoneIds() is deprecated, use RemoveBoneWeights() instead.Function
		 * is empty, does now nothing. BoneIds are added/removed when AddBoneWeights()/RemoveBoneWeights()
		 * is called.
		 */
		virtual	SGDEPRECATED void RemoveBoneIds(  ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the vertex fields. @return the vertex
		 * fields<br />Description of IFieldData: IFieldData represents multiple fields of data.
		 * Each  field is implemented as an IValueArray object, that has a unique  name, and
		 * can have complex components (such as scalars, vectors,  quaternions, tensors or matrices).
		 * All fields are assumed to be of the same length. IFieldData can be  seen as an array
		 * with complex tuples, where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> GetVertices(  ) = 0;

		/**
		 * \deprecated GetTriangleVertices() is deprecated, use GetCorners() instead.GetTriangleVertices()
		 * is renamed GetCorners()<br />Description of IFieldData: IFieldData represents multiple
		 * fields of data. Each  field is implemented as an IValueArray object, that has a unique
		 * name, and can have complex components (such as scalars, vectors,  quaternions, tensors
		 * or matrices).  All fields are assumed to be of the same length. IFieldData can be
		 * seen as an array with complex tuples, where the component can be of  different types.
		 */
		virtual	SGDEPRECATED CountedPointer<IFieldData> GetTriangleVertices(  ) = 0;

		/**
		 * Removes invalid triangles and vertices not referenced by any triangle. If any vertices
		 * are removed, the  triangles will be remapped to the new compacted vertex field. @param
		 * only_compact_triangles if true, no vertices will be removed.
		 */
		virtual	void Compact( bool only_compact_triangles ) = 0;

		/**
		 * Tests if the extents of the geometry fully contain all vertex coordinates. Note!
		 * ExtentsContainCoords() checks all vertices in the geometry, regardless to whether
		 * the vertex is referenced by any triangle. Use Compact() to remove any non-referenced
		 * vertex before  calling ExtentsContainCoords. @return true if geometry fully contain
		 * all vertex coordinates
		 */
		virtual	bool ExtentsContainCoords(  ) = 0;

		/**
		 * Adds the GroupIds field in the triangles. (Field name: "GroupIds", Tuple size: 1
		 * , Stored as: triangle attribute)
		 */
		virtual	void AddGroupIds(  ) = 0;

		/**
		 * Each tuple in the "vertex_pairs" array contains the start-vertex and end-vertex of
		 * a half-edge in the geometry. If a half-edge is found from a tuple in the "vertex_pairs"
		 * array, the edge-id of that half-edge will be stored in the edge_ids array. Do note:
		 * the half-edges are directed, so if you want all half-edges that contains 2 vertices,
		 * you need to add the tuple twice. O @param vertex_pairs is an array with tuplesize
		 * 2, which contains start and end-vertex of the edges you want to find. @param edge_ids
		 * will contain all edge-ids that were found from the vertex-pairs. The function will
		 * replace all previous data in this array. 
		 */
		virtual	void FindEdgeIdsFromVertexPairs( IRidArray *vertex_pairs , IRidArray *edge_ids ) = 0;

		/**
		 * AddTriangles increases the triangle count by the specified value. @param count the
		 * number of new triangles to add
		 */
		virtual	void AddTriangles( unsigned int count ) = 0;

		/**
		 * Adds the MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple size:
		 * 1 , Stored as: triangle attribute)
		 */
		virtual	void AddMaterialIds(  ) = 0;

		/**
		 * \deprecated GetSpecularColors() is deprecated, use GetColors() instead.SpecularColors
		 * is now an alias for 'Colors1'<br />Description of IRealArray: IRealArray is the real
		 * implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	SGDEPRECATED CountedPointer<IRealArray> GetSpecularColors(  ) = 0;

		/**
		 * \deprecated CopyTriangleVertex() is deprecated, use CopyCorner() instead.CopyTriangleVertex()
		 * is renamed CopyCorner() CopyCombineTriangleVertices() is renamed CopyCombineCorners()
		 * CopyCombine3TriangleVertices() is renamed CopyCombine3Corners()
		 */
		virtual	SGDEPRECATED void CopyTriangleVertex( IGeometryData *source , rid dest_id , rid src_id ) = 0;

		/**
		 * combines the fields of three triangles via barycentric coordinates. <br> alpha_3
		 * = 1-(alpha_1 + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3
		 * <br> @param source the IGeometryData object to combine from @param dest_id the triangle
		 * id to replace in this IGeometryData object @param src_id_1 the first triangle id
		 * to combine from @param src_id_2 the second triangle id to combine from @param src_id_3
		 * the third triangle id to combine from @param alpha_1 the first interpolation value
		 * @param alpha_1 the second interpolation value
		 */
		virtual	void CopyCombine3Triangles( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Converts the handedness of the triangle winding, coords, normals and texture coordinates
		 * of the geometry from left-handed to right-handed coordinate systems and vice versa.
		 * Simplygon generally uses right-handed coordinates, so this conversion needs to be
		 * done before processing any left-handed geometry
		 */
		virtual	void ConvertHandedness(  ) = 0;

		/**
		 * Adds a Color field in the corners.  The valid id range of the level parameter is
		 * 0-255, which equals fields  'Colors0' - 'Colors255' <br>(Field name: "Colors0" -
		 * "Colors255", Tuple size: 4 , Stored as: Corner attribute) @param level the color
		 * level (0-255)
		 */
		virtual	void AddColors( rid level ) = 0;

		/**
		 * Adds a custom field. To be able to add a field, it must have a name that does not
		 * conflict with the existing custom fields. @param field the custom field to add to
		 * the IGeometryData object
		 */
		virtual	void AddCustomField( IValueArray *field ) = 0;

		/**
		 * Removes a user-specified vertex field. @param name the name of the user vertex field
		 * to be removed from the IGeometryData object
		 */
		virtual	void RemoveUserVertexField( const char * name ) = 0;

		/**
		 * Removes the GroupIds field in the triangles. (Field name: "GroupIds", Tuple size:
		 * 1 , Stored as: triangle attribute)
		 */
		virtual	void RemoveGroupIds(  ) = 0;

		/**
		 * Removes a custom field. @param name the name of the custom field to remove from the
		 * IGeometryData object
		 */
		virtual	void RemoveCustomField( const char * name ) = 0;

		/**
		 * Gets the GroupIds field in the triangles. (Field name: "GroupIds", Tuple size: 1
		 * , Stored as: triangle attribute)<br />Description of IRidArray: IRidArray is the
		 * rid implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRidArray> GetGroupIds(  ) = 0;

		/**
		 * Gets the number of triangles in the geometry. The number of corners is always set
		 * to (TriangleCount*3), so there is no specific method to set the number of corners.
		 * @return the number of
		 */
		virtual	unsigned int GetTriangleCount(  ) = 0;

		/**
		 * Gets the VertexIds field in the corners. @return the VertexIds field <br />Description
		 * of IRidArray: IRidArray is the rid implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRidArray> GetVertexIds(  ) = 0;

		/**
		 * Welds all vertices in the geometry that are closer than the welding threshold. Non-referenced
		 * vertices will not be removed, only the vertex indices will be remapped. Call Compact()
		 * to clean up  the geometry and free up memory. @param threshold the welding threshold
		 * distance
		 */
		virtual	void Weld( real threshold ) = 0;

		/**
		 * Adds a user-specified corner field. To be able to add a field, it must have a name
		 * that does not  conflict with the existing corner fields. @param field the field to
		 * add into the IGeometryData object
		 */
		virtual	void AddUserCornerField( IValueArray *field ) = 0;

		/**
		 * Removes the VertexLocks field for the vertices. If the value for a vertex is true,
		 * then the vertex should be locked,  and not be removed in the collapse-process. (Field
		 * name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void RemoveVertexLocks(  ) = 0;

		/**
		 * \deprecated RemoveUserTriangleVertexField() is deprecated, use RemoveUserCornerField()
		 * instead.AddUserTriangleVertexField() is renamed AddUserCornerField() RemoveUserTriangleVertexField()
		 * is renamed RemoveUserCornerField() GetUserTriangleVertexField is renamed GetUserCornerField()
		 */
		virtual	SGDEPRECATED void RemoveUserTriangleVertexField( const char * name ) = 0;

		/**
		 * Removes the Normals field in the corners.  <br>(Field name: "Normals" , Tuple size:
		 * 3 , Stored as: Corner attribute)
		 */
		virtual	void RemoveNormals(  ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the triangle fields @return the triangle
		 * field data object<br />Description of IFieldData: IFieldData represents multiple
		 * fields of data. Each  field is implemented as an IValueArray object, that has a unique
		 * name, and can have complex components (such as scalars, vectors,  quaternions, tensors
		 * or matrices).  All fields are assumed to be of the same length. IFieldData can be
		 * seen as an array with complex tuples, where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> GetTriangles(  ) = 0;

		/**
		 * Gets a user-specified triangle field. @param name the name of the triangle field
		 * to get from the IGeometryData object @return the requested triangle field<br />Description
		 * of IValueArray: ReValueArray adds methods to arrays to generically  add, set and
		 * get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetUserTriangleField( const char * name ) = 0;

		/**
		 * \deprecated CopyCombineTriangleVertices() is deprecated, use CopyCombineCorners()
		 * instead.CopyTriangleVertex() is renamed CopyCorner() CopyCombineTriangleVertices()
		 * is renamed CopyCombineCorners() CopyCombine3TriangleVertices() is renamed CopyCombine3Corners()
		 */
		virtual	SGDEPRECATED void CopyCombineTriangleVertices( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Gets the Coords field in the vertices. (Field name: "Coords", Tuple size: 3 , Stored
		 * as: Vertex attribute) @return the array of coords<br />Description of IRealArray:
		 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetCoords(  ) = 0;

		/**
		 * Adds a user-specified vertex field. To be able to add a field, it must have a name
		 * that does not  conflict with the existing vertex fields. @param field the field to
		 * add to this IGeometryData object
		 */
		virtual	void AddUserVertexField( IValueArray *field ) = 0;

		/**
		 * \deprecated AddUserTriangleVertexField() is deprecated, use AddUserCornerField()
		 * instead.AddUserTriangleVertexField() is renamed AddUserCornerField() RemoveUserTriangleVertexField()
		 * is renamed RemoveUserCornerField() GetUserTriangleVertexField is renamed GetUserCornerField()
		 */
		virtual	SGDEPRECATED void AddUserTriangleVertexField( IValueArray *field ) = 0;

		/**
		 * Expands the Vertices field data so that there exists one vertex  for each of the
		 * three corners of each triangle in the geometry. The vertices will be organized identical
		 * to the Corners field. The triangles will be remapped to use the new vertices correctly.
		 * Expanding the vertex field is required to be able to extract a range of the geometry,
		 * and to be able to stream it.  Note! This will lead to increased memory requirement,
		 * as vertex  data is not shared among neigbouring triangles. It also removes the connectivity
		 * information of the triangles, and effectively  detaches all triangles from one another.
		 * This call may replace  fields in the Vertices field data. Requery any previously
		 * cached  field pointer after the call. All user fields are copied as well.
		 */
		virtual	void ExpandVertices(  ) = 0;

		/**
		 * Copies all fields in the specified corner in the source geometry to this geometry's
		 * corner.  @param source the IGeometryData object to copy from @param dest_id the vertex
		 * id to replace in this IGeometryData object @param src_id the id of the vertex to
		 * copy
		 */
		virtual	void CopyCorner( IGeometryData *source , rid dest_id , rid src_id ) = 0;

		/**
		 * Sets the number of triangles in the geometry. The number of corners is always set
		 * to (TriangleCount*3), so there is no specific method to set the number of corners.
		 * @param count the desired new triangle count
		 */
		virtual	void SetTriangleCount( unsigned int count ) = 0;

		/**
		 * Adds a user-specified triangle field. To be able to add a field, it must have a name
		 * that does not  conflict with the existing triangle fields. @param field the triangle
		 * field to add to the IGeometryData object
		 */
		virtual	void AddUserTriangleField( IValueArray *field ) = 0;

		/**
		 * \deprecated CopyCombine3TriangleVertices() is deprecated, use CopyCombine3Corners()
		 * instead.CopyTriangleVertex() is renamed CopyCorner() CopyCombineTriangleVertices()
		 * is renamed CopyCombineCorners() CopyCombine3TriangleVertices() is renamed CopyCombine3Corners()
		 */
		virtual	SGDEPRECATED void CopyCombine3TriangleVertices( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Gets a custom field. @param name the name of the custom field to get from the IGeometryData
		 * object @return the requested custom field<br />Description of IValueArray: ReValueArray
		 * adds methods to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetCustomField( const char * name ) = 0;

		/**
		 * Get the inferior (minimum) extent of the geometry @param dest_param receives the
		 * inferior@param dest_param a pointer to the destination memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Set the inferior (minimum) extent of the geometry @param vec the new inferior
		 */
		virtual	void SetInf( real vec[3] ) = 0;

		/**
		 * Extracts specified triangles from the geometry. The destination geometry will contain
		 * the triangles and vertices.  The vertices in the destination will be expanded so
		 * that there exists one vertex  for each of the three corners of each triangle in the
		 * geometry. @param dest the IGeometryData object that is written to @param triangle_ids
		 * the list of triangles indices to extract
		 */
		virtual	void ExtractTriangles( IGeometryData *dest , IRidArray *triangle_ids ) = 0;

		/**
		 * \deprecated GetUserTriangleVertexField() is deprecated, use GetUserCornerField()
		 * instead.AddUserTriangleVertexField() is renamed AddUserCornerField() RemoveUserTriangleVertexField()
		 * is renamed RemoveUserCornerField() GetUserTriangleVertexField is renamed GetUserCornerField()<br
		 * />Description of IValueArray: ReValueArray adds methods to arrays to generically
		 * add, set and get tuples, through real values.
		 */
		virtual	SGDEPRECATED CountedPointer<IValueArray> GetUserTriangleVertexField( const char * name ) = 0;

		/**
		 * Adds the VertexWeighting field for the vertices. The weights are used to determine
		 * how important it is to keep the vertices when the geometry is reduced. 1 means the
		 * weight won't change the importance, values closer to 0 means it will be less important,
		 * values > 1 means the vertex is more important and less probable to be removed. (Field
		 * name: "VertexWeighting", Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void AddVertexWeighting(  ) = 0;

		/**
		 * Gets the number of vertices in the geometry. @return the vertex count		
		 */
		virtual	unsigned int GetVertexCount(  ) = 0;

		/**
		 * Adds an empty custom field. To be able to add a field, it must have a name that does
		 * not  conflict with the existing custom fields. @param base_type the base_type of
		 * the new custom field, data types are listed in SimplygonSDK::BaseTypes @param name
		 * the name of the new custom field @param tuple_size the tuple size of the new custom
		 * field, defaults to 1 if not specified @return pointer to the created field<br />Description
		 * of IValueArray: ReValueArray adds methods to arrays to generically  add, set and
		 * get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeCustomField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * \deprecated AddBitangents() is deprecated, use AddTangents() instead.Bitangents are
		 * Added and Removed in unison with Tangents. Only need  to call AddTangents to add
		 * both Tangent and Bitangent fields, and RemoveTangents to remove both fields. Use
		 * GetBitangents to retrieve the bitangent field.
		 */
		virtual	SGDEPRECATED void AddBitangents( rid level ) = 0;

		/**
		 * Adds the BoneWeights and BoneIds fields in the vertices. The BoneWeights and BoneIds
		 * fields are added and removed in unison, and  should always be the same tuple size.
		 * (Field names: "BoneWeights" & "BoneIds", Tuple size: varying , Stored as: Vertex
		 * attribute) @param tuplesize the number of bones allowed per vertex
		 */
		virtual	void AddBoneWeights( unsigned int tuplesize ) = 0;

		/**
		 * Removes the BoneWeights and BoneIds fields in the vertices. The BoneWeights and BoneIds
		 * fields are added and removed in unison, and  should always be the same tuple size.
		 * (Field names: "BoneWeights" & "BoneIds", Tuple size: varying , Stored as: Vertex
		 * attribute)
		 */
		virtual	void RemoveBoneWeights(  ) = 0;

		/**
		 * Adds a TexCoords field in the corners.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'TexCoords0' - 'TexCoords255' <br>(Field name: "TexCoords0"
		 * - "TexCoords255", Tuple size: 2 , Stored as: Corner attribute) @param level the id
		 * of the texture field to add
		 */
		virtual	void AddTexCoords( rid level ) = 0;

		/**
		 * combines the fields of three vertices via barycentric coordinates. <br> alpha_3 =
		 * 1-(alpha_1 + alpha_2) <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br>
		 * @param source the IGeometryData object to combine from @param dest_id the vertex
		 * id to replace in this IGeometryData object @param src_id_1 the first vertex id to
		 * combine from @param src_id_2 the second vertex id to combine from @param src_id_3
		 * the third vertex id to combine from @param alpha_1 the first interpolation value
		 * @param alpha_1 the second interpolation value
		 */
		virtual	void CopyCombine3Vertices( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Removes the MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple
		 * size: 1 , Stored as: triangle attribute)
		 */
		virtual	void RemoveMaterialIds(  ) = 0;

		/**
		 * Removes the VertexWeighting field for the vertices. The weights are used to determine
		 * how important it is to keep the vertices when the geometry is reduced. 1 means the
		 * weight won't change the importance, values closer to 0 means it will be less important,
		 * values > 1 means the vertex is more important and less probable to be removed. (Field
		 * name: "VertexWeighting", Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void RemoveVertexWeighting(  ) = 0;

		/**
		 * \deprecated AddBoneIds() is deprecated, use AddBoneWeights() instead.Function is
		 * empty, does now nothing. BoneIds are added/removed when AddBoneWeights()/RemoveBoneWeights()
		 * is called.
		 */
		virtual	SGDEPRECATED void AddBoneIds( unsigned int tuplesize ) = 0;

		/**
		 * Finds all Nan (1.#IND, 1.#INF etc) values in the real/float/double arrays in the
		 * GeometryData, and sets them to 0.0 just to make sure all numbers in the GeometryData
		 * are legit. Should not be needed if all the data loaded into the GeometryData object
		 * is ok to begin with...
		 */
		virtual	void CleanupNanValues(  ) = 0;

		/**
		 * Finds triangles that contain the same vertex more than once, and invalidates them,
		 * ie. sets all the vertex id references to -1. These triangles can be culled using
		 * Compact().
		 */
		virtual	void CleanupInvalidTriangles(  ) = 0;

		/**
		 * \deprecated AddBaseTypeUserTriangleVertexField() is deprecated, use AddBaseTypeUserCornerField()
		 * instead.AddBaseTypeUserTriangleVertexField() has been renamed AddBaseTypeUserCornerField()<br
		 * />Description of IValueArray: ReValueArray adds methods to arrays to generically
		 * add, set and get tuples, through real values.
		 */
		virtual	SGDEPRECATED CountedPointer<IValueArray> AddBaseTypeUserTriangleVertexField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Adds a user-specified vertex field. To be able to add a field, it must have a name
		 * that does not  conflict with the existing vertex fields. @param base_type the base_type
		 * of the new user field, data types are listed in SimplygonSDK::BaseTypes @param name
		 * the name of the new user field @param tuple_size the tuple size of the new user field,
		 * defaults to 1 if not specified @return pointer to the created array<br />Description
		 * of IValueArray: ReValueArray adds methods to arrays to generically  add, set and
		 * get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeUserVertexField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Removes a user-specified triangle field. @param name the name of the triangle field
		 * to remove from the IGeometryData object
		 */
		virtual	void RemoveUserTriangleField( const char * name ) = 0;

		/**
		 * Gets the Normals field in the corners.  <br>(Field name: "Normals" , Tuple size:
		 * 3 , Stored as: Corner attribute) @return the normals field<br />Description of IRealArray:
		 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetNormals(  ) = 0;

		/**
		 * Adds an empty user-specified triangle field. @param base_type the base_type of the
		 * new user triangle field, data types are listed in SimplygonSDK::BaseTypes @param
		 * name the name of the triangle field to add to the IGeometryData object @param tuple_size
		 * the tuple size of the new field, deafaults to 1 if not specified @return pointer
		 * to the newly created triangle field<br />Description of IValueArray: ReValueArray
		 * adds methods to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeUserTriangleField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Adds the VertexLocks field for the vertices. If the value for a vertex is true, then
		 * the vertex should be locked,  and not be removed in the collapse-process. (Field
		 * name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void AddVertexLocks(  ) = 0;

		/**
		 * Removes a TexCoords field in the corners.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'TexCoords0' - 'TexCoords255' <br>(Field name: "TexCoords0"
		 * - "TexCoords255", Tuple size: 2 , Stored as: Corner attribute) @param level the id
		 * of the texture field to remove
		 */
		virtual	void RemoveTexCoords( rid level ) = 0;

		/**
		 * Copies all fields in the specified triangle in the source geometry to this geometry's
		 * triangle.  @param source the IGeometryData object to copy from @param dest_id the
		 * triangle id to replace in this IGeometryData object @param src_id the id of the triangle
		 * to copy
		 */
		virtual	void CopyTriangle( IGeometryData *source , rid dest_id , rid src_id ) = 0;

		/**
		 * Transforms the geometry using the supplied matrix transformation. The fields that
		 * are modified are the Coords field of Vertices, as well as the Normals and all Tangent
		 * and Bi-tangent fields of the Corners @param transformation the 4x4 transformation
		 * as a IMatrix4x4
		 */
		virtual	void Transform( IMatrix4x4 *transformation ) = 0;

		/**
		 * Extracts a range of triangles with their vertices  from the geometry. ExpandVertices()
		 * must first be called for the extraction to succeed. ExtractGeometry() can be used
		 * to stream geometries in  chunks. If writing to a stream, the extracted geometry is
		 * guaranteed to have the same setup as the original. Any previous data in the destination
		 * will be deleted. @param dest the IGeometryData object that is written to @param start_tri_id
		 * the first triangle to be extracted @param count the number of triangles to extract
		 */
		virtual	void ExtractRange( IGeometryData *dest , rid start_tri_id , unsigned int count ) = 0;

		/**
		 * combines the fields of two triangles by linear interpolation into the destination
		 * triangle. @param source the IGeometryData object to combine from @param dest_id the
		 * triangle id to replace in this IGeometryData object @param src_id_1 the first triangle
		 * id to combine from @param src_id_2 the second triangle id to combine from @param
		 * alpha the interpolation value between 0 and 1
		 */
		virtual	void CopyCombineTriangles( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Gets the VertexLocks field for the vertices. If the value for a vertex is true, then
		 * the vertex should be locked,  and not be removed in the collapse-process. (Field
		 * name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute)<br />Description
		 * of IBoolArray: IBoolArray is the bool implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IBoolArray> GetVertexLocks(  ) = 0;

		/**
		 * Gets the MaterialIds field in the triangles. (Field name: "MaterialIds", Tuple size:
		 * 1 , Stored as: triangle attribute) @return The MaterialIds field <br />Description
		 * of IRidArray: IRidArray is the rid implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRidArray> GetMaterialIds(  ) = 0;

		/**
		 * Gets the BoneWeights field in the vertices. (Field name: "BoneWeights", Tuple size:
		 * varying , Stored as: Vertex attribute) @return the array containing the bone weights<br
		 * />Description of IRealArray: IRealArray is the real implementation of IValueArray.
		 * See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetBoneWeights(  ) = 0;

		/**
		 * Removes a Color field in the corners.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'Colors0' - 'Colors255' <br>(Field name: "Colors0"
		 * - "Colors255", Tuple size: 4 , Stored as: Corner attribute) @param level the color
		 * level (0-255)
		 */
		virtual	void RemoveColors( rid level ) = 0;

		/**
		 * Removes a user-specified corner field. @param name the name of the field to remove
		 * from the IGeometryData object
		 */
		virtual	void RemoveUserCornerField( const char * name ) = 0;

		/**
		 * combines the fields of two vertices by linear interpolation into the destination
		 * vertex. @param source the IGeometryData object to combine from @param dest_id the
		 * vertex id to replace in this IGeometryData object @param src_id_1 the first vertex
		 * id to combine from @param src_id_2 the second vertex id to combine from @param alpha
		 * the interpolation value between 0 and 1
		 */
		virtual	void CopyCombineVertices( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Gets the VertexWeighting field for the vertices. The weights are used to determine
		 * how important it is to keep the vertices when the geometry is reduced. 1 means the
		 * weight won't change the importance, values closer to 0 means it will be less important,
		 * values > 1 means the vertex is more important and less probable to be removed. (Field
		 * name: "VertexWeighting", Tuple size: 1 , Stored as: Vertex attribute) @return the
		 * array of vertex weights<br />Description of IRealArray: IRealArray is the real implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetVertexWeighting(  ) = 0;

		/**
		 * Appends the geometry data to this geometry. This geometry will contain all triangles
		 * and vertices of both geometries. The  VertexIds that are copied from the source are
		 * remapped to point at the vertices, which are appended to the end of the current vertices.
		 * Any field in the appended geometry that does not exist in this geometry will be added,
		 * with the tuples that are added set to 0. The method will fail if the source geometry
		 * has identically named fields, but with different tuple sizes or base types. @param
		 * source the source geometry that will be appended to this geometry. the contents of
		 * source will not be modified.
		 */
		virtual	void AppendGeometry( IGeometryData *source ) = 0;

		/**
		 * Gets a Color field in the corners.  The valid id range of the level parameter is
		 * 0-255, which equals fields  'Colors0' - 'Colors255' <br>(Field name: "Colors0" -
		 * "Colors255", Tuple size: 4 , Stored as: Corner attribute) @param level the color
		 * level (0-255) @return the color field<br />Description of IRealArray: IRealArray
		 * is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetColors( rid level ) = 0;

		/**
		 * \deprecated AddDiffuseColors() is deprecated, use AddColors() instead.DiffuseColors
		 * is now an alias for 'Colors0'
		 */
		virtual	SGDEPRECATED void AddDiffuseColors(  ) = 0;

		/**
		 * Gets the BoneIds fields in the vertices. (Field name: "BoneIds", Tuple size: varying
		 * , Stored as: Vertex attribute) @return the array containing the bone ids, i.e the
		 * bones per vertex that affects them<br />Description of IRidArray: IRidArray is the
		 * rid implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRidArray> GetBoneIds(  ) = 0;

		/**
		 * combines the fields of two corners by linear interpolation into the destination corner.
		 * @param source the IGeometryData object to combine from @param dest_id the corner
		 * id to replace in this IGeometryData object @param src_id_1 the first corner id to
		 * combine from @param src_id_2 the second corner id to combine from @param alpha the
		 * interpolation value between 0 and 1
		 */
		virtual	void CopyCombineCorners( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , real alpha ) = 0;

		/**
		 * Copies all fields in the specified vertex in the source geometry to this geometry's
		 * vertex.  @param source the IGeometryData object to copy from @param dest_id the vertex
		 * id to replace in this IGeometryData object @param src_id the id of the vertex to
		 * copy
		 */
		virtual	void CopyVertex( IGeometryData *source , rid dest_id , rid src_id ) = 0;

		/**
		 * Gets a user-specified vertex field. @param name the name of the user vertex field
		 * to be fetched from the IGeometryData object @return the requested user-specified
		 * vertex field<br />Description of IValueArray: ReValueArray adds methods to arrays
		 * to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetUserVertexField( const char * name ) = 0;

		/**
		 * Gets a TexCoords field in the corners.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'TexCoords0' - 'TexCoords255' <br>(Field name: "TexCoords0"
		 * - "TexCoords255", Tuple size: 2 , Stored as: Corner attribute) @param level the id
		 * of the texture field to get @return the requested texture id<br />Description of
		 * IRealArray: IRealArray is the real implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRealArray> GetTexCoords( rid level ) = 0;

		/**
		 * Adds Tangents and Bitangents fields in the corners. The valid id range of the level
		 * parameter is 0-255. <br>(Field names: "Tangents0" - "Tangents255" & "Bitangents0"
		 * - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) @param level the
		 * texture channel
		 */
		virtual	void AddTangents( rid level ) = 0;

		/**
		 * Removes invalid triangles and vertices not referenced by any triangle. If any vertices
		 * are removed, the  triangles will be remapped to the new compacted vertex field. Essentially
		 * calls Compact( false ), included for compatibility.
		 */
		virtual	void Compact(  ) = 0;

		/**
		 * \deprecated RemoveDiffuseColors() is deprecated, use RemoveColors() instead.DiffuseColors
		 * is now an alias for 'Colors0'
		 */
		virtual	SGDEPRECATED void RemoveDiffuseColors(  ) = 0;

		/**
		 * Detect triangle edge neighbors. Neighbor ids are stored in the "EdgeNeighbours" Corner
		 * field.
		 */
		virtual	void DetectEdgeNeighbours(  ) = 0;

		/**
		 * Get the superior (maximum) extent of the geometry @param dest_param receives the
		 * superior@param dest_param a pointer to the destination memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * \deprecated GetDiffuseColors() is deprecated, use GetColors() instead.DiffuseColors
		 * is now an alias for 'Colors0'<br />Description of IRealArray: IRealArray is the real
		 * implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	SGDEPRECATED CountedPointer<IRealArray> GetDiffuseColors(  ) = 0;

		/**
		 * Combines three corners via barycentric coordinates. <br> alpha_3 = 1-(alpha_1 + alpha_2)
		 * <br> dest = src_1*alpha_1 + src_2*alpha_2 + src_3*alpha_3 <br> @param source the
		 * IGeometryData object to combine from @param dest_id the corner id to replace in this
		 * IGeometryData object @param src_id_1 the first corner id to combine from @param src_id_2
		 * the second corner id to combine from @param src_id_3 the third corner id to combine
		 * from @param alpha_1 the first interpolation value @param alpha_1 the second interpolation
		 * value
		 */
		virtual	void CopyCombine3Corners( IGeometryData *source , rid dest_id , rid src_id_1 , rid src_id_2 , rid src_id_3 , real alpha_1 , real alpha_2 ) = 0;

		/**
		 * Removes Tangents and Bitangents fields in the corners. The valid id range of the
		 * level parameter is 0-255. <br>(Field names: "Tangents0" - "Tangents255" & "Bitangents0"
		 * - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) @param level the
		 * texture channel
		 */
		virtual	void RemoveTangents( rid level ) = 0;

		/**
		 * Gets a Tangents field in the corners. The valid id range of the level parameter is
		 * 0-255. <br>(Field name: "Tangents0" - "Tangents255", Tuple size: 3 , Stored as: Corner
		 * attribute) @param level the texture channel @return the tangent field for the selected
		 * texture channel<br />Description of IRealArray: IRealArray is the real implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetTangents( rid level ) = 0;

		/**
		 * Gets a user-specified corner field. @param name the name of the field to get @return
		 * the requested field<br />Description of IValueArray: ReValueArray adds methods to
		 * arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetUserCornerField( const char * name ) = 0;

		/**
		 * Gets a Bitangents field in the corners. The valid id range of the level parameter
		 * is 0-255. <br>(Field name: "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored
		 * as: Corner attribute) @param level the texture channel @return the bi-tangent field
		 * for the selected texture channel<br />Description of IRealArray: IRealArray is the
		 * real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetBitangents( rid level ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the corner fields @return the corner
		 * IFieldData <br />Description of IFieldData: IFieldData represents multiple fields
		 * of data. Each  field is implemented as an IValueArray object, that has a unique 
		 * name, and can have complex components (such as scalars, vectors,  quaternions, tensors
		 * or matrices).  All fields are assumed to be of the same length. IFieldData can be
		 * seen as an array with complex tuples, where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> GetCorners(  ) = 0;

		/**
		 * Adds the Normals field in the corners.  <br>(Field name: "Normals" , Tuple size:
		 * 3 , Stored as: Corner attribute)
		 */
		virtual	void AddNormals(  ) = 0;

		/**
		 * Adds an empty user-specified corner field. @param base_type specifies the base type
		 * of the new corner field, data types are listed in SimplygonSDK::BaseTypes @param
		 * name the name of the field to add @param tuple_size the tuple size of the new field,
		 * defaults to 1 if not specified @return pointer to the created field<br />Description
		 * of IValueArray: ReValueArray adds methods to arrays to generically  add, set and
		 * get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeUserCornerField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Set the superior (maximum) extent of the geometry @param vec the new superior
		 */
		virtual	void SetSup( real vec[3] ) = 0;

		/**
		 * Calculate the extents by checking the coordinates of all vertices in the geometry.
		 * Set only_triangles to true to test only vertices that  are indexed by a triangle.
		 * This is a slower test, and  the bounding box may not encompass all vertices' positions.
		 * the new extents are found by calling GetInf() and GetSup() afterwards. @param only_triangles
		 * true if only vertices indexed by triangles should be checked, defaults to false if
		 * not specified
		 */
		virtual	void CalculateExtents( bool only_triangles ) = 0;

		/**
		 * \deprecated AddSpecularColors() is deprecated, use AddColors() instead.SpecularColors
		 * is now an alias for 'Colors1'
		 */
		virtual	SGDEPRECATED void AddSpecularColors(  ) = 0;

		/**
		 * \deprecated RemoveSpecularColors() is deprecated, use RemoveColors() instead.SpecularColors
		 * is now an alias for 'Colors1'
		 */
		virtual	SGDEPRECATED void RemoveSpecularColors(  ) = 0;

		/**
		 * \deprecated RemoveBitangents() is deprecated, use RemoveTangents() instead.Bitangents
		 * are Added and Removed in unison with Tangents. Only need  to call AddTangents to
		 * add both Tangent and Bitangent fields, and RemoveTangents to remove both fields.
		 * Use GetBitangents to retrieve the bitangent field.
		 */
		virtual	SGDEPRECATED void RemoveBitangents( rid level ) = 0;

		/**
		 * Creates another geometry data object with the same field setup.  To also copy the
		 * data to the new object, set copy_data to true. @param copy_data if true, copies the
		 * data along with the IGeometryData properties @return the new geometry data object<br
		 * />Description of IGeometryData: IGeometryData represents a geometric structure  consisting
		 * of point data (Vertices) and topological data (Triangles). IGeometryData may represent
		 * a whole geometric object, but can also be used by streaming data filters, and in
		 * this way, only represents a part of the object. <br><br> Different fields in the
		 * Vertices and Triangles fields data  objects will contain point data and topological
		 * data. The standard  naming convention used in the filters/renderers are as follows:
		 * (Case sensitive naming, other fields may also be present) <br><br> 'Coords' <br>
		 * Positional coordinates of a vertex, expressed with a 3-component real field (XYZ).
		 * <br><br> 'TexCoords0' - 'TexCoords255' <br> Texture coordinates of a vertex, expressed
		 * with a 2 components real field. By convention, the existing fields must be sequential,
		 * and  must start with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the
		 * vertex,	expressed  with a 3-component real field, a  normalized (XYZ) vector. <br><br>
		 * 'VertexIds'	 <br> The id of the primitive's current vertex.  This field is present
		 * even if the  vertex data	is directly specified in the  primitive's data, to specify
		 * topology. The field is of type rid. <br><br> 'MaterialIds' <br> The material of the
		 * primitive.  The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields
		 * always exist in the object, but the other fields are optional. Also, there can exist
		 * user fields.
		 */
		virtual	CountedPointer<IGeometryData> NewCopy( bool copy_data ) = 0;

		/**
		 * Creates a "packed" IPackedGeometryData object, where all fields in the Corner field
		 * data object is moved to  the vertex field data object. Please note that the vertex
		 * field data object will be enlarged to accommodate for data in a vertex  shared by
		 * multiple triangles, where the corner data differs between the triangles. The method
		 * will fail if a Corner field is named the same as an existing Vertices field, please
		 * make sure to remove any such field before calling the method. @return the new IPackedGeometryData
		 * object<br />Description of IPackedGeometryData: IPackedGeometryData keeps the same
		 * information as IGeometryData, but with all corner data fields moved into per-vertex
		 * fields. No per-corner fields exist, apart from the VertexIds field.  Please note
		 * that the number of vertices in an IPackedGeometryData is commonly higher than in
		 * an IGeometryData, as vertices must be split to accommodate for different corner data.
		 */
		virtual	CountedPointer<IPackedGeometryData> NewPackedCopy(  ) = 0;

		/**
		 * Copies the field setup and data from another object into this object. To only copy
		 * the setup, set copy_data to false. @param source the IGeometryData object to copy
		 * from @param copy_data if true, copies the data along with the IGeometryData properties
		 */
		virtual	void DeepCopy( IGeometryData *source , bool copy_data ) = 0;

		/**
		 * Sets the number of vertices in the geometry. @param count the desired new vertex
		 * count		
		 */
		virtual	void SetVertexCount( unsigned int count ) = 0;

		/**
		 * Increases the vertex count by the specified value. @param count the number of vertices
		 * to add
		 */
		virtual	void AddVertices( unsigned int count ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGeometryData
	 * IGeometryData represents a geometric structure  consisting of point data (Vertices)
	 * and topological data (Triangles). IGeometryData may represent a whole geometric object,
	 * but can also be used by streaming data filters, and in this way, only represents
	 * a part of the object. <br><br> Different fields in the Vertices and Triangles fields
	 * data  objects will contain point data and topological data. The standard  naming
	 * convention used in the filters/renderers are as follows: (Case sensitive naming,
	 * other fields may also be present) <br><br> 'Coords' <br> Positional coordinates of
	 * a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0' -
	 * 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
	 * real field. By convention, the existing fields must be sequential, and  must start
	 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
	 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
	 * <br> The id of the primitive's current vertex.  This field is present even if the
	 * vertex data	is directly specified in the  primitive's data, to specify topology.
	 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
	 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
	 * in the object, but the other fields are optional. Also, there can exist user fields.
	 */
	typedef CountedPointer<IGeometryData> spGeometryData;

	class IPackedGeometryData;
	class IGeometryData;
	class IRidArray;
	class IRealArray;
	class IBoolArray;
	class IValueArray;
	class IFieldData;

	/**
	 * IPackedGeometryData keeps the same information as IGeometryData, but with all corner
	 * data fields moved into per-vertex fields. No per-corner fields exist, apart from
	 * the VertexIds field.  Please note that the number of vertices in an IPackedGeometryData
	 * is commonly higher than in an IGeometryData, as vertices must be split to accommodate
	 * for different corner data.
	 */
	class IPackedGeometryData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IPackedGeometryData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IPackedGeometryData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IPackedGeometryData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IPackedGeometryData pointer
		 * @return a pointer to the IPackedGeometryData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IPackedGeometryData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IPackedGeometryData") )
				return static_cast<IPackedGeometryData*>(ptr);
			return NULL;
			}
		/**
		 * Set the superior (maximum) extent of the geometry @param vec is the values that the
		 * maximum extent of the geometry is to be set to
		 */
		virtual	void SetSup( real vec[3] ) = 0;

		/**
		 * Gets the GroupIds field in the triangles. <br>(Field name: "GroupIds", Tuple size:
		 * 1 , Stored as: triangle attribute) @return the material ids array<br />Description
		 * of IRidArray: IRidArray is the rid implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRidArray> GetGroupIds(  ) = 0;

		/**
		 * Gets the BoneIds field. <br>(Field name: "BoneIds", Tuple size: varying , Stored
		 * as: Vertex attribute) @return the bone id array<br />Description of IRidArray: IRidArray
		 * is the rid implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRidArray> GetBoneIds(  ) = 0;

		/**
		 * Retrieves the ReFieldData object that contains the triangle fields @return the triangle
		 * fields data<br />Description of IFieldData: IFieldData represents multiple fields
		 * of data. Each  field is implemented as an IValueArray object, that has a unique 
		 * name, and can have complex components (such as scalars, vectors,  quaternions, tensors
		 * or matrices).  All fields are assumed to be of the same length. IFieldData can be
		 * seen as an array with complex tuples, where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> GetTriangles(  ) = 0;

		/**
		 * \deprecated RemoveSpecularColors() is deprecated, use RemoveColors() instead.SpecularColors
		 * is now an alias for 'Colors1'
		 */
		virtual	SGDEPRECATED void RemoveSpecularColors(  ) = 0;

		/**
		 * Gets a Color field in the vertices.  The valid id range of the level parameter is
		 * 0-255, which equals fields  'Colors0' - 'Colors255' <br>(Field name: "Colors0" -
		 * "Colors255", Tuple size: 4 , Stored as: Vertex attribute) @param level is the level
		 * of the Colors field to get @return the colors array<br />Description of IRealArray:
		 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetColors( rid level ) = 0;

		/**
		 * Gets the VertexIds field in the triangles. @return the vertex ids array<br />Description
		 * of IRidArray: IRidArray is the rid implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRidArray> GetVertexIds(  ) = 0;

		/**
		 * Get the inferior (minimum) extent of the geometry@param dest_param a pointer to the
		 * destination memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Removes the MaterialIds field in the triangles. <br>(Field name: "MaterialIds", Tuple
		 * size: 1 , Stored as: triangle attribute)
		 */
		virtual	void RemoveMaterialIds(  ) = 0;

		/**
		 * Creates an "unpacked" ReGeometryData object. Please note that since the data in the
		 * RePackedGeometryData structure is per-vertex, you may have to weld the resulting
		 * ReGeometryData to remove vertices with the same spatial coordinates. @return the
		 * new unpacked geometry data object<br />Description of IGeometryData: IGeometryData
		 * represents a geometric structure  consisting of point data (Vertices) and topological
		 * data (Triangles). IGeometryData may represent a whole geometric object, but can also
		 * be used by streaming data filters, and in this way, only represents a part of the
		 * object. <br><br> Different fields in the Vertices and Triangles fields data  objects
		 * will contain point data and topological data. The standard  naming convention used
		 * in the filters/renderers are as follows: (Case sensitive naming, other fields may
		 * also be present) <br><br> 'Coords' <br> Positional coordinates of a vertex, expressed
		 * with a 3-component real field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br>
		 * Texture coordinates of a vertex, expressed with a 2 components real field. By convention,
		 * the existing fields must be sequential, and  must start with 'TexCoord0'. <br><br>
		 * 'Normals'	 <br> Normal vector for the vertex,	expressed  with a 3-component real
		 * field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	 <br> The id of the primitive's
		 * current vertex.  This field is present even if the  vertex data	is directly specified
		 * in the  primitive's data, to specify topology. The field is of type rid. <br><br>
		 * 'MaterialIds' <br> The material of the primitive.  The field is of type rid. <br><br>
		 * The 'Coords' and 'VertexIds' fields always exist in the object, but the other fields
		 * are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> NewUnpackedCopy(  ) = 0;

		/**
		 * \deprecated AddDiffuseColors() is deprecated, use AddColors() instead.DiffuseColors
		 * is now an alias for 'Colors0'
		 */
		virtual	SGDEPRECATED void AddDiffuseColors(  ) = 0;

		/**
		 * Adds the MaterialIds field in the triangles. <br>(Field name: "MaterialIds", Tuple
		 * size: 1 , Stored as: triangle attribute)
		 */
		virtual	void AddMaterialIds(  ) = 0;

		/**
		 * Removes a user-specified triangle field. To be able to add a field, it must have
		 * a name that does not  conflict with the existing triangle fields. @param field is
		 * the name of the field that is to be removed
		 */
		virtual	void RemoveUserTriangleField( const char * name ) = 0;

		/**
		 * Removes the VertexWeighting field for the vertices. <br>(Field name: "VertexWeighting",
		 * Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void RemoveVertexWeighting(  ) = 0;

		/**
		 * Set the inferior (minimum) extent of the geometry @param vec is the values that the
		 * minimum extent of the geometry is to be set to
		 */
		virtual	void SetInf( real vec[3] ) = 0;

		/**
		 * Gets the number of triangles in the geometry. @return the current triangle count
		 */
		virtual	void AddTriangles( unsigned int count ) = 0;

		/**
		 * Removes the GroupIds field in the triangles. <br>(Field name: "GroupIds", Tuple size:
		 * 1 , Stored as: triangle attribute)
		 */
		virtual	void RemoveGroupIds(  ) = 0;

		/**
		 * Gets the Coords field in the vertices. <br>(Field name: "Coords", Tuple size: 3 ,
		 * Stored as: Vertex attribute) @return the vertex coords array<br />Description of
		 * IRealArray: IRealArray is the real implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRealArray> GetCoords(  ) = 0;

		/**
		 * \deprecated GetSpecularColors() is deprecated, use GetColors() instead.SpecularColors
		 * is now an alias for 'Colors1'<br />Description of IRealArray: IRealArray is the real
		 * implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	SGDEPRECATED CountedPointer<IRealArray> GetSpecularColors(  ) = 0;

		/**
		 * Copies the field setup and data from another object. To only copy the setup, set
		 * copy_data to false. @param source is the source from which the data will be copied
		 * @param copy_data is the bool determining whether to copy the data or just the field
		 * setup
		 */
		virtual	void DeepCopy( IPackedGeometryData *source , bool copy_data ) = 0;

		/**
		 * Removes a TexCoords field in the vertices.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'TexCoords0' - 'TexCoords255' <br>(Field name: "TexCoords0"
		 * - "TexCoords255", Tuple size: 2 , Stored as: Vertex attribute) @param level is the
		 * level of the texcoord field to remove
		 */
		virtual	void RemoveTexCoords( rid level ) = 0;

		/**
		 * Retrieves the IFieldData object that contains the vertex fields @return the vertex
		 * fields data<br />Description of IFieldData: IFieldData represents multiple fields
		 * of data. Each  field is implemented as an IValueArray object, that has a unique 
		 * name, and can have complex components (such as scalars, vectors,  quaternions, tensors
		 * or matrices).  All fields are assumed to be of the same length. IFieldData can be
		 * seen as an array with complex tuples, where the component can be of  different types.
		 */
		virtual	CountedPointer<IFieldData> GetVertices(  ) = 0;

		/**
		 * Adds a Tangents field in the corners. <br>(Field name: "Tangents0" - "Tangents255"
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) @param
		 * level is the level of the new tangent fields
		 */
		virtual	void AddTangents( rid level ) = 0;

		/**
		 * Removes a user-specified vertex field. @param name is the name of the field that
		 * is to be removed
		 */
		virtual	void RemoveUserVertexField( const char * name ) = 0;

		/**
		 * Gets the MaterialIds field in the triangles. <br>(Field name: "MaterialIds", Tuple
		 * size: 1 , Stored as: triangle attribute) @return the material ids array<br />Description
		 * of IRidArray: IRidArray is the rid implementation of IValueArray. See IValueArray
		 * for a description.
		 */
		virtual	CountedPointer<IRidArray> GetMaterialIds(  ) = 0;

		/**
		 * Gets the number of triangles in the geometry. @return the current triangle count
		 */
		virtual	unsigned int GetTriangleCount(  ) = 0;

		/**
		 * Gets the VertexWeighting field for the vertices. <br>(Field name: "VertexWeighting",
		 * Tuple size: 1 , Stored as: Vertex attribute) @return the vertex weighting array<br
		 * />Description of IRealArray: IRealArray is the real implementation of IValueArray.
		 * See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetVertexWeighting(  ) = 0;

		/**
		 * Adds the VertexLocks field for the vertices. If the value for a vertex is true, then
		 * the vertex should be locked,  and not be removed in the collapse-process. <br>(Field
		 * name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void AddVertexLocks(  ) = 0;

		/**
		 * Adds a TexCoords field in the vertices.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'TexCoords0' - 'TexCoords255' <br>(Field name: "TexCoords0"
		 * - "TexCoords255", Tuple size: 2 , Stored as: Vertex attribute) @param level is the
		 * level of the new texcoord field
		 */
		virtual	void AddTexCoords( rid level ) = 0;

		/**
		 * Gets a Tangents field in the corners. <br>(Field name: "Tangents0" - "Tangents255"
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) @param
		 * level is the level of the tangent field to get @return the tangent array for the
		 * requested level<br />Description of IRealArray: IRealArray is the real implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetTangents( rid level ) = 0;

		/**
		 * Adds the GroupIds field in the triangles. <br>(Field name: "GroupIds", Tuple size:
		 * 1 , Stored as: triangle attribute)
		 */
		virtual	void AddGroupIds(  ) = 0;

		/**
		 * \deprecated RemoveDiffuseColors() is deprecated, use RemoveColors() instead.DiffuseColors
		 * is now an alias for 'Colors0'
		 */
		virtual	SGDEPRECATED void RemoveDiffuseColors(  ) = 0;

		/**
		 * AddVertices increases the vertex count by the specified value. @param count is the
		 * number of vertices to add
		 */
		virtual	void AddVertices( unsigned int count ) = 0;

		/**
		 * \deprecated RemoveBitangents() is deprecated, use RemoveTangents() instead.Bitangents
		 * are Added and Removed in unison with Tangents. Only need  to call AddTangents to
		 * add both Tangent and Bitangent fields, and RemoveTangents to remove both fields.
		 * Use GetBitangents to retrieve the bitangent field.
		 */
		virtual	SGDEPRECATED void RemoveBitangents( rid level ) = 0;

		/**
		 * Appends all vertex-tuples in "source" that don't already exists in the current GeometryData.
		 * For each vertex field in this PackedGeometryData, the "source" must contain a corresponding
		 * vertex or corner field. All extra-fields in "source" will be skipped however.  Returns
		 * the number of new and unique vertices created, and the NewVertexIds will contain
		 * the indices for the triangles of the "source" Geometry. The VertexIds of the current
		 * GeometryData will still be valid. If collapseToOriginalVertices is set to true, all
		 * vertices from source will be collapsed to the closest matching vertex of the current
		 * geometry. This means that no new vertices will be added, so the returned value will
		 * always be 0. If the "NewVertexIds"-array is not initiated before send into this function,
		 * it will do nothing and return -1 instead, as error value. The method does not append
		 * triangle ids or triangle field data from "source" to the current object. @param source
		 * is the geometry from which to append @param NewVertexIds will be written to and contain
		 * the indices for the appended geometries triangles @param collapseToOriginalVertices
		 * will determine if the appended vertices are collapsed to existing ones or not @return
		 * the number of unique verts added to the packed geometry
		 */
		virtual	int AppendPackedGeometry( IGeometryData *source , IRidArray *NewVertexIds , bool collapseToOriginalVertices ) = 0;

		/**
		 * Adds the Normals field in the vertices.  <br>(Field name: "Normals" , Tuple size:
		 * 3 , Stored as: Vertex attribute)
		 */
		virtual	void AddNormals(  ) = 0;

		/**
		 * Adds the VertexWeighting field for the vertices. <br>(Field name: "VertexWeighting",
		 * Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void AddVertexWeighting(  ) = 0;

		/**
		 * Adds a user-specified vertex field from an already populated value array. To be able
		 * to add a field, it must have a name that does not  conflict with the existing vertex
		 * fields. @param field is the field that is to be added
		 */
		virtual	void AddUserVertexField( IValueArray *field ) = 0;

		/**
		 * \deprecated AddSpecularColors() is deprecated, use AddColors() instead.SpecularColors
		 * is now an alias for 'Colors1'
		 */
		virtual	SGDEPRECATED void AddSpecularColors(  ) = 0;

		/**
		 * Adds a user-specified triangle field from an already populated array. To be able
		 * to add a field, it must have a name that does not  conflict with the existing triangle
		 * fields. @param field is the array that is to be added
		 */
		virtual	void AddUserTriangleField( IValueArray *field ) = 0;

		/**
		 * Gets a user-specified triangle field. To be able to add a field, it must have a name
		 * that does not  conflict with the existing triangle fields. @param field is the name
		 * of the field that is to be fetched<br />Description of IValueArray: ReValueArray
		 * adds methods to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetUserTriangleField( const char * name ) = 0;

		/**
		 * Removes a Color field in the vertices.  The valid id range of the level parameter
		 * is 0-255, which equals fields  'Colors0' - 'Colors255' <br>(Field name: "Colors0"
		 * - "Colors255", Tuple size: 4 , Stored as: Vertex attribute) @param level is the level
		 * of the Color field to remove
		 */
		virtual	void RemoveColors( rid level ) = 0;

		/**
		 * Removes the BoneWeights and BoneIds fields in the vertices. The BoneWeights and BoneIds
		 * fields are added and removed in unison, and  should always be the same tuple size.
		 * <br>(Field names: "BoneWeights" & "BoneIds", Tuple size: varying , Stored as: Vertex
		 * attribute)
		 */
		virtual	void RemoveBoneWeights(  ) = 0;

		/**
		 * Creates another geometry data object with the same field setup.  To also copy the
		 * data to the new object, set copy_data to true. @param copy_data determines if the
		 * data is included in the new copy @return the new packed geometry data object<br />Description
		 * of IPackedGeometryData: IPackedGeometryData keeps the same information as IGeometryData,
		 * but with all corner data fields moved into per-vertex fields. No per-corner fields
		 * exist, apart from the VertexIds field.  Please note that the number of vertices in
		 * an IPackedGeometryData is commonly higher than in an IGeometryData, as vertices must
		 * be split to accommodate for different corner data.
		 */
		virtual	CountedPointer<IPackedGeometryData> NewCopy( bool copy_data ) = 0;

		/**
		 * Adds/Removes/Gets a TexCoords field in the vertices.  The valid id range of the level
		 * parameter is 0-255, which equals fields  'TexCoords0' - 'TexCoords255' <br>(Field
		 * name: "TexCoords0" - "TexCoords255", Tuple size: 2 , Stored as: Vertex attribute)
		 * @param level is the level of the texcoord field to get @return the texcoord array
		 * for the requested level<br />Description of IRealArray: IRealArray is the real implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetTexCoords( rid level ) = 0;

		/**
		 * \deprecated AddBitangents() is deprecated, use AddTangents() instead.Bitangents are
		 * Added and Removed in unison with Tangents. Only need  to call AddTangents to add
		 * both Tangent and Bitangent fields, and RemoveTangents to remove both fields. Use
		 * GetBitangents to retrieve the bitangent field.
		 */
		virtual	SGDEPRECATED void AddBitangents( rid level ) = 0;

		/**
		 * Adds an empty user-specified triangle field. To be able to add a field, it must have
		 * a name that does not  conflict with the existing triangle fields. @param base_type
		 * is the type of data in the field, the alternatives can be found in SimplygonSDK::BaseTypes
		 * @param name is the name of the new field @param tuple_size is the tuple size of the
		 * new field @return the newly added field<br />Description of IValueArray: ReValueArray
		 * adds methods to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeUserTriangleField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Sets the number of vertices in the geometry. @param count is the new vertexcount
		 */
		virtual	void SetVertexCount( unsigned int count ) = 0;

		/**
		 * Get the superior (maximum) extent of the geometry@param dest_param a pointer to the
		 * destination memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * Gets the number of vertices in the geometry. @return the current vertex count
		 */
		virtual	unsigned int GetVertexCount(  ) = 0;

		/**
		 * Gets the BoneWeights field. <br>(Field name: "BoneWeights", Tuple size: varying ,
		 * Stored as: Vertex attribute) @return the bone weights array<br />Description of IRealArray:
		 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetBoneWeights(  ) = 0;

		/**
		 * Adds a Color field in the vertices.  The valid id range of the level parameter is
		 * 0-255, which equals fields  'Colors0' - 'Colors255' <br>(Field name: "Colors0" -
		 * "Colors255", Tuple size: 4 , Stored as: Vertex attribute) @param level is the level
		 * of the Color field to add
		 */
		virtual	void AddColors( rid level ) = 0;

		/**
		 * \deprecated GetDiffuseColors() is deprecated, use GetColors() instead.DiffuseColors
		 * is now an alias for 'Colors0'<br />Description of IRealArray: IRealArray is the real
		 * implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	SGDEPRECATED CountedPointer<IRealArray> GetDiffuseColors(  ) = 0;

		/**
		 * Gets a user-specified vertex field. @param name is the name of the field to be fetched
		 * @return the matching field, or NULL if no such field exists<br />Description of IValueArray:
		 * ReValueArray adds methods to arrays to generically  add, set and get tuples, through
		 * real values.
		 */
		virtual	CountedPointer<IValueArray> GetUserVertexField( const char * name ) = 0;

		/**
		 * Sets the number of triangles in the geometry. @param count is the number of triangles
		 * to add
		 */
		virtual	void SetTriangleCount( unsigned int count ) = 0;

		/**
		 * Adds an empty user-specified vertex field. To be able to add a field, it must have
		 * a name that does not  conflict with the existing vertex fields. @param base_type
		 * is the type of data in the field, the alternatives can be found in SimplygonSDK::BaseTypes
		 * @param name is the name of the new field @param tuple_size is the tuple size of the
		 * new field @return the newly added field<br />Description of IValueArray: ReValueArray
		 * adds methods to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddBaseTypeUserVertexField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

		/**
		 * Gets a Bitangents field in the corners. <br>(Field name: "Tangents0" - "Tangents255"
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) @param
		 * level is the level of the bitangent field to get @return the bitangent array for
		 * the requested level<br />Description of IRealArray: IRealArray is the real implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetBitangents( rid level ) = 0;

		/**
		 * Removes the VertexLocks field for the vertices. If the value for a vertex is true,
		 * then the vertex should be locked,  and not be removed in the collapse-process. <br>(Field
		 * name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute)
		 */
		virtual	void RemoveVertexLocks(  ) = 0;

		/**
		 * Gets the VertexLocks field for the vertices. If the value for a vertex is true, then
		 * the vertex should be locked,  and not be removed in the collapse-process. <br>(Field
		 * name: "VertexLocks", Tuple size: 1 , Stored as: Vertex attribute) @return an array
		 * containing the vertex lock bools<br />Description of IBoolArray: IBoolArray is the
		 * bool implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IBoolArray> GetVertexLocks(  ) = 0;

		/**
		 * Adds the BoneWeights and BoneIds fields in the vertices. The BoneWeights and BoneIds
		 * fields are added and removed in unison, and  should always be the same tuple size.
		 * <br>(Field names: "BoneWeights" & "BoneIds", Tuple size: varying , Stored as: Vertex
		 * attribute) @param tuplesize is the size of the tuples in the new bone weight and
		 * bone id field
		 */
		virtual	void AddBoneWeights( unsigned int tuplesize ) = 0;

		/**
		 * Removes a Tangents field in the corners. <br>(Field name: "Tangents0" - "Tangents255"
		 * & "Bitangents0" - "Bitangents255", Tuple size: 3 , Stored as: Corner attribute) @param
		 * level is the level of the tangent fields to remove
		 */
		virtual	void RemoveTangents( rid level ) = 0;

		/**
		 * Removes the Normals field in the vertices.  <br>(Field name: "Normals" , Tuple size:
		 * 3 , Stored as: Vertex attribute)
		 */
		virtual	void RemoveNormals(  ) = 0;

		/**
		 * Gets the Normals field in the vertices.  <br>(Field name: "Normals" , Tuple size:
		 * 3 , Stored as: Vertex attribute) @return the normals array<br />Description of IRealArray:
		 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetNormals(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IPackedGeometryData
	 * IPackedGeometryData keeps the same information as IGeometryData, but with all corner
	 * data fields moved into per-vertex fields. No per-corner fields exist, apart from
	 * the VertexIds field.  Please note that the number of vertices in an IPackedGeometryData
	 * is commonly higher than in an IGeometryData, as vertices must be split to accommodate
	 * for different corner data.
	 */
	typedef CountedPointer<IPackedGeometryData> spPackedGeometryData;

	class IImageData;
	class IValueArray;
	class IFieldData;

	/**
	 * IImageData holds unpacked image data. The data is  stored in an IFieldData object
	 * as value fields. For simplicity all  images are implemented as 3D images, but has
	 * an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for 1D images.
	 * Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
	 */
	class IImageData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IImageData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IImageData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageData pointer
		 * @return a pointer to the IImageData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IImageData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IImageData") )
				return static_cast<IImageData*>(ptr);
			return NULL;
			}
		/**
		 * Get the X dimension size of this image data. @return the X dimension size of this
		 * image data.
		 */
		virtual	unsigned int GetXSize(  ) = 0;

		/**
		 * Get the ImageFields field data object, that holds all fields within the image @return
		 * the ImageFields field data object<br />Description of IFieldData: IFieldData represents
		 * multiple fields of data. Each  field is implemented as an IValueArray object, that
		 * has a unique  name, and can have complex components (such as scalars, vectors,  quaternions,
		 * tensors or matrices).  All fields are assumed to be of the same length. IFieldData
		 * can be  seen as an array with complex tuples, where the component can be of  different
		 * types.
		 */
		virtual	CountedPointer<IFieldData> GetImageFields(  ) = 0;

		/**
		 * Get the type of this image data. @return the type of this image data
		 */
		virtual	unsigned int GetType(  ) = 0;

		/**
		 * Gets the base type used by the colors field @return the base type used by the colors
		 * field.
		 */
		virtual	rid GetColorsValueType(  ) = 0;

		/**
		 * Set the X, Y and Z dimension size of this image data. @param _xs the desired X dimension
		 * size of this image data @param _ys the desired Y dimension size of this image data
		 * @param _zs the desired Z dimension size of this image data
		 */
		virtual	void Set3DSize( unsigned int _xs , unsigned int _ys , unsigned int _zs ) = 0;

		/**
		 * Set the X and Y dimension size of this image data. @param _xs the desired X dimension
		 * size of this image data @param _ys the desired Y dimension size of this image data
		 */
		virtual	void Set2DSize( unsigned int _xs , unsigned int _ys ) = 0;

		/**
		 * Gets a field's value type.  @param name the name of the field whose type to get,
		 * types listed in SimplygonSDK::BaseTypes @return the base type of the field
		 */
		virtual	rid GetFieldValueType( const char * name ) = 0;

		/**
		 * Creates another image data object with the same field setup.  To also copy the data
		 * to the new object, set copy_data to true. @param copy_data if true, all data is copied
		 * @return the new copy of the image data object<br />Description of IImageData: IImageData
		 * holds unpacked image data. The data is  stored in an IFieldData object as value fields.
		 * For simplicity all  images are implemented as 3D images, but has an extent of 1 in
		 * Z for 2D images, and an extent of 1 in both Y and Z for 1D images. Cube maps are
		 * stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> NewCopy( bool copy_data ) = 0;

		/**
		 * Removes the Colors field. 
		 */
		virtual	void RemoveColors(  ) = 0;

		/**
		 * Get the Y dimension size of this image data. @return the Y dimension size of this
		 * image data.
		 */
		virtual	unsigned int GetYSize(  ) = 0;

		/**
		 * Copies the field setup and data from another object. To only copy the setup, set
		 * copy_data to false. @param source the IImageData object to copy from @param copy_data
		 * true if the data should be copied along with  the image data properties
		 */
		virtual	void DeepCopy( IImageData *source , bool copy_data ) = 0;

		/**
		 * Checks if the image has a color field @return true if the image has a color field
		 */
		virtual	bool HasColors(  ) = 0;

		/**
		 * Gets the color field format specification @return the format specification string
		 */
		virtual	rstring GetColorsFormat(  ) = 0;

		/**
		 * Gets the Colors field.  @return the value array used by the colors field.<br />Description
		 * of IValueArray: ReValueArray adds methods to arrays to generically  add, set and
		 * get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetColors(  ) = 0;

		/**
		 * Check if a field exists in the IImageData object.  @param name the name of the field
		 * to check for @return true if field exists, otherwise false
		 */
		virtual	bool HasField( const char * name ) = 0;

		/**
		 * Adds the Colors field.  @param valuetype is the type used to store the tuples.  
		 * Use TYPES_ID_UCHAR base type for 8-bit per channel data, and TYPES_ID_USHORT base
		 * type for 16-bit per channel data.  @param format is a string that describes the format
		 * of the color field. Each character in format represents a color channel in the color
		 * tuple. All characters in the format string must be unique and uppercase. Normal values
		 * for format are: RGB, RGBA, YUV, HLS, CMYK, L and R. In these  examples the tuplesize
		 * of the formats will be 3,4,3,3,4,1  and 1, respectively. The format string must be
		 * at least one  character long. Use the SG_IMAGEDATA_FORMAT_[] defines to  define the
		 * standard types.
		 */
		virtual	void AddColors( rid valuetype , const char * format ) = 0;

		/**
		 * Adds a field. The field must have a name that does not conflict with any of the existing
		 * fields' names. The field is referenced by the image after the call to AddField()
		 * @param name the name of the field to add @param valuetype the type of the field,
		 * types listed in SimplygonSDK::BaseTypes @param tuplesize the size of tuples in the
		 * new field
		 */
		virtual	void AddField( const char * name , rid valuetype , unsigned int tuplesize ) = 0;

		/**
		 * Removes a field.  @param name the name of the field to remove
		 */
		virtual	void RemoveField( const char * name ) = 0;

		/**
		 * Gets a field.  @param name the name of the field to get @return the requested field
		 * <br />Description of IValueArray: ReValueArray adds methods to arrays to generically
		 * add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> GetField( const char * name ) = 0;

		/**
		 * Get the Z dimension size of this image data. @return the Z dimension size of this
		 * image data.
		 */
		virtual	unsigned int GetZSize(  ) = 0;

		/**
		 * Set the X dimension size of this image data. @param _xs the desired X dimension size
		 * of this image data
		 */
		virtual	void Set1DSize( unsigned int _xs ) = 0;

		/**
		 * Clears all data from the image, and removes all data fields. The type is reset to
		 * 2D
		 */
		virtual	void Reset(  ) = 0;

		/**
		 * Set the 6 uniform cube side dimensions of this image data. @param _xs the desired
		 * X dimension size of each cube side in this image data @param _ys the desired Y dimension
		 * size of each cube side in this image data
		 */
		virtual	void SetCubeSize( unsigned int _xs , unsigned int _ys ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IImageData
	 * IImageData holds unpacked image data. The data is  stored in an IFieldData object
	 * as value fields. For simplicity all  images are implemented as 3D images, but has
	 * an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for 1D images.
	 * Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
	 */
	typedef CountedPointer<IImageData> spImageData;


	/**
	 * ITable is the base class for tables objects, where items are added into an id-indexed
	 * array of objects. 
	 */
	class ITable : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ITable is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ITable",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITable pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITable pointer
		 * @return a pointer to the ITable object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ITable *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ITable") )
				return static_cast<ITable*>(ptr);
			return NULL;
			}
		/**
		 * Removes an item, and invalidates the id. The id will not point at a valid item, until
		 * Clear is called and new items are added up until the id. @param id the id of the
		 * object that should be removed
		 */
		virtual	void RemoveItem( rid id ) = 0;

		/**
		 * Adds an item to the table. The returned value is  the id of the item within the table,
		 * which can be used to retrieve the item using GetItem().  @param item is the item
		 * that is to be added to the table @return the id of the added item in the table
		 */
		virtual	rid AddItem( IObject *item ) = 0;

		/**
		 * Returns the i:th item, using the id of the item @param id is the id of the requested
		 * object @return the found object
		 */
		virtual	CountedPointer<IObject> GetItem( rid id ) = 0;

		/**
		 * Clears the table, and removes all items. If AddItem is called after Clear, the item
		 * ids will start over from 0
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Finds a named item in the table. If multiple items  have the same name, the first
		 * will be returned. If no item  was found, the return will be NULL. @param name is
		 * the string that is to be searched for @return the matching object, or NULL if no
		 * match was found
		 */
		virtual	CountedPointer<IObject> FindItem( const char * name ) = 0;

		/**
		 * Gets the number of item id:s in the table. If an item has been removed, using RemoveItem,
		 * the id is still  counted in this method. GetIdsCount also equals the id that will
		 * be applied to the next item added to the table. @return the itemcount of the table
		 */
		virtual	unsigned int GetItemsCount(  ) = 0;

		/**
		 * Sets an item in the table. The id must exist in the table. @param id is the id that
		 * is to be set @param item is the object set to the id 
		 */
		virtual	void SetItem( rid id , IObject *item ) = 0;

		/**
		 * Finds the id of an item in the table, using the name. If multiple items have the
		 * same name, the first will be returned. If no item was found, the return will be -1.
		 * @param name is the string that is to be searched for @return the id of the found
		 * object, or -1 if no match was found
		 */
		virtual	rid FindItemId( const char * name ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ITable
	 * ITable is the base class for tables objects, where items are added into an id-indexed
	 * array of objects. 
	 */
	typedef CountedPointer<ITable> spTable;

	class IShadingNode;
	class IImageData;
	class IMaterial;

	/**
	 * IMaterial keeps information on materials used while rendering.
	 */
	class IMaterial : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMaterial is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMaterial",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterial pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterial pointer
		 * @return a pointer to the IMaterial object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMaterial *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMaterial") )
				return static_cast<IMaterial*>(ptr);
			return NULL;
			}
		/**
		 * Get the base color of the material channel.  @param channel_name the name of the
		 * material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines
		 * @returns the value of the component
		 */
		virtual	real GetColorRed( const char * channel_name ) = 0;

		/**
		 * Set the luminance component index of the channel.  @param channel_name the name of
		 * the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param lum_component_index the component index, 0-3, RGBA
		 */
		virtual	void SetLuminanceComponentIndex( const char * channel_name , rid lum_component_index ) = 0;

		/**
		 * Save shading network to XML @param channel_name is the name of the channel @return
		 * the current shading network's exit node
		 */
		virtual	void LoadShadingNetworkFromXML( const char * channel_name , const char * in_xml ) = 0;

		/**
		 * Returns the name of a channel from the index. Note that by adding/removing channels
		 * the indices are changed, and this method should only be used for enumeration @param
		 * index is the index to the channel to be fetched @return the channel name corresponding
		 * to the index
		 */
		virtual	rstring GetChannelFromIndex( rid index ) = 0;

		/**
		 * Set the Diffuse Color component of the material @param val is the new color component
		 * value
		 */
		virtual	void SetDiffuseGreen( real val ) = 0;

		/**
		 * Get the blend type of a texture in a layered texture. Note that the SetTextureBlendType
		 * always sets the first texture (layer id 0) @param channel_name the name of the material
		 * channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param
		 * layer_id the layer id (0->size-1) @returns the blend type for the texture
		 */
		virtual	rid GetLayeredTextureBlendType( const char * channel_name , rid layer_id ) = 0;

		/**
		 * Set the Specular Color component of the material @param val is the new color component
		 * value
		 */
		virtual	void SetSpecularBlue( real val ) = 0;

		/**
		 * Set the Specular Color component of the material @param val is the new color component
		 * value
		 */
		virtual	void SetSpecularGreen( real val ) = 0;

		/**
		 * Set Displacement multiplier @param value is the new Displacement multiplier
		 */
		virtual	void SetDisplacement( real value ) = 0;

		/**
		 * Get the luminance component index of the channel. This is the component in the channel
		 * that  luminance should be extracted from  @returns the component index, 0-3, RGBA
		 */
		virtual	rid GetLuminanceComponentIndex( const char * channel_name ) = 0;

		/**
		 * Set the diffuse transparency override. If set, IsTransparent will always return true.
		 * @param value is the new DiffuseTextureHasAlpha value
		 */
		virtual	void SetDiffuseTextureHasAlpha( bool value ) = 0;

		/**
		 * Set the Ambient Color components of the material @param val is the new color component
		 * value
		 */
		virtual	void SetAmbientBlue( real val ) = 0;

		/**
		 * Set the Diffuse Color component of the material @param val is the new color component
		 * value
		 */
		virtual	void SetDiffuseRed( real val ) = 0;

		/**
		 * Returns true if the material is transparent, either by diffuse color, if there is
		 * an opacity texture, or the diffuse texture has an alpha channel
		 */
		virtual	bool IsTransparent(  ) = 0;

		/**
		 * Get a named texture filename. If a texture image is set using SetTextureImage/SetLayeredTextureImage
		 * , this parameter is not used to load texture data. @param channel_name the name of
		 * the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @returns the texture file name
		 */
		virtual	rstring GetTexture( const char * channel_name ) = 0;

		/**
		 * Get the vertex color channel used for the material channel.  @param channel_name
		 * the name of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @returns the vertex color channel, or -1 if no channel is set for the material
		 * channel
		 */
		virtual	rid GetVertexColorChannel( const char * channel_name ) = 0;

		/**
		 * Get which shading network to use for the material's channel @param channel_name is
		 * the name of the channel @return the current shading network's exit node<br />Description
		 * of IShadingNode: IShadingNode is the parent of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetShadingNetwork( const char * channel_name ) = 0;

		/**
		 * Save shading network to XML @param channel_name is the name of the channel @return
		 * the current shading network's exit node
		 */
		virtual	rstring SaveShadingNetworkToXML( const char * channel_name ) = 0;

		/**
		 * Get the Ambient Color components of the material @return the component value
		 */
		virtual	real GetAmbientRed(  ) = 0;

		/**
		 * Get Displacement multiplier @return the Displacement multiplier
		 */
		virtual	real GetDisplacement(  ) = 0;

		/**
		 * Get the base color of the material channel.  @param channel_name the name of the
		 * material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines
		 * @returns the value of the component
		 */
		virtual	real GetColorGreen( const char * channel_name ) = 0;

		/**
		 * Get the Specular Color component of the material @return the component value
		 */
		virtual	real GetSpecularRed(  ) = 0;

		/**
		 * Set a named texture image data. @param channel_name the name of the material channel.
		 * Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param image
		 * the image object
		 */
		virtual	void SetTextureImage( const char * channel_name , IImageData *image ) = 0;

		/**
		 * Get the luminance value of the channel. The value is stored in the color tuple, by
		 * default in the Red component. @returns the luminance value
		 */
		virtual	real GetLuminance( const char * channel_name ) = 0;

		/**
		 * Set the base color of the material channel.  @param channel_name the name of the
		 * material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines
		 * @param r the red value  @param g the green value  @param b the blue value  @param
		 * a the alpha value 
		 */
		virtual	void SetColor( const char * channel_name , real r , real g , real b , real a ) = 0;

		/**
		 * Get the Specular Color component of the material @return the component value
		 */
		virtual	real GetSpecularGreen(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) of all matching texture paths in the material,
		 * with the new one.  This method is useful when external textures are placed in a specific
		 * folder, which needs to be moved @param current_path_prefix the current prefix path,
		 * either relative or absolute @param new_path_prefix the new prefix path
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

		/**
		 * Get the number of textures maps in a layered texture @param channel_name the name
		 * of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @returns the number of textures in the layered texture (>=1)
		 */
		virtual	unsigned int GetLayeredTextureSize( const char * channel_name ) = 0;

		/**
		 * Get a named texture image data. @param channel_name the name of the material channel.
		 * Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @returns the
		 * texture object<br />Description of IImageData: IImageData holds unpacked image data.
		 * The data is  stored in an IFieldData object as value fields. For simplicity all 
		 * images are implemented as 3D images, but has an extent of 1 in Z for 2D images, and
		 * an extent of 1 in both Y and Z for 1D images. Cube maps are stored as a 3D image
		 * with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetTextureImage( const char * channel_name ) = 0;

		/**
		 * Set Shininess multiplier (0->128) @param value is the new Shininess value
		 */
		virtual	void SetShininess( real value ) = 0;

		/**
		 * Set a named texture texture coordinate level The valid values are 0->15 @param channel_name
		 * the name of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param level the texture coordinate level
		 */
		virtual	void SetTextureLevel( const char * channel_name , rid level ) = 0;

		/**
		 * Set a named texture image data in a layered texture. Note that the SetTextureImage
		 * always sets the first texture (layer id 0) @param channel_name the name of the material
		 * channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param
		 * layer_id the layer id (0->size-1) @param image the image object
		 */
		virtual	void SetLayeredTextureImage( const char * channel_name , rid layer_id , IImageData *image ) = 0;

		/**
		 * Get the Diffuse Color components of the material @return the component value
		 */
		virtual	real GetDiffuseRed(  ) = 0;

		/**
		 * Get the Ambient Color components of the material @return the component value
		 */
		virtual	real GetAmbientBlue(  ) = 0;

		/**
		 * Add a user material channel @param name is the name of the new channel
		 */
		virtual	void AddUserChannel( const char * channel_name ) = 0;

		/**
		 * Set a named texture filename. If a texture image is set using SetTextureImage/SetLayeredTextureImage
		 * , this parameter is not used to load texture data. @param channel_name the name of
		 * the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param texture_filename the texture file name
		 */
		virtual	void SetTexture( const char * channel_name , const char * texture_filename ) = 0;

		/**
		 * Get a named texture image data in a layered texture. Note that the SetTextureImage
		 * always sets the first texture (layer id 0) @param channel_name the name of the material
		 * channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param
		 * layer_id the layer id (0->size-1) @returns the texture object<br />Description of
		 * IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetLayeredTextureImage( const char * channel_name , rid layer_id ) = 0;

		/**
		 * Set the Ambient Color components of the material @param val is the new color component
		 * value
		 */
		virtual	void SetAmbientRed( real val ) = 0;

		/**
		 * Get the Ambient Color components of the material @return the component value
		 */
		virtual	real GetAmbientGreen(  ) = 0;

		/**
		 * Get a named texture texture coordinate level The valid values are 0->15 @param channel_name
		 * the name of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @returns the texture coordinate level
		 */
		virtual	rid GetTextureLevel( const char * channel_name ) = 0;

		/**
		 * Set the texture coordinate level of a texture in a layered texture. Note that the
		 * SetTextureLevel always sets the first texture (layer id 0) @param channel_name the
		 * name of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param layer_id the layer id (0->size-1) @param level the texture coordinate
		 * level
		 */
		virtual	void SetLayeredTextureLevel( const char * channel_name , rid layer_id , rid level ) = 0;

		/**
		 * Set the number of textures maps in a layered texture @param channel_name the name
		 * of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param size the number of textures in the layered texture (>=1)
		 */
		virtual	void SetLayeredTextureSize( const char * channel_name , unsigned int size ) = 0;

		/**
		 * Set the Diffuse Color component of the material @param val is the new color component
		 * value
		 */
		virtual	void SetDiffuseBlue( real val ) = 0;

		/**
		 * Get the Specular Color component of the material @return the component value
		 */
		virtual	real GetSpecularBlue(  ) = 0;

		/**
		 * Set the Diffuse Color of the material @param r is the red color component value @param
		 * g is the green color component value @param b is the blue color component value
		 */
		virtual	void SetDiffuseColor( real r , real g , real b ) = 0;

		/**
		 * Returns true if the material is setup identical to this material
		 */
		virtual	bool IsIdenticalTo( IMaterial *mat ) = 0;

		/**
		 * Set the Ambient Color of the material @param r is the red color component value @param
		 * g is the green color component value @param b is the blue color component value
		 */
		virtual	void SetAmbientColor( real r , real g , real b ) = 0;

		/**
		 * Set opacity of material (0->1) @param value is the new opacity value
		 */
		virtual	void SetOpacity( real value ) = 0;

		/**
		 * Set the Specular Color of the material @param r is the red color component value
		 * @param g is the green color component value @param b is the blue color component
		 * value
		 */
		virtual	void SetSpecularColor( real r , real g , real b ) = 0;

		/**
		 * Get opacity of material (0->1) @return the material opacity
		 */
		virtual	real GetOpacity(  ) = 0;

		/**
		 * Sets the base color to a luminance value. Note that this will replace the base color
		 * @param channel_name the name of the material channel. Default channels are defined
		 * in the SG_MATERIAL_CHANNEL_[...] defines @param lum the luminance value. 
		 */
		virtual	void SetLuminance( const char * channel_name , real lum ) = 0;

		/**
		 * Get the texture coordinate level of a texture in a layered texture. Note that the
		 * SetTextureLevel always sets the first texture (layer id 0) @param channel_name the
		 * name of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param layer_id the layer id (0->size-1) @returns the texture coordinate
		 * level
		 */
		virtual	rid GetLayeredTextureLevel( const char * channel_name , rid layer_id ) = 0;

		/**
		 * Set the blend type of a texture in a layered texture. Note that the SetTextureBlendType
		 * always sets the first texture (layer id 0) @param channel_name the name of the material
		 * channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param
		 * layer_id the layer id (0->size-1) @param blend_type the blend type to set
		 */
		virtual	void SetLayeredTextureBlendType( const char * channel_name , rid layer_id , rid blend_type ) = 0;

		/**
		 * Get the Diffuse Color components of the material @return the component value
		 */
		virtual	real GetDiffuseGreen(  ) = 0;

		/**
		 * Set a named texture filename in a layered texture. Note that the SetTexture always
		 * sets the first texture (layer id 0) @param channel_name the name of the material
		 * channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param
		 * layer_id the layer id (0->size-1) @param texture_filename the texture file name
		 */
		virtual	void SetLayeredTexture( const char * channel_name , rid layer_id , const char * texture_filename ) = 0;

		/**
		 * Get a named texture filename in a layered texture. Note that the SetTexture always
		 * sets the first texture (layer id 0) @param channel_name the name of the material
		 * channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines @param
		 * layer_id the layer id (0->size-1) @returns the texture file name
		 */
		virtual	rstring GetLayeredTexture( const char * channel_name , rid layer_id ) = 0;

		/**
		 * Get Shininess multiplier (0->128) @return the shininess value
		 */
		virtual	real GetShininess(  ) = 0;

		/**
		 * Set/Get the TangentSpaceNormals flag. If set, the normal map has tangent space normals
		 */
		virtual	void SetTangentSpaceNormals( bool value ) = 0;

		/**
		 * Get the Diffuse Color components of the material @return the component value
		 */
		virtual	real GetDiffuseBlue(  ) = 0;

		/**
		 * Set the Specular Color component of the material @param val is the new color component
		 * value
		 */
		virtual	void SetSpecularRed( real val ) = 0;

		/**
		 * Set which shading network to use for the material's channel @param channel_name is
		 * the name of the new channel @param node the shading network's exit node
		 */
		virtual	void SetShadingNetwork( const char * channel_name , IShadingNode *node ) = 0;

		/**
		 * Set the Ambient Color components of the material @param val is the new color component
		 * value
		 */
		virtual	void SetAmbientGreen( real val ) = 0;

		/**
		 * Set/Get the TangentSpaceNormals flag. If set, the normal map has tangent space normals
		 */
		virtual	bool GetTangentSpaceNormals(  ) = 0;

		/**
		 * Get the diffuse transparency override. If set, IsTransparent will always return true.
		 * @return the current value of the DiffuseTextureHasAlpha bool
		 */
		virtual	bool GetDiffuseTextureHasAlpha(  ) = 0;

		/**
		 * Returns the number of material channels in the material @return the current channel
		 * count
		 */
		virtual	unsigned int GetChannelCount(  ) = 0;

		/**
		 * Remove a user material channel @param name is the name of the channel to be removed
		 */
		virtual	void RemoveUserChannel( const char * channel_name ) = 0;

		/**
		 * Get the base color of the material channel.  @param channel_name the name of the
		 * material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines
		 * @returns the value of the component
		 */
		virtual	real GetColorBlue( const char * channel_name ) = 0;

		/**
		 * Check if the user channel exists within the material. @param name is the name to
		 * be searched for @return true if the channel exists, false if not
		 */
		virtual	bool HasUserChannel( const char * channel_name ) = 0;

		/**
		 * Set the base color of the material channel.  @param channel_name the name of the
		 * material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines
		 * @param r the red value  @param g the green value  @param b the blue value 
		 */
		virtual	void SetColorRGB( const char * channel_name , real r , real g , real b ) = 0;

		/**
		 * Get the base color of the material channel.  @param channel_name the name of the
		 * material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...] defines
		 * @returns the value of the component
		 */
		virtual	real GetColorAlpha( const char * channel_name ) = 0;

		/**
		 * Set the vertex color channel used for the material channel.  @param channel_name
		 * the name of the material channel. Default channels are defined in the SG_MATERIAL_CHANNEL_[...]
		 * defines @param vertex_color_channel_id the vertex color channel to use for the material
		 * channel, or -1 to not use the current vertex color channel
		 */
		virtual	void SetVertexColorChannel( const char * channel_name , rid vertex_color_channel_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMaterial
	 * IMaterial keeps information on materials used while rendering.
	 */
	typedef CountedPointer<IMaterial> spMaterial;

	class IMaterial;
	class IRidArray;

	/**
	 * IMaterialTable keeps information on materials used while rendering.
	 */
	class IMaterialTable : public ITable
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMaterialTable is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMaterialTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterialTable pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterialTable pointer
		 * @return a pointer to the IMaterialTable object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMaterialTable *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMaterialTable") )
				return static_cast<IMaterialTable*>(ptr);
			return NULL;
			}
		/**
		 * Finds a material in the table that is setup identical to the specified material.
		 * @param mat the material setup to look for @return the material, if found, NULL otherwise<br
		 * />Description of IMaterial: IMaterial keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterial> FindIdenticalMaterial( IMaterial *mat ) = 0;

		/**
		 * Adds a material to the table. The returned value is  the id of the material within
		 * the table. @param material the material to add into the table @return the material
		 * id of the material in the table
		 */
		virtual	rid AddMaterial( IMaterial *material ) = 0;

		/**
		 * Finds the id of a material in the table, using the material name. If multiple materials
		 * have the same name, the first will be returned. If the material was not found, the
		 * return will be -1. @param name the material name to look for @return the material
		 * id if found, -1 otherwise
		 */
		virtual	rid FindMaterialId( const char * name ) = 0;

		/**
		 * Clears the table, and removes all items. If AddItem is called after Clear, the item
		 * ids will start over from 0
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Sets an item in the table. The id must exist in the table. @param id is the id that
		 * is to be set @param item is the object set to the id 
		 */
		virtual	void SetItem( rid id , IObject *item ) = 0;

		/**
		 * Sets a material in the table.  @param id the id of the material in the table @param
		 * material the material to set into the table
		 */
		virtual	void SetMaterial( rid id , IMaterial *material ) = 0;

		/**
		 * Finds the materials in the table that are setup identical to the specified material.
		 * @param mat the material setup to look for @return the an array material ids if found,
		 * NULL otherwise<br />Description of IRidArray: IRidArray is the rid implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRidArray> FindIdenticalMaterialIds( IMaterial *mat ) = 0;

		/**
		 * Returns the i:th material, using the id of the material @param id the id of the material
		 * in the table @return the the material in the table<br />Description of IMaterial:
		 * IMaterial keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetMaterial( rid id ) = 0;

		/**
		 * Removes a material. If GetMaterial is called with the material id, the value returned
		 * will be NULL. @param id the id of the material in the table
		 */
		virtual	void RemoveMaterial( rid id ) = 0;

		/**
		 * Adds an item to the table. The returned value is  the id of the item within the table,
		 * which can be used to retrieve the item using GetItem().  @param item is the item
		 * that is to be added to the table @return the id of the added item in the table
		 */
		virtual	rid AddItem( IObject *item ) = 0;

		/**
		 * Finds the id of an item in the table, using the name. If multiple items have the
		 * same name, the first will be returned. If no item was found, the return will be -1.
		 * @param name is the string that is to be searched for @return the id of the found
		 * object, or -1 if no match was found
		 */
		virtual	rid FindItemId( const char * name ) = 0;

		/**
		 * Removes an item, and invalidates the id. The id will not point at a valid item, until
		 * Clear is called and new items are added up until the id. @param id the id of the
		 * object that should be removed
		 */
		virtual	void RemoveItem( rid id ) = 0;

		/**
		 * Gets the number of item id:s in the table. If an item has been removed, using RemoveItem,
		 * the id is still  counted in this method. GetIdsCount also equals the id that will
		 * be applied to the next item added to the table. @return the itemcount of the table
		 */
		virtual	unsigned int GetItemsCount(  ) = 0;

		/**
		 * Returns the i:th item, using the id of the item @param id is the id of the requested
		 * object @return the found object
		 */
		virtual	CountedPointer<IObject> GetItem( rid id ) = 0;

		/**
		 * Finds a material in the table, using the material name. If multiple materials have
		 * the same name, the first will be returned. If the material was not found, the return
		 * will be NULL. @param name the material name to look for @return the material, if
		 * found, NULL otherwise<br />Description of IMaterial: IMaterial keeps information
		 * on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterial> FindMaterial( const char * name ) = 0;

		/**
		 * Finds the id of a material in the table that is setup identical to the specified
		 * material. @param mat the material setup to look for @return the material id if found,
		 * -1 otherwise
		 */
		virtual	rid FindIdenticalMaterialId( IMaterial *mat ) = 0;

		/**
		 * Returns the number of materials in the table
		 */
		virtual	unsigned int GetMaterialsCount(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) of all matching texture paths in all the
		 * materials in the table, with the new one.  This method is useful when external textures
		 * are placed in a specific folder, which needs to be moved @param current_path_prefix
		 * the current prefix path, either relative or absolute @param new_path_prefix the new
		 * prefix path		
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

		/**
		 * Finds a named item in the table. If multiple items  have the same name, the first
		 * will be returned. If no item  was found, the return will be NULL. @param name is
		 * the string that is to be searched for @return the matching object, or NULL if no
		 * match was found
		 */
		virtual	CountedPointer<IObject> FindItem( const char * name ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMaterialTable
	 * IMaterialTable keeps information on materials used while rendering.
	 */
	typedef CountedPointer<IMaterialTable> spMaterialTable;

	class IMatrix4x4;
	class IRealArray;

	/**
	 * IMatrix4x4 is used to represent and manipulate 4x4  transformation matrices, which
	 * can be either standard matrices, or  homogeneous 4x4 matrices used to transform 3D
	 * homogeneous coordinates  [x y z w]. The transformations are defined in row-major
	 * order.
	 */
	class IMatrix4x4 : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMatrix4x4 is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMatrix4x4",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMatrix4x4 pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMatrix4x4 pointer
		 * @return a pointer to the IMatrix4x4 object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMatrix4x4 *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMatrix4x4") )
				return static_cast<IMatrix4x4*>(ptr);
			return NULL;
			}
		/**
		 * Set the current matrix to the zero matrix (all zeros).
		 */
		virtual	void Zero(  ) = 0;

		/**
		 * Multiply in-place an array with 3D points [x y z 1]. @param vecarray is the vectors
		 * to be multiplied and written to
		 */
		virtual	void Point3ArrayMultiply( IRealArray *vecarray ) = 0;

		/**
		 * Set a matrix element. @param column is column index @param row is the row index @param
		 * value is the value to which the element will be set
		 */
		virtual	void SetElement( unsigned int column , unsigned int row , real value ) = 0;

		/**
		 * Set the current matrix to the identity matrix.
		 */
		virtual	void Identity(  ) = 0;

		/**
		 * Creates a 3D scaling in a homogeneous transformation 4x4 matrix @param angle is the
		 * angle @param sx is the x component of the scaling @param sy is the y component of
		 * the scaling @param sz is the z component of the scaling
		 */
		virtual	void SetToScalingTransform( real sx , real sy , real sz ) = 0;

		/**
		 * Creates a 3D translation in a homogeneous 4x4 matrix.  @param tx is the x component
		 * of the scaling @param ty is the y component of the scaling @param tz is the z component
		 * of the scaling
		 */
		virtual	void SetToTranslationTransform( real tx , real ty , real tz ) = 0;

		/**
		 * Invert the input matrix and save it to the current matrix. @param mtxin is the input
		 * matrix
		 */
		virtual	void Invert( IMatrix4x4 *mtxin ) = 0;

		/**
		 * Multiply in-place an array with 3D direction vectors [x y z 0]. @param vecarray is
		 * the vectors to be multiplied and written to
		 */
		virtual	void Direction3ArrayMultiply( IRealArray *vecarray ) = 0;

		/**
		 * Multiply in-place an array with full 4D vectors [x y z w].  @param vecarray is the
		 * vectors to be multiplied and written to
		 */
		virtual	void Vector4ArrayMultiply( IRealArray *vecarray ) = 0;

		/**
		 * Get a matrix element. @param column is column index @param row is the row index @return
		 * the value of the element
		 */
		virtual	real GetElement( unsigned int column , unsigned int row ) = 0;

		/**
		 * Creates a 3D rotation in a homogeneous transformation 4x4 matrix around the specified
		 * axis. @param angle is the angle @param ax is the x component of the rotation axis
		 * @param ay is the y component of the rotation axis @param az is the z component of
		 * the rotation axis
		 */
		virtual	void SetToRotationTransform( real angle , real ax , real ay , real az ) = 0;

		/**
		 * Gets the elements of the matrix @return an array containing all elements@param dest_param
		 * a pointer to the destination memory area
		 */
		virtual	void GetElements( real dest_param[16] ) = 0;

		/**
		 * Copies the contents of an input matrix to the current matrix @param mtxin is the
		 * source matrix
		 */
		virtual	void DeepCopy( IMatrix4x4 *mtxin ) = 0;

		/**
		 * Invert the current matrix.
		 */
		virtual	void Invert(  ) = 0;

		/**
		 * Transpose the input matrix and save it to the current matrix. @param mtxin is the
		 * input matrix
		 */
		virtual	void Transpose( IMatrix4x4 *mtxin ) = 0;

		/**
		 * Transpose the current matrix
		 */
		virtual	void Transpose(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMatrix4x4
	 * IMatrix4x4 is used to represent and manipulate 4x4  transformation matrices, which
	 * can be either standard matrices, or  homogeneous 4x4 matrices used to transform 3D
	 * homogeneous coordinates  [x y z w]. The transformations are defined in row-major
	 * order.
	 */
	typedef CountedPointer<IMatrix4x4> spMatrix4x4;

	class IMatrix4x4;
	class IRealArray;
	class ITransform3;

	/**
	 * ITransform3 handles homogeneous 4x4  transforms, i.e. transformations which can be
	 * represented by  multiplying a 4x4 matrix with a homogeneous 3D coordinate. <br> ITransform3
	 * can either pre-multiply a matrix onto the transformation, which will add a transform
	 * around the current transform, or it can post-multiply the matrix, which will add
	 * a transform inside the current transform. Post-multiply is the default mode.
	 */
	class ITransform3 : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ITransform3 is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ITransform3",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITransform3 pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITransform3 pointer
		 * @return a pointer to the ITransform3 object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ITransform3 *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ITransform3") )
				return static_cast<ITransform3*>(ptr);
			return NULL;
			}
		/**
		 * Set the transform concatenation mode to post-multiply, any added transform will be
		 * concatenated using this mode. 
		 */
		virtual	void PostMultiply(  ) = 0;

		/**
		 * Set the transform concatenation mode to pre-multiply, any added transform will be
		 * concatenated using this mode. 
		 */
		virtual	void PreMultiply(  ) = 0;

		/**
		 * Get the real array that is used to store the matrix stack @return the matrix stack
		 * array<br />Description of IRealArray: IRealArray is the real implementation of IValueArray.
		 * See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetStack(  ) = 0;

		/**
		 * Concatenates a translation transform to the current transform @param tx the translation
		 * vector's x component @param ty the translation vector's y component @param tz the
		 * translation vector's z component
		 */
		virtual	void AddTranslation( real tx , real ty , real tz ) = 0;

		/**
		 * Get the transform concatenation mode. @return true if the mode is set to post-multiply,
		 * false otherwise
		 */
		virtual	bool IsPostMultiply(  ) = 0;

		/**
		 * Concatenates a scaling transform to the current transform @param sx the scaling vector's
		 * x axis component  @param sy the scaling vector's y axis component  @param sz the
		 * scaling vector's z axis component 
		 */
		virtual	void AddScaling( real sx , real sy , real sz ) = 0;

		/**
		 * Concatenates a generic transform to the current transform @param transform the input
		 * transform
		 */
		virtual	void AddTransformation( IMatrix4x4 *transform ) = 0;

		/**
		 * Resets the transformation to the identity transform, resets the  multiplication mode
		 * to postmultiply, and clears the matrix stack
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the transform concatenation mode. @return true if the mode is set to pre-multiply,
		 * false otherwise
		 */
		virtual	bool IsPreMultiply(  ) = 0;

		/**
		 * Pushes the current transform onto the matrix stack
		 */
		virtual	void Push(  ) = 0;

		/**
		 * Pops the topmost matrix on the the matrix stack, and replaces the current transform
		 * with the popped matrix.
		 */
		virtual	void Pop(  ) = 0;

		/**
		 * Get the matrix that is used to specify the transform @return the transform matrix<br
		 * />Description of IMatrix4x4: IMatrix4x4 is used to represent and manipulate 4x4 
		 * transformation matrices, which can be either standard matrices, or  homogeneous 4x4
		 * matrices used to transform 3D homogeneous coordinates  [x y z w]. The transformations
		 * are defined in row-major order.
		 */
		virtual	CountedPointer<IMatrix4x4> GetMatrix(  ) = 0;

		/**
		 * Concatenates a rotation transform to the current transform @param angle the rotation
		 * angle around the axis @param rx the x axis rotation component @param ry the y axis
		 * rotation component @param rz the z axis rotation component
		 */
		virtual	void AddRotation( real angle , real rx , real ry , real rz ) = 0;

		/**
		 * Concatenates a generic transform to the current transform @param transform the input
		 * transform
		 */
		virtual	void AddTransformation( ITransform3 *transform ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ITransform3
	 * ITransform3 handles homogeneous 4x4  transforms, i.e. transformations which can be
	 * represented by  multiplying a 4x4 matrix with a homogeneous 3D coordinate. <br> ITransform3
	 * can either pre-multiply a matrix onto the transformation, which will add a transform
	 * around the current transform, or it can post-multiply the matrix, which will add
	 * a transform inside the current transform. Post-multiply is the default mode.
	 */
	typedef CountedPointer<ITransform3> spTransform3;

	class IChunkedImageData;
	class IMappingImageMeshData;

	/**
	 * IMappingImage stores the mapping between a processed geometry and the source geometry
	 * it is based on. The mapping image object also stores multisampling settings. It can
	 * be used to cast information from the original geometry to the processed geometry,
	 * such as surface transfer or calculating normal maps. See IMaterialCaster and subclasses
	 * for casting uses.
	 */
	class IMappingImage : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImage is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMappingImage",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImage pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImage pointer
		 * @return a pointer to the IMappingImage object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMappingImage *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMappingImage") )
				return static_cast<IMappingImage*>(ptr);
			return NULL;
			}
		/**
		 * Get the number of layers of the mapping texture.  @return the LayerCount of the mapping
		 * texture
		 */
		virtual	unsigned int GetLayerCount(  ) = 0;

		/**
		 * Get the multi sampling width of the mapping texture.  @return the multi sampling
		 * width
		 */
		virtual	unsigned int GetMultisamplingWidth(  ) = 0;

		/**
		 * Get the multi sampling height of the mapping texture.  @return the multi sampling
		 * height
		 */
		virtual	unsigned int GetMultisamplingHeight(  ) = 0;

		/**
		 * Get the ImageData object, which stores the mapping data @return the ImageData object<br
		 * />Description of IChunkedImageData: ReChunkedImageData holds chunks for ReImageData
		 * objects. ReImageData objects can be referenced, and swapped in/out of memory,  to
		 * secondary storage. This is useful for very large images that cannot be stored in-memory.
		 * ReImageData objects can be indexed in 1-,2- or 3D, and each ReImageData chunk is
		 * cloned from a source ReImageData object, at setup. Fields added to ReImageData chunks
		 * after setup will only be added into that chunk, and is not recommended.
		 */
		virtual	CountedPointer<IChunkedImageData> GetImageData(  ) = 0;

		/**
		 * Get the IMappingImageMeshData Mesh data that is used to retrieve the  triangle mapping
		 * to mesh information to map back to the original scene. @return the mapping mesh data
		 * object<br />Description of IMappingImageMeshData: IMappingImageMeshData stores the
		 * mapped meshes and their paths in the original scene. This can be used to find a specific
		 * triangle on the original mesh in the scene from the combined id in the mapping image.
		 */
		virtual	CountedPointer<IMappingImageMeshData> GetMappingMeshData(  ) = 0;

		/**
		 * Get the height of the mapping texture.  @return the Height of the mapping texture
		 */
		virtual	unsigned int GetHeight(  ) = 0;

		/**
		 * Get the width of the mapping texture.  @return the Width of the mapping texture
		 */
		virtual	unsigned int GetWidth(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMappingImage
	 * IMappingImage stores the mapping between a processed geometry and the source geometry
	 * it is based on. The mapping image object also stores multisampling settings. It can
	 * be used to cast information from the original geometry to the processed geometry,
	 * such as surface transfer or calculating normal maps. See IMaterialCaster and subclasses
	 * for casting uses.
	 */
	typedef CountedPointer<IMappingImage> spMappingImage;


	/**
	 * IProcessingObject is the abstract base class for all processing objects in Simplygon.
	 * Processing objects take parameters, exports the RunProcessing to run the main processing
	 * and Clear to  clear the internal states of the processing object. All processing
	 * objects also export information on how far the process has moved and the possibility
	 * to cancel long running processings.
	 */
	class IProcessingObject : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IProcessingObject is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IProcessingObject",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IProcessingObject pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IProcessingObject pointer
		 * @return a pointer to the IProcessingObject object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IProcessingObject *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IProcessingObject") )
				return static_cast<IProcessingObject*>(ptr);
			return NULL;
			}
		/**
		 * Clear all internal states of the object. This will NOT clear the parameters set in
		 * the object.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Runs the processing the object is designed for
		 */
		virtual	void RunProcessing(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IProcessingObject
	 * IProcessingObject is the abstract base class for all processing objects in Simplygon.
	 * Processing objects take parameters, exports the RunProcessing to run the main processing
	 * and Clear to  clear the internal states of the processing object. All processing
	 * objects also export information on how far the process has moved and the possibility
	 * to cancel long running processings.
	 */
	typedef CountedPointer<IProcessingObject> spProcessingObject;

	class IGeometryData;
	class IRealArray;

	/**
	 * Computes texture coordinates for arbitrary geometry.
	 */
	class IParameterizer : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IParameterizer is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IParameterizer",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IParameterizer pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IParameterizer pointer
		 * @return a pointer to the IParameterizer object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IParameterizer *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IParameterizer") )
				return static_cast<IParameterizer*>(ptr);
			return NULL;
			}
		/**
		 * If UseVisibilityWeights is enabled, the weights help determine the UV charts and
		 * their UV area. @return the current flag
		 */
		virtual	bool GetUseVisibilityWeights(  ) = 0;

		/**
		 * Get the number of output mapping images that are to be generated. @return the current
		 * value of OutputMaterialCount
		 */
		virtual	unsigned int GetOutputMaterialCount(  ) = 0;

		/**
		 * Set the height of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureHeight( unsigned int value ) = 0;

		/**
		 * Get the number of input materials set earlier. 0 signifies that no in-out material
		 * mapping is used. @return the current value of InputMaterialCount
		 */
		virtual	unsigned int GetInputMaterialCount(  ) = 0;

		/**
		 * If UseVertexWeights is enabled, the weights help determine the UV charts and their
		 * UV area. @param value the desired flag
		 */
		virtual	void SetUseVertexWeights( bool value ) = 0;

		/**
		 * Set/Get the packing performance setting the value is in the range 0->1, where 0 has
		 * the lowest packing efficiency, but runs the fastest, and 1 has the highest packing
		 * efficiency but runs slower. @param value is the value to which PackingEfficency will
		 * be set
		 */
		virtual	void SetPackingEfficency( real value ) = 0;

		/**
		 * Set a texture dimension length multiplier for the automatic  texture size.  @param
		 * value the desired multiplier
		 */
		virtual	void SetAutomaticTextureSizeMultiplier( real value ) = 0;

		/**
		 * Get the width of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureWidth(  ) = 0;

		/**
		 * Set the automatic_texture_size flag. If true, then texture sizes will be computed
		 * for the reduced mesh depending on its pixel size on screen. @param value the desired
		 * flag
		 */
		virtual	void SetAutomaticTextureSize( bool value ) = 0;

		/**
		 * Set/Get the packing performance setting the value is in the range 0->1, where 0 has
		 * the lowest packing efficiency, but runs the fastest, and 1 has the highest packing
		 * efficiency but runs slower. @return the current value of PackingEfficency
		 */
		virtual	real GetPackingEfficency(  ) = 0;

		/**
		 * If UseVertexWeights is enabled, the weights help determine the UV charts and their
		 * UV area. @return the current flag
		 */
		virtual	bool GetUseVertexWeights(  ) = 0;

		/**
		 * Set the height of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureHeight( unsigned int id , unsigned int value ) = 0;

		/**
		 * Get the minimum number of pixels between charts. @return the current value of GutterSpace
		 */
		virtual	unsigned int GetGutterSpace( unsigned int id ) = 0;

		/**
		 * Executes the parameterization of the geometry. @param geom is the geometry which
		 * is to be parameterized @param arr will contain the completed parameterization @return
		 * true if the parameterization succeeds, false otherwise
		 */
		virtual	bool Parameterize( IGeometryData *geom , IRealArray *arr ) = 0;

		/**
		 * Set the number of input materials used in the original geometry for mapping to multiple
		 * output materials. This needs to be set before you can set any specific in-out material
		 * mapping.  0 signifies that no in-out material mapping is used, ie. the process will
		 * produce one resulting mapping image. @param value is the number of outputs
		 */
		virtual	void SetInputMaterialCount( unsigned int value ) = 0;

		/**
		 * Set the material mapping for mat_id, meaning what material of the generated LOD mat_id
		 * will be baked into. Both InputMaterialCount and OutputMaterialCount need to be set
		 * for this mapping to work, and all original materials need to be mapped to an existing
		 * output id. @param value is the number of outputs
		 */
		virtual	void SetInputOutputMaterialMapping( unsigned int InMaterialId , int OutMaterialId ) = 0;

		/**
		 * Get the width of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureWidth( unsigned int id ) = 0;

		/**
		 * If UseVisibilityWeights is enabled, the weights help determine the UV charts and
		 * their UV area. @param value the desired flag
		 */
		virtual	void SetUseVisibilityWeights( bool value ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the  texture sizes to be a power
		 * of 2 @return the current flag
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * Set the automatic_texture_size flag. If true, then texture sizes will be computed
		 * for the reduced mesh depending on its pixel size on screen. @return the current flag
		 */
		virtual	bool GetAutomaticTextureSize(  ) = 0;

		/**
		 * Get the height of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureHeight(  ) = 0;

		/**
		 * Set the maximum allowed texture stretch. Range 0->1 @param value is the value to
		 * which MaxStretch will be set
		 */
		virtual	void SetMaxStretch( real value ) = 0;

		/**
		 * Get the previously set material mapping for mat_id. @return the currently mapped
		 * output material for InMaterialId. -1 means mapping is not set.
		 */
		virtual	int GetInputOutputMaterialMapping( unsigned int InMaterialId ) = 0;

		/**
		 * Set the width of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureWidth( unsigned int value ) = 0;

		/**
		 * Set the number of output mapping images that are to be generated. The triangle field
		 * OutputMaterialIds also needs to be set,  or the material ids of the original geometry
		 * needs to be set to a specific output material in this setting object. @param value
		 * is the number of outputs
		 */
		virtual	void SetOutputMaterialCount( unsigned int value ) = 0;

		/**
		 * Get the current automatic texture size multiplier. @return the current multiplier
		 */
		virtual	real GetAutomaticTextureSizeMultiplier(  ) = 0;

		/**
		 * Get the height of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureHeight( unsigned int id ) = 0;

		/**
		 * Get the maximum allowed texture stretch. Range 0->1 @return the current value of
		 * MaxStretch
		 */
		virtual	real GetMaxStretch(  ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the  texture sizes to be a power
		 * of 2 @param value the desired flag
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

		/**
		 * Set the width of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureWidth( unsigned int id , unsigned int value ) = 0;

		/**
		 * Set the minimum number of pixels between charts. @param value is the value to which
		 * GutterSpace will be set
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * Set the minimum number of pixels between charts. @param value is the value to which
		 * GutterSpace will be set
		 */
		virtual	void SetGutterSpace( unsigned int id , unsigned int value ) = 0;

		/**
		 * Get the FeatureFlagsMask. Any edge that has  one of the flags present as a feature
		 * edge, will have the edge forced as a parameterization feature. @return the current
		 * FeatureFlagsMask
		 */
		virtual	unsigned int GetFeatureFlagsMask(  ) = 0;

		/**
		 * Get the minimum number of pixels between charts. @return the current value of GutterSpace
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

		/**
		 * Set the FeatureFlagsMask. Any edge that has  one of the flags present as a feature
		 * edge, will have the edge forced as a parameterization feature. @param value is the
		 * mask to which FeatureFlagsMask will be set
		 */
		virtual	void SetFeatureFlagsMask( unsigned int value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IParameterizer
	 * Computes texture coordinates for arbitrary geometry.
	 */
	typedef CountedPointer<IParameterizer> spParameterizer;

	class IGeometryData;
	class IGeometryDataCollection;

	/**
	 * A grouping of objects that process in conjunction.
	 */
	class IGeometryGroup : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryGroup is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGeometryGroup",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryGroup pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryGroup pointer
		 * @return a pointer to the IGeometryGroup object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGeometryGroup *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGeometryGroup") )
				return static_cast<IGeometryGroup*>(ptr);
			return NULL;
			}
		/**
		 * Appends geometry data to the combined geometry data, the return value is the id of
		 * the object within the group. All triangles in the combined geometry that comes from
		 * this geometry will have the field "GroupId" set to this id. Please note that the
		 * original geometry will not be placed in the group, but  a copy of the object. Note!
		 * That the field "GroupId" must not exist in the  source geometry. @param source_geometry
		 * the geometry to add to the combined geometry data @return the group id of the geometry
		 * data copy in the combined geometry
		 */
		virtual	rid AppendGeometryData( IGeometryData *source_geometry ) = 0;

		/**
		 * Extracts all geometries into a collection. Please note that  just as in GetSplitGeometryData,
		 * the same geometry objects are extracted  and returned each time. Because of setup
		 * time, calling this method is  much faster than calling GetSplitGeometryData for each
		 * geometry in the group. @return the collection of all the geometries in the IGeometryGroup<br
		 * />Description of IGeometryDataCollection: IGeometryDataCollection holds a number
		 * of IGeometryData  objects. The objects can be looked up by their names (if they have
		 * been named through IObject::SetName() ).
		 */
		virtual	CountedPointer<IGeometryDataCollection> NewSplitGeometryDataCollection(  ) = 0;

		/**
		 * Get the name of a geometry group @param group_id the group id in the combined geometry
		 * @return the name of the geometry
		 */
		virtual	rstring GetGroupName( rid group_id ) = 0;

		/**
		 * Sets the combined geometry and split geometries from  a geometry that already contains
		 * GroupIds. Note that the  actual geometry is now referenced, and will be returned
		 * by  a call to GetCombinedGeometry(). The combined geometry *must* have group ids
		 * in the range 0 -> (group_counts-1). @param geom the geometry with GroupIds to be
		 * placed in the combined geometry @param group_counts the number of groups in the geometry
		 */
		virtual	void ConnectToExistingCombinedGeometry( IGeometryData *geom , unsigned int group_counts ) = 0;

		/**
		 * Get the combined geometry object @return the combined geometry object<br />Description
		 * of IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetCombinedGeometry(  ) = 0;

		/**
		 * Get the CopyNewCombinedFields flag. If true, the split  geometry data objects will
		 * receive newly added fields in the combined geometry data object. @return the current
		 * CopyNewCombinedFields flag
		 */
		virtual	bool GetCopyNewCombinedFields(  ) = 0;

		/**
		 * Clears the group, releases all geometry data
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the name of a geometry group @param group_id the group id in the combined geometry
		 * @param group_id the desired name of the particular group
		 */
		virtual	void SetGroupName( rid group_id , const char * str ) = 0;

		/**
		 * Set the CopyNewCombinedFields flag. If true, the split  geometry data objects will
		 * receive newly added fields in the combined geometry data object. @param value the
		 * new CopyNewCombinedFields flags
		 */
		virtual	void SetCopyNewCombinedFields( bool value ) = 0;

		/**
		 * Sets the group from a geometry collection. This will clear the group, and append
		 * all geometries in the collection, in the order they are listed within the collection.
		 * Returns the number of added geometries from the collection @param collection a collection
		 * of geometry data objects @return the number of geometry groups in the combined geometry
		 */
		virtual	unsigned int SetFromGeometryCollection( IGeometryDataCollection *collection ) = 0;

		/**
		 * Retrieve a pointer to a specific geometry within the group. The id is the same as
		 * was returned when appending the geometry to the group.  Before returning, the object
		 * returned will be updated from the combined geometry, this may impact performance
		 * if the function is unnecessarily called.  Please note that the returned geometry
		 * is not the same as was appended, but a  copy of that geometry. The same geometry
		 * is however returned each time. @param geometry_id the id of the requested geometry
		 * @return the IGeometryData object from the combined geometry<br />Description of IGeometryData:
		 * IGeometryData represents a geometric structure  consisting of point data (Vertices)
		 * and topological data (Triangles). IGeometryData may represent a whole geometric object,
		 * but can also be used by streaming data filters, and in this way, only represents
		 * a part of the object. <br><br> Different fields in the Vertices and Triangles fields
		 * data  objects will contain point data and topological data. The standard  naming
		 * convention used in the filters/renderers are as follows: (Case sensitive naming,
		 * other fields may also be present) <br><br> 'Coords' <br> Positional coordinates of
		 * a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0' -
		 * 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetSplitGeometryData( rid geometry_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGeometryGroup
	 * A grouping of objects that process in conjunction.
	 */
	typedef CountedPointer<IGeometryGroup> spGeometryGroup;


	/**
	 * IObjectCollection and its specializations handles a collection of  IObjects. There
	 * are methods for adding, removing and iterating through  the objects.
	 */
	class IObjectCollection : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IObjectCollection is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IObjectCollection",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IObjectCollection pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IObjectCollection pointer
		 * @return a pointer to the IObjectCollection object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IObjectCollection *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IObjectCollection") )
				return static_cast<IObjectCollection*>(ptr);
			return NULL;
			}
		/**
		 * Returns the handle to the next item in the collection. Use  GetFirstItem and this
		 * method to step through the collection. If the return is NULL, the end of the collection
		 * has been reached. @param objhandle is the handle of an object i @return the handle
		 * of the object i+1
		 */
		virtual	rhandle GetNextItem( rhandle objhandle ) = 0;

		/**
		 * Returns true if the object is in the collection @param pobj is the object to be checked
		 * for @return true if the collection contains pobj, false otherwise
		 */
		virtual	bool IsObjectInCollection( IObject *pobj ) = 0;

		/**
		 * Adds an object to the collection, as AddObject, but sorts the object into the collection
		 * based on its name. @param obj is the object that is to be added to the collection
		 * @param ascending determines the sorting order @return the handle of the added object
		 * in the collection
		 */
		virtual	rhandle AddObjectSorted( IObject *obj , bool ascending ) = 0;

		/**
		 * Adds an object to the collection. The handle refers to the object until the object
		 * is removed from the collection again. @param obj is the object that is to be added
		 * to the collection @return the handle of the added object in the collection
		 */
		virtual	rhandle AddObject( IObject *obj ) = 0;

		/**
		 * Finds a named object in the collection. The first object  with this name is returned.
		 * The search is case-sensitive. @param name is the name of an object in the collection
		 * @return the object with the relevant name, or NULL if none is found
		 */
		virtual	CountedPointer<IObject> FindObject( const char * name ) = 0;

		/**
		 * Returns the handle of the i:th item @param index is the index of an object in the
		 * collection @return the handle of the object with the relevant index
		 */
		virtual	rhandle GetItem( unsigned int index ) = 0;

		/**
		 * Returns the start of the collection. The handle returned refers to the first object
		 * in the collection. If the handle is  NULL, then the collection is empty. @return
		 * the first item in collection, or NULL if collection is empty
		 */
		virtual	rhandle GetFirstItem(  ) = 0;

		/**
		 * Returns the object of the i:th item @param index is the index of an object in the
		 * collection @return the object with the relevant index
		 */
		virtual	CountedPointer<IObject> GetItemAsObject( unsigned int index ) = 0;

		/**
		 * Gets the object the handle is referring to. @param objhandle is the handle of an
		 * object in the collection @return the object associated with the handle
		 */
		virtual	CountedPointer<IObject> GetItemsObject( rhandle objhandle ) = 0;

		/**
		 * Returns true if the item is in the collection @param objhandle is the handle of an
		 * object to be checked for @return true if the collection contains the object, false
		 * otherwise
		 */
		virtual	bool IsItemInCollection( rhandle objhandle ) = 0;

		/**
		 * Removes an item from the collection. The handle returned is the first item after
		 * this item that is in the collection. If the return is NULL, the item was the last
		 * item in the collection. Warning! The handle is invalid after the removal of the object.
		 * @param objhandle is the handle of the object that is to be removed @return the handle
		 * to the item following the removed one, or NULL if collection is now empty
		 */
		virtual	rhandle RemoveItem( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurance of the object is
		 * removed from the collection.  @param pobj is the object that is to be removed
		 */
		virtual	void RemoveObject( IObject *pobj ) = 0;

		/**
		 * Removes all items from the collection.
		 */
		virtual	void RemoveAllItems(  ) = 0;

		/**
		 * Get the number of items in the collection. @return the number of items in the collection
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IObjectCollection
	 * IObjectCollection and its specializations handles a collection of  IObjects. There
	 * are methods for adding, removing and iterating through  the objects.
	 */
	typedef CountedPointer<IObjectCollection> spObjectCollection;

	class IGeometryData;

	/**
	 * IGeometryDataCollection holds a number of IGeometryData  objects. The objects can
	 * be looked up by their names (if they have  been named through IObject::SetName()
	 * ).
	 */
	class IGeometryDataCollection : public IObjectCollection
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryDataCollection is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGeometryDataCollection",type)==0 )
				return true;
			return IObjectCollection::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryDataCollection pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryDataCollection pointer
		 * @return a pointer to the IGeometryDataCollection object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGeometryDataCollection *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGeometryDataCollection") )
				return static_cast<IGeometryDataCollection*>(ptr);
			return NULL;
			}
		/**
		 * Adds an object to the collection. The handle refers to the object until the object
		 * is removed from the collection again. @param obj is the object that is to be added
		 * to the collection @return the handle of the added object in the collection
		 */
		virtual	rhandle AddObject( IObject *obj ) = 0;

		/**
		 * Returns true if the item is in the collection @param objhandle is the handle of an
		 * object to be checked for @return true if the collection contains the object, false
		 * otherwise
		 */
		virtual	bool IsItemInCollection( rhandle objhandle ) = 0;

		/**
		 * Finds a named object in the collection. The first object  with this name is returned.
		 * The search is case-sensitive. @param name is the name of an object in the collection
		 * @return the object with the relevant name, or NULL if none is found
		 */
		virtual	CountedPointer<IObject> FindObject( const char * name ) = 0;

		/**
		 * Returns the object of the next item. @param phandle the handle to the current IGeometryData
		 * object @return the next IGeometryData object<br />Description of IGeometryData: IGeometryData
		 * represents a geometric structure  consisting of point data (Vertices) and topological
		 * data (Triangles). IGeometryData may represent a whole geometric object, but can also
		 * be used by streaming data filters, and in this way, only represents a part of the
		 * object. <br><br> Different fields in the Vertices and Triangles fields data  objects
		 * will contain point data and topological data. The standard  naming convention used
		 * in the filters/renderers are as follows: (Case sensitive naming, other fields may
		 * also be present) <br><br> 'Coords' <br> Positional coordinates of a vertex, expressed
		 * with a 3-component real field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br>
		 * Texture coordinates of a vertex, expressed with a 2 components real field. By convention,
		 * the existing fields must be sequential, and  must start with 'TexCoord0'. <br><br>
		 * 'Normals'	 <br> Normal vector for the vertex,	expressed  with a 3-component real
		 * field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	 <br> The id of the primitive's
		 * current vertex.  This field is present even if the  vertex data	is directly specified
		 * in the  primitive's data, to specify topology. The field is of type rid. <br><br>
		 * 'MaterialIds' <br> The material of the primitive.  The field is of type rid. <br><br>
		 * The 'Coords' and 'VertexIds' fields always exist in the object, but the other fields
		 * are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetNextItemAsGeometryData( rhandle *phandle ) = 0;

		/**
		 * Returns the handle of the i:th item @param index is the index of an object in the
		 * collection @return the handle of the object with the relevant index
		 */
		virtual	rhandle GetItem( unsigned int index ) = 0;

		/**
		 * Get the number of items in the collection. @return the number of items in the collection
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Adds a IGeometryData object to the collection. The handle refers  to the object until
		 * it is removed from the collection again. If the geometry and the pre-existing collection
		 * shares a field name they have to be of the same type and tuple size. @param obj is
		 * the IGeometryData to add @return a handle to the added geometry in the collection
		 */
		virtual	rhandle AddGeometryData( IGeometryData *obj ) = 0;

		/**
		 * Finds a named object.  @param name is the name of the geometry object @return the
		 * requested IGeometryData object<br />Description of IGeometryData: IGeometryData represents
		 * a geometric structure  consisting of point data (Vertices) and topological data (Triangles).
		 * IGeometryData may represent a whole geometric object, but can also be used by streaming
		 * data filters, and in this way, only represents a part of the object. <br><br> Different
		 * fields in the Vertices and Triangles fields data  objects will contain point data
		 * and topological data. The standard  naming convention used in the filters/renderers
		 * are as follows: (Case sensitive naming, other fields may also be present) <br><br>
		 * 'Coords' <br> Positional coordinates of a vertex, expressed with a 3-component real
		 * field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br> Texture coordinates of a
		 * vertex, expressed with a 2 components real field. By convention, the existing fields
		 * must be sequential, and  must start with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal
		 * vector for the vertex,	expressed  with a 3-component real field, a  normalized (XYZ)
		 * vector. <br><br> 'VertexIds'	 <br> The id of the primitive's current vertex.  This
		 * field is present even if the  vertex data	is directly specified in the  primitive's
		 * data, to specify topology. The field is of type rid. <br><br> 'MaterialIds' <br>
		 * The material of the primitive.  The field is of type rid. <br><br> The 'Coords' and
		 * 'VertexIds' fields always exist in the object, but the other fields are optional.
		 * Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> FindGeometryData( const char * name ) = 0;

		/**
		 * Removes an item from the collection. The handle returned is the first item after
		 * this item that is in the collection. If the return is NULL, the item was the last
		 * item in the collection. Warning! The handle is invalid after the removal of the object.
		 * @param objhandle is the handle of the object that is to be removed @return the handle
		 * to the item following the removed one, or NULL if collection is now empty
		 */
		virtual	rhandle RemoveItem( rhandle objhandle ) = 0;

		/**
		 * Returns the object of the i:th item @param index is the index of an object in the
		 * collection @return the object with the relevant index
		 */
		virtual	CountedPointer<IObject> GetItemAsObject( unsigned int index ) = 0;

		/**
		 * Returns true if the object is in the collection @param pobj the geometry to look
		 * for @return true if the geometry is in the collection, otherwise false
		 */
		virtual	bool IsGeometryDataInCollection( IGeometryData *pobj ) = 0;

		/**
		 * Adds an object to the collection, as AddObject, but sorts the object into the collection
		 * based on its name. @param obj is the object that is to be added to the collection
		 * @param ascending determines the sorting order @return the handle of the added object
		 * in the collection
		 */
		virtual	rhandle AddObjectSorted( IObject *obj , bool ascending ) = 0;

		/**
		 * Gets the object the handle is referring to. @param objhandle the handle of the geometry
		 * data object to fetch @return the requested IGeometryData object<br />Description
		 * of IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetGeometryData( rhandle objhandle ) = 0;

		/**
		 * Removes all items from the collection.
		 */
		virtual	void RemoveAllItems(  ) = 0;

		/**
		 * Returns true if the object is in the collection @param pobj is the object to be checked
		 * for @return true if the collection contains pobj, false otherwise
		 */
		virtual	bool IsObjectInCollection( IObject *pobj ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurrence of the object is
		 * removed.  @param pobj the IGeometryData to remove from the collection
		 */
		virtual	void RemoveGeometryData( IGeometryData *pobj ) = 0;

		/**
		 * Returns the start of the collection. The handle returned refers to the first object
		 * in the collection. If the handle is  NULL, then the collection is empty. @return
		 * the first item in collection, or NULL if collection is empty
		 */
		virtual	rhandle GetFirstItem(  ) = 0;

		/**
		 * Returns the handle to the next item in the collection. Use  GetFirstItem and this
		 * method to step through the collection. If the return is NULL, the end of the collection
		 * has been reached. @param objhandle is the handle of an object i @return the handle
		 * of the object i+1
		 */
		virtual	rhandle GetNextItem( rhandle objhandle ) = 0;

		/**
		 * Gets the object the handle is referring to. @param objhandle is the handle of an
		 * object in the collection @return the object associated with the handle
		 */
		virtual	CountedPointer<IObject> GetItemsObject( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurance of the object is
		 * removed from the collection.  @param pobj is the object that is to be removed
		 */
		virtual	void RemoveObject( IObject *pobj ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGeometryDataCollection
	 * IGeometryDataCollection holds a number of IGeometryData  objects. The objects can
	 * be looked up by their names (if they have  been named through IObject::SetName()
	 * ).
	 */
	typedef CountedPointer<IGeometryDataCollection> spGeometryDataCollection;

	class IGraphicsImporter;
	class IMaterialTable;
	class IGeometryDataCollection;
	class IGeometryData;

	/**
	 * base class for graphics import classes
	 */
	class IGraphicsImporter : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGraphicsImporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGraphicsImporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGraphicsImporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGraphicsImporter pointer
		 * @return a pointer to the IGraphicsImporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGraphicsImporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGraphicsImporter") )
				return static_cast<IGraphicsImporter*>(ptr);
			return NULL;
			}
		/**
		 * Close any open file or stream, release any allocated data .
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the main import file path. This must always be set. Some importers, such as IWavefrontImporter,
		 * also have secondary files that may be set. For info regarding these secondary files,
		 * please see the documentation for the specific importer. @return the current ImportFilePath
		 * string
		 */
		virtual	rstring GetImportFilePath(  ) = 0;

		/**
		 * Set the main import file path. This must always be set. Some importers, such as IWavefrontImporter,
		 * also have secondary files that may be set. For info regarding these secondary files,
		 * please see the documentation for the specific importer. @param value the desired
		 * ImportFilePath string
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * Get the geometry data collection object that is filled with  geometries from the
		 * importer. The importer will reference the table until Clear() is called. @return
		 * the requested IGeometryDataCollection<br />Description of IGeometryDataCollection:
		 * IGeometryDataCollection holds a number of IGeometryData  objects. The objects can
		 * be looked up by their names (if they have  been named through IObject::SetName()
		 * ).
		 */
		virtual	CountedPointer<IGeometryDataCollection> GetGeometries(  ) = 0;

		/**
		 * Get the first geometry data in the Geometries collection. This is useful  if Geometries
		 * is known to only contain one object. @return the first IGeometryData object<br />Description
		 * of IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetFirstGeometry(  ) = 0;

		/**
		 * Runs the import. Note that all parameters must be setup before importing. @return
		 * true if the import was successful, false otherwise
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Get the material table that is used by the importer. The importer will reference
		 * the table until Clear() is called. @return the requested IMaterialTable<br />Description
		 * of IMaterialTable: IMaterialTable keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetMaterials(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGraphicsImporter
	 * base class for graphics import classes
	 */
	typedef CountedPointer<IGraphicsImporter> spGraphicsImporter;

	class IGraphicsImporter;
	class IMaterialTable;
	class IGeometryDataCollection;
	class IGeometryData;

	/**
	 * base class for graphics import classes
	 */
	class IWavefrontImporter : public IGraphicsImporter
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IWavefrontImporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IWavefrontImporter",type)==0 )
				return true;
			return IGraphicsImporter::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IWavefrontImporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IWavefrontImporter pointer
		 * @return a pointer to the IWavefrontImporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IWavefrontImporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IWavefrontImporter") )
				return static_cast<IWavefrontImporter*>(ptr);
			return NULL;
			}
		/**
		 * Close any open file or stream, release any allocated data 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the material file path. If the path is not set, it is assumed to equal the  path
		 * of the main obj file, but with the extension '.mtl' instead of '.obj'. If no material
		 * file is found or specified, materials that are found in the Wavefront file is added
		 * using default material settings to the material table. @param value is the path to
		 * the material file
		 */
		virtual	void SetMaterialFilePath( const char * value ) = 0;

		/**
		 * Get the ExtractGroups boolean. If true, each group within the wavefront file is extracted
		 * into a separate geometry data object, that is named as the group. If false, the whole
		 * file  is imported into one geometry data, and groups are ignored. @return the current
		 * value of the ExtractGroups bool 
		 */
		virtual	bool GetExtractGroups(  ) = 0;

		/**
		 * Get the geometry data collection object that is filled with  geometries from the
		 * importer. The importer will reference the table until Clear() is called. @return
		 * the requested IGeometryDataCollection<br />Description of IGeometryDataCollection:
		 * IGeometryDataCollection holds a number of IGeometryData  objects. The objects can
		 * be looked up by their names (if they have  been named through IObject::SetName()
		 * ).
		 */
		virtual	CountedPointer<IGeometryDataCollection> GetGeometries(  ) = 0;

		/**
		 * Get the first geometry data in the Geometries collection. This is useful  if Geometries
		 * is known to only contain one object. @return the first IGeometryData object<br />Description
		 * of IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetFirstGeometry(  ) = 0;

		/**
		 * Set the ExtractGroups boolean. If true, each group within the wavefront file is extracted
		 * into a separate geometry data object, that is named as the group. If false, the whole
		 * file  is imported into one geometry data, and groups are ignored. @param value is
		 * the bool the parameter is to be set to
		 */
		virtual	void SetExtractGroups( bool value ) = 0;

		/**
		 * Get the main import file path. This must always be set. Some importers, such as IWavefrontImporter,
		 * also have secondary files that may be set. For info regarding these secondary files,
		 * please see the documentation for the specific importer. @return the current ImportFilePath
		 * string
		 */
		virtual	rstring GetImportFilePath(  ) = 0;

		/**
		 * Get the material table that is used by the importer. The importer will reference
		 * the table until Clear() is called. @return the requested IMaterialTable<br />Description
		 * of IMaterialTable: IMaterialTable keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetMaterials(  ) = 0;

		/**
		 * Set the AlphaAsOpacity boolean. If set, then if the material has a map_d texture
		 * definition, and that texture is RGBA, the material will use the alpha channel rather
		 * than the color (R) to specify the opacity. @param value is the bool the parameter
		 * is to be set to
		 */
		virtual	void SetAlphaAsOpacity( bool value ) = 0;

		/**
		 * Runs the import. Note that all parameters must be setup before importing. @return
		 * true if the import was successful, false otherwise
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Get the AlphaAsOpacity boolean. If set, then if the material has a map_d texture
		 * definition, and that texture is RGBA, the material will use the alpha channel rather
		 * than the color (R) to specify the opacity. @return the current value of the AlphaAsOpacity
		 * bool 
		 */
		virtual	bool GetAlphaAsOpacity(  ) = 0;

		/**
		 * Set the main import file path. This must always be set. Some importers, such as IWavefrontImporter,
		 * also have secondary files that may be set. For info regarding these secondary files,
		 * please see the documentation for the specific importer. @param value the desired
		 * ImportFilePath string
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * Get the material file path. If the path is not set, it is assumed to equal the  path
		 * of the main obj file, but with the extension '.mtl' instead of '.obj'. If no material
		 * file is found or specified, materials that are found in the Wavefront file is added
		 * using default material settings to the material table. @return the path to the material
		 * file
		 */
		virtual	rstring GetMaterialFilePath(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IWavefrontImporter
	 * base class for graphics import classes
	 */
	typedef CountedPointer<IWavefrontImporter> spWavefrontImporter;

	class IMaterialTable;
	class IGeometryDataCollection;
	class IGeometryData;

	/**
	 * base class for graphics export classes
	 */
	class IGraphicsExporter : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGraphicsExporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGraphicsExporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGraphicsExporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGraphicsExporter pointer
		 * @return a pointer to the IGraphicsExporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGraphicsExporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGraphicsExporter") )
				return static_cast<IGraphicsExporter*>(ptr);
			return NULL;
			}
		/**
		 * Set the main export file path. This is the main file being written to, and must always
		 * be set.  @param value the desired file path
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

		/**
		 * Get the main export file path. This is the main file being written to, and must always
		 * be set.  @return the current file path
		 */
		virtual	rstring GetExportFilePath(  ) = 0;

		/**
		 * Set the material table that is to be written.  @param value the material table to
		 * write
		 */
		virtual	void SetMaterials( IMaterialTable *value ) = 0;

		/**
		 * Set the geometry data collection object that is to be written. @param value the geometry
		 * data collection to write
		 */
		virtual	void SetGeometries( IGeometryDataCollection *value ) = 0;

		/**
		 * Tells the exporter that only one geometry is to be exported. The exporter will allocate
		 * an IGeometryDataCollection object, and add the geometry into it.  @param geom The
		 * one geometry that will be exported.
		 */
		virtual	void SetSingleGeometry( IGeometryData *geom ) = 0;

		/**
		 * Runs the export. Note that all required parameters must be setup before exporting.
		 * @return true if the export was successful, false otherwise
		 */
		virtual	bool RunExport(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGraphicsExporter
	 * base class for graphics export classes
	 */
	typedef CountedPointer<IGraphicsExporter> spGraphicsExporter;

	class IMaterialTable;
	class IGeometryDataCollection;
	class IGeometryData;

	/**
	 * Wavefront .obj geometry exporter
	 */
	class IWavefrontExporter : public IGraphicsExporter
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IWavefrontExporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IWavefrontExporter",type)==0 )
				return true;
			return IGraphicsExporter::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IWavefrontExporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IWavefrontExporter pointer
		 * @return a pointer to the IWavefrontExporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IWavefrontExporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IWavefrontExporter") )
				return static_cast<IWavefrontExporter*>(ptr);
			return NULL;
			}
		/**
		 * Set the geometry data collection object that is to be written. @param value the geometry
		 * data collection to write
		 */
		virtual	void SetGeometries( IGeometryDataCollection *value ) = 0;

		/**
		 * Runs the export. Note that all required parameters must be setup before exporting.
		 * @return true if the export was successful, false otherwise
		 */
		virtual	bool RunExport(  ) = 0;

		/**
		 * Set the material file path. If the path is not set, it is assumed to equal the  path
		 * of the main obj file, but with the extension '.mtl' instead of '.obj'.  @param value
		 * is the path to the material file
		 */
		virtual	void SetMaterialFilePath( const char * value ) = 0;

		/**
		 * Get the main export file path. This is the main file being written to, and must always
		 * be set.  @return the current file path
		 */
		virtual	rstring GetExportFilePath(  ) = 0;

		/**
		 * Get the material file path. If the path is not set, it is assumed to equal the  path
		 * of the main obj file, but with the extension '.mtl' instead of '.obj'.  @return the
		 * path to the material file
		 */
		virtual	rstring GetMaterialFilePath(  ) = 0;

		/**
		 * Tells the exporter that only one geometry is to be exported. The exporter will allocate
		 * a GeometryDataCollection object, and add the geometry into it.  <br> Specific for
		 * WavefrontExporter: If the geometry contains GroupIds, these are used and the wavefront
		 * file will contain g statements with names in the  form: group_id_XX where XX is the
		 * id in the GroupIds array  @param geom The one geometry that will be exported.
		 */
		virtual	void SetSingleGeometry( IGeometryData *geom ) = 0;

		/**
		 * Set the main export file path. This is the main file being written to, and must always
		 * be set.  @param value the desired file path
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

		/**
		 * Set the material table that is to be written.  @param value the material table to
		 * write
		 */
		virtual	void SetMaterials( IMaterialTable *value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IWavefrontExporter
	 * Wavefront .obj geometry exporter
	 */
	typedef CountedPointer<IWavefrontExporter> spWavefrontExporter;

	class IGraphicsImporter;
	class IMaterialTable;
	class IGeometryDataCollection;
	class IGeometryData;

	/**
	 * IBinaryImporter loads the geometry data from a binary file, that is specific for
	 * Simplygon. Please note that the binary file is only intended for temporary storage,
	 * and that no compatibility between versions of Simplygon is guaranteed.
	 */
	class IBinaryImporter : public IGraphicsImporter
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IBinaryImporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IBinaryImporter",type)==0 )
				return true;
			return IGraphicsImporter::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBinaryImporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBinaryImporter pointer
		 * @return a pointer to the IBinaryImporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IBinaryImporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IBinaryImporter") )
				return static_cast<IBinaryImporter*>(ptr);
			return NULL;
			}
		/**
		 * Runs the import. Note that all parameters must be setup before importing. @return
		 * true if the import was successful, false otherwise
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Get the main import file path. This must always be set. Some importers, such as IWavefrontImporter,
		 * also have secondary files that may be set. For info regarding these secondary files,
		 * please see the documentation for the specific importer. @return the current ImportFilePath
		 * string
		 */
		virtual	rstring GetImportFilePath(  ) = 0;

		/**
		 * Get the material table that is used by the importer. The importer will reference
		 * the table until Clear() is called. @return the requested IMaterialTable<br />Description
		 * of IMaterialTable: IMaterialTable keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetMaterials(  ) = 0;

		/**
		 * Set the main import file path. This must always be set. Some importers, such as IWavefrontImporter,
		 * also have secondary files that may be set. For info regarding these secondary files,
		 * please see the documentation for the specific importer. @param value the desired
		 * ImportFilePath string
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * Get the geometry data collection object that is filled with  geometries from the
		 * importer. The importer will reference the table until Clear() is called. @return
		 * the requested IGeometryDataCollection<br />Description of IGeometryDataCollection:
		 * IGeometryDataCollection holds a number of IGeometryData  objects. The objects can
		 * be looked up by their names (if they have  been named through IObject::SetName()
		 * ).
		 */
		virtual	CountedPointer<IGeometryDataCollection> GetGeometries(  ) = 0;

		/**
		 * Get the first geometry data in the Geometries collection. This is useful  if Geometries
		 * is known to only contain one object. @return the first IGeometryData object<br />Description
		 * of IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetFirstGeometry(  ) = 0;

		/**
		 * Close any open file or stream, release any allocated data.
		 */
		virtual	void Clear(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IBinaryImporter
	 * IBinaryImporter loads the geometry data from a binary file, that is specific for
	 * Simplygon. Please note that the binary file is only intended for temporary storage,
	 * and that no compatibility between versions of Simplygon is guaranteed.
	 */
	typedef CountedPointer<IBinaryImporter> spBinaryImporter;

	class IMaterialTable;
	class IGeometryDataCollection;
	class IGeometryData;

	/**
	 * IBinaryExporter stores the geometry data into a binary file, that is specific for
	 * Simplygon. Please note that the binary file is only intended for temporary storage,
	 * and that no compatibility between versions of Simplygon is guaranteed.
	 */
	class IBinaryExporter : public IGraphicsExporter
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IBinaryExporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IBinaryExporter",type)==0 )
				return true;
			return IGraphicsExporter::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBinaryExporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBinaryExporter pointer
		 * @return a pointer to the IBinaryExporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IBinaryExporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IBinaryExporter") )
				return static_cast<IBinaryExporter*>(ptr);
			return NULL;
			}
		/**
		 * Get the main export file path. This is the main file being written to, and must always
		 * be set.  @return the current file path
		 */
		virtual	rstring GetExportFilePath(  ) = 0;

		/**
		 * Runs the export. Note that all required parameters must be setup before exporting.
		 * @return true if the export was successful, false otherwise
		 */
		virtual	bool RunExport(  ) = 0;

		/**
		 * Set the material table that is to be written.  @param value the material table to
		 * write
		 */
		virtual	void SetMaterials( IMaterialTable *value ) = 0;

		/**
		 * Set the geometry data collection object that is to be written. @param value the geometry
		 * data collection to write
		 */
		virtual	void SetGeometries( IGeometryDataCollection *value ) = 0;

		/**
		 * Tells the exporter that only one geometry is to be exported. The exporter will allocate
		 * an IGeometryDataCollection object, and add the geometry into it.  @param geom The
		 * one geometry that will be exported.
		 */
		virtual	void SetSingleGeometry( IGeometryData *geom ) = 0;

		/**
		 * Set the main export file path. This is the main file being written to, and must always
		 * be set.  @param value the desired file path
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IBinaryExporter
	 * IBinaryExporter stores the geometry data into a binary file, that is specific for
	 * Simplygon. Please note that the binary file is only intended for temporary storage,
	 * and that no compatibility between versions of Simplygon is guaranteed.
	 */
	typedef CountedPointer<IBinaryExporter> spBinaryExporter;

	class IGeometryData;

	/**
	 * Checks the geometry for consistent indices, number of triangles etc.
	 */
	class IGeometryValidator : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryValidator is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGeometryValidator",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryValidator pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryValidator pointer
		 * @return a pointer to the IGeometryValidator object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGeometryValidator *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGeometryValidator") )
				return static_cast<IGeometryValidator*>(ptr);
			return NULL;
			}
		/**
		 * Checks if the data stored in the Geometry is stored correctly. @param geom the geometry
		 * data to validate @return True if the geometry is stored correct, or false if something
		 * is wrong.
		 */
		virtual	bool ValidateGeometry( IGeometryData *geom ) = 0;

		/**
		 * Returns a string describing the error that was found for the last check that was
		 * performed. @return the last string describing the error 
		 */
		virtual	rstring GetErrorString(  ) = 0;

		/**
		 * Set the CheckDegenerateFaceIndices flag. If set, faces that have the same index more
		 * than once will not be allowed. @param v the flag value
		 */
		virtual	void SetCheckDegenerateFaceIndices( bool value ) = 0;

		/**
		 * Get the AllowedBoneCount count. This is the number of bones used in the scene. Only
		 * indices within this range are allowed. @return the flag value
		 */
		virtual	void SetAllowedBoneCount( unsigned int value ) = 0;

		/**
		 * Returns the error-code for the last check that was performed. 0 means no error was
		 * found, and values less than 0 means an error was found. @return the last error-code
		 */
		virtual	rid GetErrorValue(  ) = 0;

		/**
		 * Get the CheckDegenerateFaceIndices flag. If set, faces that have the same index more
		 * than once will not be allowed. @return the flag value
		 */
		virtual	bool GetCheckDegenerateFaceIndices(  ) = 0;

		/**
		 * Set the CheckZeroAreaFaces flag. If set, faces that have zero area will not be allowed.
		 * @param v the flag value
		 */
		virtual	void SetCheckZeroAreaFaces( bool value ) = 0;

		/**
		 * Get the CheckZeroAreaFaces flag. If set, faces that have zero area will not be allowed.
		 * @return the flag value
		 */
		virtual	bool GetCheckZeroAreaFaces(  ) = 0;

		/**
		 * Get the AllowedGroupCount count. This is the number of groups/objects used in the
		 * scene. Only indices within this range are allowed. @return the flag value
		 */
		virtual	void SetAllowedGroupCount( unsigned int value ) = 0;

		/**
		 * Get the AllowedMaterialCount count. This is the number of materials used in the scene.
		 * Only indices within this range are allowed. @return the flag value
		 */
		virtual	void SetAllowedMaterialCount( unsigned int value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGeometryValidator
	 * Checks the geometry for consistent indices, number of triangles etc.
	 */
	typedef CountedPointer<IGeometryValidator> spGeometryValidator;

	class ITextureTable;
	class IMaterialTable;
	class IMaterial;
	class IMappingImage;
	class IImageData;

	/**
	 * IMaterialCaster is the base interface for material  casting interfaces. The interface
	 * exports methods for defining input geometries & mapping image, materials, output
	 * image paths & formats
	 */
	class IMaterialCaster : public IProcessingObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMaterialCaster is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMaterialCaster",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMaterialCaster pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMaterialCaster pointer
		 * @return a pointer to the IMaterialCaster object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMaterialCaster *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMaterialCaster") )
				return static_cast<IMaterialCaster*>(ptr);
			return NULL;
			}
		/**
		 * Set the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @param value is the value to which DestMaterialId will be
		 * set
		 */
		virtual	void SetDestMaterialId( rid value ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Get the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @return the current MappingImage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Get the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @return the current OutputFilePath
		 */
		virtual	rstring GetOutputFilePath(  ) = 0;

		/**
		 * Get the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @return the current value of DestMaterialId
		 */
		virtual	rid GetDestMaterialId(  ) = 0;

		/**
		 * Get the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @return the current value of OutputBitDepth
		 */
		virtual	unsigned int GetOutputChannelBitDepth(  ) = 0;

		/**
		 * Get the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @return the current SourceMaterials material table<br
		 * />Description of IMaterialTable: IMaterialTable keeps information on materials used
		 * while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetSourceMaterials(  ) = 0;

		/**
		 * Get the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @return the current value of OutputChannels
		 */
		virtual	unsigned int GetOutputChannels(  ) = 0;

		/**
		 * Set the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @param value is the string to which OutputFilePath will be set
		 */
		virtual	void SetOutputFilePath( const char * value ) = 0;

		/**
		 * Set the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @param value is the value to which OutputChannels
		 * will be set
		 */
		virtual	void SetOutputChannels( unsigned int value ) = 0;

		/**
		 * Set the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @param value the destination
		 * material to use
		 */
		virtual	void SetDestMaterial( IMaterial *value ) = 0;

		/**
		 * Get the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @return the current OutputImage<br />Description
		 * of IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetOutputImage(  ) = 0;

		/**
		 * Set the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @param value is the image data to which OutputImage
		 * will be set
		 */
		virtual	void SetOutputImage( IImageData *value ) = 0;

		/**
		 * Get the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @return the current destination
		 * material<br />Description of IMaterial: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetDestMaterial(  ) = 0;

		/**
		 * Set the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @param value is the texture table to which SourceTextures
		 * will be set
		 */
		virtual	void SetSourceTextures( ITextureTable *value ) = 0;

		/**
		 * Set the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @param value is the mapping image to which
		 * MappingImage will be set
		 */
		virtual	void SetMappingImage( IMappingImage *value ) = 0;

		/**
		 * Set the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @param value is the value to which Dilation will be set
		 */
		virtual	void SetDilation( unsigned int value ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void CastMaterials(  ) = 0;

		/**
		 * Get the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @return the current value of Dilation
		 */
		virtual	unsigned int GetDilation(  ) = 0;

		/**
		 * Set the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @param value is the value to which OutputBitDepth
		 * will be set
		 */
		virtual	void SetOutputChannelBitDepth( unsigned int value ) = 0;

		/**
		 * Clears the processing, and resets all internal states. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @return the current SourceTextures material table<br />Description
		 * of ITextureTable: ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetSourceTextures(  ) = 0;

		/**
		 * Set the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @param value is the material table to which SourceMaterials
		 * will be set
		 */
		virtual	void SetSourceMaterials( IMaterialTable *value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMaterialCaster
	 * IMaterialCaster is the base interface for material  casting interfaces. The interface
	 * exports methods for defining input geometries & mapping image, materials, output
	 * image paths & formats
	 */
	typedef CountedPointer<IMaterialCaster> spMaterialCaster;

	class ITextureTable;
	class IMaterialTable;
	class IMaterial;
	class IMappingImage;
	class IImageData;

	/**
	 * IColorCaster is the interface used to cast basic color values. Currently supported
	 * material color value types are Ambient,  Diffuse and Specular + Shininess.
	 */
	class IColorCaster : public IMaterialCaster
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IColorCaster is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IColorCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IColorCaster pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IColorCaster pointer
		 * @return a pointer to the IColorCaster object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IColorCaster *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IColorCaster") )
				return static_cast<IColorCaster*>(ptr);
			return NULL;
			}
		/**
		 * Get the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @return the current SourceTextures material table<br />Description
		 * of ITextureTable: ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetSourceTextures(  ) = 0;

		/**
		 * Set the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @param value is the value to which Dilation will be set
		 */
		virtual	void SetDilation( unsigned int value ) = 0;

		/**
		 * Set the sRGB flag. If set, textures are assumed to  be in sRGB format. Default true.
		 * @param value the desired sRGB flag
		 */
		virtual	void SetsRGB( bool value ) = 0;

		/**
		 * Set which material channel to cast. The material channels are defined as SG_MATERIAL_CHANNEL_[
		 * CHANNEL ]. For example, the diffuse channel is SG_MATERIAL_CHANNEL_DIFFUSE. @param
		 * value the desired material channel
		 */
		virtual	void SetColorType( const char * value ) = 0;

		/**
		 * Set the fill mode. The fill mode determines what to do with the pixels that remain
		 * unfilled after both the casting and dilation has been performed.<br> Options are:
		 * <br> SG_ATLASFILLMODE_NONE = Do not fill remaining pixels <br> SG_ATLASFILLMODE_INTERPOLATE
		 * = linearly interpolate the closest samples <br> SG_ATLASFILLMODE_NEARESTNEIGHBOR
		 * = use the closest available pixel value without interpolation <br> @param value is
		 * the mode to which the fill mode will be set
		 */
		virtual	void SetFillMode( int value ) = 0;

		/**
		 * Set the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @param value is the value to which OutputChannels
		 * will be set
		 */
		virtual	void SetOutputChannels( unsigned int value ) = 0;

		/**
		 * Get which material channel to cast. The material channels are defined as SG_MATERIAL_CHANNEL_[
		 * CHANNEL ]. For example, the diffuse channel is SG_MATERIAL_CHANNEL_DIFFUSE. @return
		 * the current material channel.
		 */
		virtual	rstring GetColorType(  ) = 0;

		/**
		 * Get the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @return the current MappingImage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * \deprecated use the IMaterial SetVertexColorChannel instead to set the use of vertex
		 * colors 
		 */
		virtual	void SetBakeVertexColors( bool value ) = 0;

		/**
		 * Set the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @param value is the string to which OutputFilePath will be set
		 */
		virtual	void SetOutputFilePath( const char * value ) = 0;

		/**
		 * Get the sRGB flag. If set, textures are assumed to  be in sRGB format. Default true.
		 * @return the current sRGB flag
		 */
		virtual	bool GetsRGB(  ) = 0;

		/**
		 * Set the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @param value is the texture table to which SourceTextures
		 * will be set
		 */
		virtual	void SetSourceTextures( ITextureTable *value ) = 0;

		/**
		 * Get the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @return the current SourceMaterials material table<br
		 * />Description of IMaterialTable: IMaterialTable keeps information on materials used
		 * while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetSourceMaterials(  ) = 0;

		/**
		 * Set the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @param value is the image data to which OutputImage
		 * will be set
		 */
		virtual	void SetOutputImage( IImageData *value ) = 0;

		/**
		 * Set the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @param value is the material table to which SourceMaterials
		 * will be set
		 */
		virtual	void SetSourceMaterials( IMaterialTable *value ) = 0;

		/**
		 * Get the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @return the current value of Dilation
		 */
		virtual	unsigned int GetDilation(  ) = 0;

		/**
		 * Set the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @param value is the mapping image to which
		 * MappingImage will be set
		 */
		virtual	void SetMappingImage( IMappingImage *value ) = 0;

		/**
		 * Get the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @return the current destination
		 * material<br />Description of IMaterial: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetDestMaterial(  ) = 0;

		/**
		 * Get the fill mode The fill mode determines what to do with the pixels that remain
		 * unfilled after both the casting and dilation has been performed.<br> Options are:
		 * <br> SG_ATLASFILLMODE_NONE = Do not fill remaining pixels <br> SG_ATLASFILLMODE_INTERPOLATE
		 * = linearly interpolate the closest samples <br> SG_ATLASFILLMODE_NEARESTNEIGHBOR
		 * = use the closest available pixel value without interpolation <br> @return the current
		 * fill mode
		 */
		virtual	int GetFillMode(  ) = 0;

		/**
		 * Get the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @return the current value of DestMaterialId
		 */
		virtual	rid GetDestMaterialId(  ) = 0;

		/**
		 * Get the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @return the current OutputFilePath
		 */
		virtual	rstring GetOutputFilePath(  ) = 0;

		/**
		 * Get the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @return the current OutputImage<br />Description
		 * of IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetOutputImage(  ) = 0;

		/**
		 * Clears the processing, and resets all internal states. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the BakeOpacityInAlpha flag. If set, the total opacity of the baked layers replaces
		 * the alpha value in the output texture. @param value the new BakeOpacityInAlpha value
		 */
		virtual	void SetBakeOpacityInAlpha( bool value ) = 0;

		/**
		 * Get the BakeOpacityInAlpha flag. If set, the total opacity of the baked layers replaces
		 * the alpha value in the output texture. @return the current BakeOpacityInAlpha value
		 */
		virtual	bool GetBakeOpacityInAlpha(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void CastMaterials(  ) = 0;

		/**
		 * \deprecated use the IMaterial SetVertexColorChannel instead to set the use of vertex
		 * colors 
		 */
		virtual	bool GetBakeVertexColors(  ) = 0;

		/**
		 * Get the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @return the current value of OutputChannels
		 */
		virtual	unsigned int GetOutputChannels(  ) = 0;

		/**
		 * Set the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @param value the destination
		 * material to use
		 */
		virtual	void SetDestMaterial( IMaterial *value ) = 0;

		/**
		 * Set the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @param value is the value to which OutputBitDepth
		 * will be set
		 */
		virtual	void SetOutputChannelBitDepth( unsigned int value ) = 0;

		/**
		 * Set the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @param value is the value to which DestMaterialId will be
		 * set
		 */
		virtual	void SetDestMaterialId( rid value ) = 0;

		/**
		 * Get the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @return the current value of OutputBitDepth
		 */
		virtual	unsigned int GetOutputChannelBitDepth(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IColorCaster
	 * IColorCaster is the interface used to cast basic color values. Currently supported
	 * material color value types are Ambient,  Diffuse and Specular + Shininess.
	 */
	typedef CountedPointer<IColorCaster> spColorCaster;

	class ITextureTable;
	class IMaterialTable;
	class IMaterial;
	class IMappingImage;
	class IImageData;

	/**
	 * IOpacityCaster is the interface used to cast opacity values. To be used when opacity
	 * is needed as a separate texture.
	 */
	class IOpacityCaster : public IMaterialCaster
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IOpacityCaster is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IOpacityCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IOpacityCaster pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IOpacityCaster pointer
		 * @return a pointer to the IOpacityCaster object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IOpacityCaster *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IOpacityCaster") )
				return static_cast<IOpacityCaster*>(ptr);
			return NULL;
			}
		/**
		 * Set the color type that is cast. @param value the desired color type
		 */
		virtual	void SetColorType( const char * value ) = 0;

		/**
		 * Set the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @param value is the value to which OutputChannels
		 * will be set
		 */
		virtual	void SetOutputChannels( unsigned int value ) = 0;

		/**
		 * Set the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @param value is the texture table to which SourceTextures
		 * will be set
		 */
		virtual	void SetSourceTextures( ITextureTable *value ) = 0;

		/**
		 * Set the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @param value is the string to which OutputFilePath will be set
		 */
		virtual	void SetOutputFilePath( const char * value ) = 0;

		/**
		 * Set the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @param value is the value to which OutputBitDepth
		 * will be set
		 */
		virtual	void SetOutputChannelBitDepth( unsigned int value ) = 0;

		/**
		 * Set the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @param value is the value to which Dilation will be set
		 */
		virtual	void SetDilation( unsigned int value ) = 0;

		/**
		 * Get the fill mode @return the current fill mode
		 */
		virtual	int GetFillMode(  ) = 0;

		/**
		 * Set the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @param value is the image data to which OutputImage
		 * will be set
		 */
		virtual	void SetOutputImage( IImageData *value ) = 0;

		/**
		 * Set the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @param value is the material table to which SourceMaterials
		 * will be set
		 */
		virtual	void SetSourceMaterials( IMaterialTable *value ) = 0;

		/**
		 * Get the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @return the current SourceMaterials material table<br
		 * />Description of IMaterialTable: IMaterialTable keeps information on materials used
		 * while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetSourceMaterials(  ) = 0;

		/**
		 * Get the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @return the current value of DestMaterialId
		 */
		virtual	rid GetDestMaterialId(  ) = 0;

		/**
		 * Get the BakeOpacityInAlpha flag. If set, the total opacity of the baked layers replaces
		 * the alpha value in the output texture. @return the current BakeOpacityInAlpha value
		 */
		virtual	bool GetBakeOpacityInAlpha(  ) = 0;

		/**
		 * \deprecated use the IMaterial SetVertexColorChannel instead to set the use of vertex
		 * colors 
		 */
		virtual	bool GetBakeVertexColors(  ) = 0;

		/**
		 * Get the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @return the current OutputImage<br />Description
		 * of IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetOutputImage(  ) = 0;

		/**
		 * \deprecated use the IMaterial SetVertexColorChannel instead to set the use of vertex
		 * colors 
		 */
		virtual	void SetBakeVertexColors( bool value ) = 0;

		/**
		 * Set the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @param value the destination
		 * material to use
		 */
		virtual	void SetDestMaterial( IMaterial *value ) = 0;

		/**
		 * Set the BakeOpacityInAlpha flag. If set, the total opacity of the baked layers replaces
		 * the alpha value in the output texture. @param value the new BakeOpacityInAlpha value
		 */
		virtual	void SetBakeOpacityInAlpha( bool value ) = 0;

		/**
		 * Get the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @return the current MappingImage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Get the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @return the current value of OutputBitDepth
		 */
		virtual	unsigned int GetOutputChannelBitDepth(  ) = 0;

		/**
		 * Set the fill mode @param value is the mode to which the fill mode will be set
		 */
		virtual	void SetFillMode( int value ) = 0;

		/**
		 * Get the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @return the current value of Dilation
		 */
		virtual	unsigned int GetDilation(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void CastMaterials(  ) = 0;

		/**
		 * Clears the processing, and resets all internal states. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @return the current SourceTextures material table<br />Description
		 * of ITextureTable: ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetSourceTextures(  ) = 0;

		/**
		 * Get the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @return the current destination
		 * material<br />Description of IMaterial: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetDestMaterial(  ) = 0;

		/**
		 * Set the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @param value is the value to which DestMaterialId will be
		 * set
		 */
		virtual	void SetDestMaterialId( rid value ) = 0;

		/**
		 * Get the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @return the current OutputFilePath
		 */
		virtual	rstring GetOutputFilePath(  ) = 0;

		/**
		 * Get the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @return the current value of OutputChannels
		 */
		virtual	unsigned int GetOutputChannels(  ) = 0;

		/**
		 * Set the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @param value is the mapping image to which
		 * MappingImage will be set
		 */
		virtual	void SetMappingImage( IMappingImage *value ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Get the color type that is cast.  @return the current color type
		 */
		virtual	rstring GetColorType(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IOpacityCaster
	 * IOpacityCaster is the interface used to cast opacity values. To be used when opacity
	 * is needed as a separate texture.
	 */
	typedef CountedPointer<IOpacityCaster> spOpacityCaster;

	class ITextureTable;
	class IMaterialTable;
	class IMaterial;
	class IMappingImage;
	class IImageData;

	/**
	 * INormalCaster is the interface used to cast normals data onto the receiving geometry.
	 */
	class INormalCaster : public IMaterialCaster
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if INormalCaster is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("INormalCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalCaster pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalCaster pointer
		 * @return a pointer to the INormalCaster object, if the cast can be made, and a NULL pointer otherwise
		 */
		static INormalCaster *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("INormalCaster") )
				return static_cast<INormalCaster*>(ptr);
			return NULL;
			}
		/**
		 * Get the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @return the current value of Dilation
		 */
		virtual	unsigned int GetDilation(  ) = 0;

		/**
		 * Set the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @param value is the value to which OutputBitDepth
		 * will be set
		 */
		virtual	void SetOutputChannelBitDepth( unsigned int value ) = 0;

		/**
		 * Set the FlipBackfacingNormals flag. If set, then normals will be flipped if they
		 * are back facing, i.e., pointing into the surface. This may introduce artifacts on
		 * geometries that have correctly facing normals, so only use for geometries with known
		 * back-facing normals. @param value is the value to which the FlipBackfacingNormals
		 * bool is to be set
		 */
		virtual	void SetFlipBackfacingNormals( bool value ) = 0;

		/**
		 * Set the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @param value is the mapping image to which
		 * MappingImage will be set
		 */
		virtual	void SetMappingImage( IMappingImage *value ) = 0;

		/**
		 * Set the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @param value is the value to which OutputChannels
		 * will be set
		 */
		virtual	void SetOutputChannels( unsigned int value ) = 0;

		/**
		 * Set the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @param value is the texture table to which SourceTextures
		 * will be set
		 */
		virtual	void SetSourceTextures( ITextureTable *value ) = 0;

		/**
		 * Get the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @return the current value of OutputChannels
		 */
		virtual	unsigned int GetOutputChannels(  ) = 0;

		/**
		 * Get the FlippedGreen flag. If set, the green channel is assumed to point along the
		 * negative bitangent instead of the positive. @return the current value of the FlippedGreen
		 * bool 
		 */
		virtual	bool GetFlippedGreen(  ) = 0;

		/**
		 * Set the FlippedGreen flag. If set, the green channel is assumed to point along the
		 * negative bitangent instead of the positive. @param value is the value the FlippedGreen
		 * bool is to be set
		 */
		virtual	void SetFlippedGreen( bool value ) = 0;

		/**
		 * Get the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @return the current OutputImage<br />Description
		 * of IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetOutputImage(  ) = 0;

		/**
		 * Set the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @param value the destination
		 * material to use
		 */
		virtual	void SetDestMaterial( IMaterial *value ) = 0;

		/**
		 * Get the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @return the current SourceTextures material table<br />Description
		 * of ITextureTable: ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetSourceTextures(  ) = 0;

		/**
		 * Get the texture coordinate level to use for the  tangent space normals. @return the
		 * current value of NormalMapTextureLevel
		 */
		virtual	rid GetNormalMapTextureLevel(  ) = 0;

		/**
		 * Get the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @return the current destination
		 * material<br />Description of IMaterial: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetDestMaterial(  ) = 0;

		/**
		 * Get the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @return the current value of DestMaterialId
		 */
		virtual	rid GetDestMaterialId(  ) = 0;

		/**
		 * Get the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @return the current MappingImage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Get the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @return the current value of OutputBitDepth
		 */
		virtual	unsigned int GetOutputChannelBitDepth(  ) = 0;

		/**
		 * Get the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @return the current SourceMaterials material table<br
		 * />Description of IMaterialTable: IMaterialTable keeps information on materials used
		 * while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetSourceMaterials(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Set the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @param value is the value to which Dilation will be set
		 */
		virtual	void SetDilation( unsigned int value ) = 0;

		/**
		 * Set the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @param value is the material table to which SourceMaterials
		 * will be set
		 */
		virtual	void SetSourceMaterials( IMaterialTable *value ) = 0;

		/**
		 * Set the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @param value is the value to which DestMaterialId will be
		 * set
		 */
		virtual	void SetDestMaterialId( rid value ) = 0;

		/**
		 * Get the FlipBackfacingNormals flag. If set, then normals will be flipped if they
		 * are back facing, i.e., pointing into the surface. This may introduce artifacts on
		 * geometries that have correctly facing normals, so only use for geometries with known
		 * back-facing normals. @return the current value of the FlipBackfacingNormals bool
		 */
		virtual	bool GetFlipBackfacingNormals(  ) = 0;

		/**
		 * Set the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @param value is the string to which OutputFilePath will be set
		 */
		virtual	void SetOutputFilePath( const char * value ) = 0;

		/**
		 * Set the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @param value is the image data to which OutputImage
		 * will be set
		 */
		virtual	void SetOutputImage( IImageData *value ) = 0;

		/**
		 * Clears the processing, and resets all internal states. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @return the current OutputFilePath
		 */
		virtual	rstring GetOutputFilePath(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void CastMaterials(  ) = 0;

		/**
		 * Set the GenerateTangentSpaceNormals flag. If set, then the generated normal map will
		 * be in tangent space. Please note that the geometry casted to must contain tangent
		 * space fields. @param value is the value to which the GenerateTangentSpaceNormals
		 * bool is to be set
		 */
		virtual	void SetGenerateTangentSpaceNormals( bool value ) = 0;

		/**
		 * Set the fill mode @param value is the mode to which the fill mode will be set
		 */
		virtual	void SetFillMode( int value ) = 0;

		/**
		 * Get the GenerateTangentSpaceNormals flag. If set, then the generated normal map will
		 * be in tangent space. Please note that the geometry casted to must contain tangent
		 * space fields. @return the current value of the GenerateTangentSpaceNormals bool
		 */
		virtual	bool GetGenerateTangentSpaceNormals(  ) = 0;

		/**
		 * Set the texture coordinate level to use for the  tangent space normals. @param value
		 * is the value to which NormalMapTextureLevel is to be set
		 */
		virtual	void SetNormalMapTextureLevel( rid value ) = 0;

		/**
		 * Get the fill mode @return the current fill mode
		 */
		virtual	int GetFillMode(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an INormalCaster
	 * INormalCaster is the interface used to cast normals data onto the receiving geometry.
	 */
	typedef CountedPointer<INormalCaster> spNormalCaster;

	class IGeometryData;

	/**
	 * Repairs normals on a processed geometry.
	 */
	class INormalRepairer : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if INormalRepairer is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("INormalRepairer",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalRepairer pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalRepairer pointer
		 * @return a pointer to the INormalRepairer object, if the cast can be made, and a NULL pointer otherwise
		 */
		static INormalRepairer *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("INormalRepairer") )
				return static_cast<INormalRepairer*>(ptr);
			return NULL;
			}
		/**
		 * Get the use borders flag mask. Edges with a matching BorderFlag will be "hard". If
		 * for example SGBORDER_TEXCOORD0 is being used, all edges with an UV border will be
		 * hard shaded. @return the current value of the BorderFlagsMask
		 */
		virtual	unsigned int GetBorderFlagsMask(  ) = 0;

		/**
		 * Repairs the normals of the geometry.  If the geometry has a "ShadingGroupIds" triangle
		 * user field, it is used to calculate new normals.
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Get the ScaleByArea flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the area of the triangle. @return the current value of the
		 * ScaleByArea bool
		 */
		virtual	bool GetScaleByArea(  ) = 0;

		/**
		 * Get the ScaleByAngle flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the angle of the corner at the vertex. @return the current
		 * value of the ScaleByAngle bool
		 */
		virtual	bool GetScaleByAngle(  ) = 0;

		/**
		 * Get the edge angle above which an edge is considered "hard". Note! The angle is in
		 * radians. @return the current value of HardEdgeAngle
		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * Set the ScaleByAngle flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the angle of the corner at the vertex. @param value is the
		 * value to which the ScaleByAngle bool is to be set
		 */
		virtual	void SetScaleByAngle( bool value ) = 0;

		/**
		 * Get the RepairOnlyInvalidNormals flag If set, then only those normals that are invalid
		 * (backfacing, zero length etc) will be fixed. @return the current value of the RepairOnlyInvalidNormals
		 * bool
		 */
		virtual	bool GetRepairOnlyInvalidNormals(  ) = 0;

		/**
		 * Set the RepairOnlyInvalidNormals flag If set, then only those normals that are invalid
		 * (backfacing, zero length etc) will be fixed. @param value is the value to which the
		 * RepairOnlyInvalidNormals bool is to be set
		 */
		virtual	void SetRepairOnlyInvalidNormals( bool value ) = 0;

		/**
		 * Set the edge angle above which an edge is considered "hard". Note! The angle is in
		 * radians. @param value is the value to which HardEdgeAngle is to be set
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * Set the use borders flag mask. Edges with a matching BorderFlag will be "hard". If
		 * for example SGBORDER_TEXCOORD0 is being used, all edges with an UV border will be
		 * hard shaded. @param value is the value to which the BorderFlagsMask is to be set
		 */
		virtual	void SetBorderFlagsMask( unsigned int value ) = 0;

		/**
		 * Set the Geometry object.  @param value is the geometry that is to be repaired
		 */
		virtual	void SetGeometry( IGeometryData *value ) = 0;

		/**
		 * Get the Geometry object.  @return the current geometry object<br />Description of
		 * IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetGeometry(  ) = 0;

		/**
		 * Set the ScaleByArea flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the area of the triangle. @param value is the value to which
		 * the ScaleByArea bool is to be set
		 */
		virtual	void SetScaleByArea( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an INormalRepairer
	 * Repairs normals on a processed geometry.
	 */
	typedef CountedPointer<INormalRepairer> spNormalRepairer;

	class ITextureTable;
	class IMaterialTable;
	class IMaterial;
	class IMappingImage;
	class IImageData;

	/**
	 * IDisplacementCaster is used to store the delta-values between the original and processed
	 * geometries. The values are divided by a scaling value, and clamped into the -1 ->
	 * 1 range before being  stored into an image.
	 */
	class IDisplacementCaster : public IMaterialCaster
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IDisplacementCaster is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IDisplacementCaster",type)==0 )
				return true;
			return IMaterialCaster::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDisplacementCaster pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDisplacementCaster pointer
		 * @return a pointer to the IDisplacementCaster object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IDisplacementCaster *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IDisplacementCaster") )
				return static_cast<IDisplacementCaster*>(ptr);
			return NULL;
			}
		/**
		 * Get the GenerateScalarDisplacement value. If set, the displacement vectors' lengths
		 * are stored into the displacement map, not the delta values @return The current GenerateScalarDisplacement
		 * flag
		 */
		virtual	bool GetGenerateScalarDisplacement(  ) = 0;

		/**
		 * Set the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @param value is the image data to which OutputImage
		 * will be set
		 */
		virtual	void SetOutputImage( IImageData *value ) = 0;

		/**
		 * Set the GenerateScalarDisplacement value. If set, the displacement vectors' lengths
		 * are stored into the displacement map, not the delta values @param value The desired
		 * GenerateScalarDisplacement flag
		 */
		virtual	void SetGenerateScalarDisplacement( bool value ) = 0;

		/**
		 * Get the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @return the current value of Dilation
		 */
		virtual	unsigned int GetDilation(  ) = 0;

		/**
		 * Get the OutputImage object that will receive the image. The current contents of the
		 * image will be removed, and the image will be written to the Colors field of the ReImageData
		 * object. Either OutputImage or OutputFilePath must be set. If OutputImage is set,
		 * then OutputFilePath is ignored. @return the current OutputImage<br />Description
		 * of IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetOutputImage(  ) = 0;

		/**
		 * Get the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @return the current value of OutputBitDepth
		 */
		virtual	unsigned int GetOutputChannelBitDepth(  ) = 0;

		/**
		 * Get the DistanceScaling value. All the delta values are divided by this value before
		 * storing them into an image. @return The current DistanceScaling value
		 */
		virtual	real GetDistanceScaling(  ) = 0;

		/**
		 * Set the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @param value the destination
		 * material to use
		 */
		virtual	void SetDestMaterial( IMaterial *value ) = 0;

		/**
		 * Set the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @param value is the value to which DestMaterialId will be
		 * set
		 */
		virtual	void SetDestMaterialId( rid value ) = 0;

		/**
		 * Set the Dilation value. Where applicable, such as colors and normals, the caster
		 * will fill empty pixels surrounding filled pixels with values mixed from the filled
		 * ones. This setting sets how many  pixels to fill outside the original filled pixels.
		 * @param value is the value to which Dilation will be set
		 */
		virtual	void SetDilation( unsigned int value ) = 0;

		/**
		 * Set the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @param value is the string to which OutputFilePath will be set
		 */
		virtual	void SetOutputFilePath( const char * value ) = 0;

		/**
		 * Get the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @return the current SourceTextures material table<br />Description
		 * of ITextureTable: ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetSourceTextures(  ) = 0;

		/**
		 * Set the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @param value is the value to which OutputChannels
		 * will be set
		 */
		virtual	void SetOutputChannels( unsigned int value ) = 0;

		/**
		 * Get the texture coordinate level to use for the  tangent space displacement vectors.
		 * @return The current NormalMapTextureLevel value
		 */
		virtual	rid GetNormalMapTextureLevel(  ) = 0;

		/**
		 * Get the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @return the current MappingImage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void CastMaterials(  ) = 0;

		/**
		 * Runs the material casting from SourceGeometry to Geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Get the OutputChannels parameter. This can be set to either: <ul><li>1 (Luminance)</li><li>3
		 * (RGB)</li><li>4 (RGBA)</li></ul> @return the current value of OutputChannels
		 */
		virtual	unsigned int GetOutputChannels(  ) = 0;

		/**
		 * Get the OutputFilePath file path, where the output image will be placed. Note that
		 * the extension specified will specify the file format. Please note that only PNG (extension
		 * .png) will be able  to support all possible bit dephts (such as RGB 16-bit per channel).
		 * Either OutputImage or OutputFilePath must be set. If OutputImage is set, then OutputFilePath
		 * is ignored. @return the current OutputFilePath
		 */
		virtual	rstring GetOutputFilePath(  ) = 0;

		/**
		 * Set the DistanceScaling value. All the delta values are divided by this value before
		 * storing them into an image. @param value The desired DistanceScaling value
		 */
		virtual	void SetDistanceScaling( real value ) = 0;

		/**
		 * Set the GenerateTangentSpaceDisplacement value. If set, the displacement vectors
		 * are transformed into the destination objects' tangent space @param value The desired
		 * GenerateTangentSpaceDisplacement flag
		 */
		virtual	void SetGenerateTangentSpaceDisplacement( bool value ) = 0;

		/**
		 * Get the GenerateTangentSpaceDisplacement value. If set, the displacement vectors
		 * are transformed into the destination objects' tangent space @return The current GenerateTangentSpaceDisplacement
		 * flag
		 */
		virtual	bool GetGenerateTangentSpaceDisplacement(  ) = 0;

		/**
		 * Set the OutputBitDepth parameter. This can be either 8 or 16.  Please note that this
		 * is the bit depth per-channel, so a bit depth of 8 and a OutputChannels value of 3
		 * will result in 8*3 = 24-bit RGB values. @param value is the value to which OutputBitDepth
		 * will be set
		 */
		virtual	void SetOutputChannelBitDepth( unsigned int value ) = 0;

		/**
		 * Get the DestMaterial object. When casting colors, the material caster will modulate
		 * the output to match the base color of the  destination material. If no destination
		 * material is set, no modulation will be set on the output. @return the current destination
		 * material<br />Description of IMaterial: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetDestMaterial(  ) = 0;

		/**
		 * Set the texture coordinate level to use for the  tangent space displacement vectors.
		 * @param value The desired NormalMapTextureLevel value
		 */
		virtual	void SetNormalMapTextureLevel( rid value ) = 0;

		/**
		 * Clears the processing, and resets all internal states. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @param value is the material table to which SourceMaterials
		 * will be set
		 */
		virtual	void SetSourceMaterials( IMaterialTable *value ) = 0;

		/**
		 * Set the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @param value is the texture table to which SourceTextures
		 * will be set
		 */
		virtual	void SetSourceTextures( ITextureTable *value ) = 0;

		/**
		 * Get the DestMaterialId object. If set, only the parts of the destination map that.
		 * To disable, set to -1. @return the current value of DestMaterialId
		 */
		virtual	rid GetDestMaterialId(  ) = 0;

		/**
		 * Get the SourceMaterials object. The SourceMaterials object contains all materials
		 * of the the source geometry. The source geometry must have a "MaterialIds" field that
		 * indices the material table. @return the current SourceMaterials material table<br
		 * />Description of IMaterialTable: IMaterialTable keeps information on materials used
		 * while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetSourceMaterials(  ) = 0;

		/**
		 * Set the MappingImage object. The MappingImage object contains the mapping between
		 * the Geometry and SourceGeometry objects. @param value is the mapping image to which
		 * MappingImage will be set
		 */
		virtual	void SetMappingImage( IMappingImage *value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IDisplacementCaster
	 * IDisplacementCaster is used to store the delta-values between the original and processed
	 * geometries. The values are divided by a scaling value, and clamped into the -1 ->
	 * 1 range before being  stored into an image.
	 */
	typedef CountedPointer<IDisplacementCaster> spDisplacementCaster;

	class IGeometryData;

	/**
	 * IGeometryTangentCalculator calculates tangent vectors for geometry data objects.
	 * One corner field of texture coordinates must exist, as well as normals. The Tangents
	 * are placed into two corner fields called "Tangents" and "Bitangents". If any of these
	 * fields already exists, it is replaced by the new field.
	 */
	class IGeometryTangentCalculator : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryTangentCalculator is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGeometryTangentCalculator",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryTangentCalculator pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryTangentCalculator pointer
		 * @return a pointer to the IGeometryTangentCalculator object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGeometryTangentCalculator *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGeometryTangentCalculator") )
				return static_cast<IGeometryTangentCalculator*>(ptr);
			return NULL;
			}
		/**
		 * The TexCoords field id to use for the tangent calculation. If set to -1, all texture
		 * coordinates will get corresponding tangent fields. @param value the TexCoords set
		 * id	
		 */
		virtual	void SetTexCoordsSetId( rid value ) = 0;

		/**
		 * Sets the tangent calculator type, types listed in SimplygonSDK::TangentSpaceMethod
		 * @param type the desired tangent calculator type
		 */
		virtual	void SetTangentCalculatorType( rid type ) = 0;

		/**
		 * Gets the tangent calculator type, types listed in SimplygonSDK::TangentSpaceMethod
		 * @return the current tangent calculator type
		 */
		virtual	rid GetTangentCalculatorType(  ) = 0;

		/**
		 * Calculates the tangents of a geometry data object.  @param geom the geometry object
		 * receives new fields, as described in the class description.
		 */
		virtual	void CalculateTangents( IGeometryData *geom ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGeometryTangentCalculator
	 * IGeometryTangentCalculator calculates tangent vectors for geometry data objects.
	 * One corner field of texture coordinates must exist, as well as normals. The Tangents
	 * are placed into two corner fields called "Tangents" and "Bitangents". If any of these
	 * fields already exists, it is replaced by the new field.
	 */
	typedef CountedPointer<IGeometryTangentCalculator> spGeometryTangentCalculator;


	/**
	 * ISettingsObject is the abstract base class for all settings objects in Simplygon.
	 * Settings objects contains parameters for processing objects to use. These settings
	 * objects will have their data set and reached from a IProcessingObject and then used
	 * therein.
	 */
	class ISettingsObject : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISettingsObject is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISettingsObject",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISettingsObject pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISettingsObject pointer
		 * @return a pointer to the ISettingsObject object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISettingsObject *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISettingsObject") )
				return static_cast<ISettingsObject*>(ptr);
			return NULL;
			}
	};

	/**
	 * a CounterPointer smart pointer to an ISettingsObject
	 * ISettingsObject is the abstract base class for all settings objects in Simplygon.
	 * Settings objects contains parameters for processing objects to use. These settings
	 * objects will have their data set and reached from a IProcessingObject and then used
	 * therein.
	 */
	typedef CountedPointer<ISettingsObject> spSettingsObject;


	/**
	 * Settings for handling unconnected parts and unwanted gaps in the geometry. It consists
	 * of two parts, Welding and T-junction removal. Welding merges vertices that are closer
	 * than a set distance from each other. T-junction removal finds open edges that lies
	 * within a set distance from other open edges, but without matching vertices. It then
	 * splits those triangles into smaller, matching triangles and fuses them together.
	 */
	class IRepairSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRepairSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRepairSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRepairSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRepairSettings pointer
		 * @return a pointer to the IRepairSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRepairSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRepairSettings") )
				return static_cast<IRepairSettings*>(ptr);
			return NULL;
			}
		/**
		 * Get the UseWelding flag. If set, vertices within each others welding distance will
		 * be welded together. @return the current value of UseWelding
		 */
		virtual	bool GetUseWelding(  ) = 0;

		/**
		 * Set the number of ProgressivePasses. Minimum is 1, but higher numbers give a better
		 * quality, at the expense of longer running time. @param value is the integer to which
		 * ProgressivePasses will be set
		 */
		virtual	void SetProgressivePasses( unsigned int value ) = 0;

		/**
		 * Get the number of ProgressivePasses. Minimum is 1, but higher numbers give a better
		 * quality, at the expense of longer running time. @return the current value of ProgressivePasses
		 */
		virtual	unsigned int GetProgressivePasses(  ) = 0;

		/**
		 * Get the UseTJunctionRemover flag, if set, t-junctions will be removed. If enabled,
		 * it also requires UseWelding to be on. @return the current value of UseTJunctionRemover
		 */
		virtual	bool GetUseTJunctionRemover(  ) = 0;

		/**
		 * Set the T-Junction distance, below which, the T-Junctions will be welded @param value
		 * is the value to which TjuncDist will be set
		 */
		virtual	void SetTjuncDist( real value ) = 0;

		/**
		 * Get the WeldOnlyBorderVertices flag, if set, only vertices that are on the border
		 * (as reported by the VertexBorder boolean field) are considered for the welding @return
		 * the current value of WeldOnlyBorderVertices
		 */
		virtual	bool GetWeldOnlyBorderVertices(  ) = 0;

		/**
		 * Set the WeldOnlyBorderVertices flag, if set, only vertices that are on the border
		 * (as reported by the VertexBorder boolean field) are considered for the welding @param
		 * value is the bool to which WeldOnlyBorderVertices will be set
		 */
		virtual	void SetWeldOnlyBorderVertices( bool value ) = 0;

		/**
		 * Get the T-Junction distance, below which, the T-Junctions will be welded @return
		 * the current value of TjuncDist
		 */
		virtual	real GetTjuncDist(  ) = 0;

		/**
		 * Set the WeldOnlyObjectBoundary flag, if set, only vertices that are on the boundary
		 * between two different objects are considered. Affects both welder and t-junction
		 * remover. for the welding. @param value is the bool to which WeldOnlyObjectBoundary
		 * will be set
		 */
		virtual	void SetWeldOnlyObjectBoundary( bool value ) = 0;

		/**
		 * Set the UseTJunctionRemover flag, if set, t-junctions will be removed. If enabled,
		 * it also requires UseWelding to be on. @param value is the bool to which UseTJunctionRemover
		 * will be set
		 */
		virtual	void SetUseTJunctionRemover( bool value ) = 0;

		/**
		 * Set the Welding distance, below which, the vertices will be welded @param value is
		 * the value to which WeldDist will be set
		 */
		virtual	void SetWeldDist( real value ) = 0;

		/**
		 * Get the Welding distance, below which, the vertices will be welded @return the current
		 * value of WeldDist
		 */
		virtual	real GetWeldDist(  ) = 0;

		/**
		 * Get the WeldOnlyObjectBoundary flag, if set, only vertices that are on the boundary
		 * between two different objects are considered. Affects both welder and t-junction
		 * remover. for the welding. @return the current value of WeldOnlyObjectBoundary
		 */
		virtual	bool GetWeldOnlyObjectBoundary(  ) = 0;

		/**
		 * Set the UseWelding flag. If set, vertices within each others welding distance will
		 * be welded together. @param value is the bool to which UseWelding will be set
		 */
		virtual	void SetUseWelding( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRepairSettings
	 * Settings for handling unconnected parts and unwanted gaps in the geometry. It consists
	 * of two parts, Welding and T-junction removal. Welding merges vertices that are closer
	 * than a set distance from each other. T-junction removal finds open edges that lies
	 * within a set distance from other open edges, but without matching vertices. It then
	 * splits those triangles into smaller, matching triangles and fuses them together.
	 */
	typedef CountedPointer<IRepairSettings> spRepairSettings;


	/**
	 * Settings for the Simplygon Reduction/Remeshing classes  With the BoneSettings object,
	 * the user can setup all the parameters for how the BoneLOD processor should simplify
	 * the links between geometries  and bones.   Bones can be un-linked from the geometry
	 * either with a set ratio or  depending on a selected pixel size on screen.
	 */
	class IBoneSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IBoneSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IBoneSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IBoneSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IBoneSettings pointer
		 * @return a pointer to the IBoneSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IBoneSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IBoneSettings") )
				return static_cast<IBoneSettings*>(ptr);
			return NULL;
			}
		/**
		 * Decides what kind of bone-removal that will be used (if any). <br> <ul> <li> SG_BONEPROCESSING_NO_PROCESSING,
		 * All bones will be kept, and the number of bones linked to each vertex will be kept
		 * as is. </li> <li> SG_BONEPROCESSING_NO_BONE_REMOVAL, No bones removed, but can still
		 * limit the number of bones that each vertex can be linked to. </li> <li> SG_BONEPROCESSING_RATIO_PROCESSING,
		 * Removes a number of bones based on a percentage-basis. BoneLodRatio is a value set
		 * from 0 to 1.	 Using this flag, the max number of bones per vertex can also be reduced.
		 * </li> <li> SG_BONEPROCESSING_PIXELSIZE_PROCESSING, Removes as many bones as possible,
		 * as long as the removal wont be noticeable at the set pixel size. </li> </ul> Using
		 * this flag, the max number of bones per vertex can also be reduced. @param value the
		 * desired BoneLOD processing method
		 */
		virtual	void SetBoneLodProcess( unsigned int value ) = 0;

		/**
		 * A value between 0 and 1. Decides how many bones will be removed (or rather, un-linked)
		 * from the geometry. 1 means all bones will be kept, 0.5 would mean that 50% of the
		 * bones would  be removed, and 0.1 would mean that only 10% of the bones would be kept.
		 * Leaf-bones will be removed first, and then  bones further in will follow. Vertices
		 * will be re-linked to the most suitable remaining bone. @param value the new BoneLOD
		 * ratio value
		 */
		virtual	void SetBoneLodRatio( real value ) = 0;

		/**
		 * Decides what kind of bone-removal that will be used (if any). <br> <ul> <li> SG_BONEPROCESSING_NO_PROCESSING,
		 * All bones will be kept, and the number of bones linked to each vertex will be kept
		 * as is. </li> <li> SG_BONEPROCESSING_NO_BONE_REMOVAL, No bones removed, but can still
		 * limit the number of bones that each vertex can be linked to. </li> <li> SG_BONEPROCESSING_RATIO_PROCESSING,
		 * Removes a number of bones based on a percentage-basis. BoneLodRatio is a value set
		 * from 0 to 1.	 Using this flag, the max number of bones per vertex can also be reduced.
		 * </li> <li> SG_BONEPROCESSING_PIXELSIZE_PROCESSING, Removes as many bones as possible,
		 * as long as the removal wont be noticeable at the set pixel size. </li> </ul> Using
		 * this flag, the max number of bones per vertex can also be reduced. @return the current
		 * BoneLOD processing method
		 */
		virtual	unsigned int GetBoneLodProcess(  ) = 0;

		/**
		 * Decides the maximum limit of how many bones can be connected to each vertex. If for
		 * example set to 1, then each vertex will only be linked to 1 bone. @param value the
		 * desired maximum bones per vertex
		 */
		virtual	void SetMaxBonePerVertex( unsigned int value ) = 0;

		/**
		 * A value between 0 and 1. Decides how many bones will be removed (or rather, un-linked)
		 * from the geometry. 1 means all bones will be kept, 0.5 would mean that 50% of the
		 * bones would  be removed, and 0.1 would mean that only 10% of the bones would be kept.
		 * Leaf-bones will be removed first, and then  bones further in will follow. Vertices
		 * will be re-linked to the most suitable remaining bone. @return the BoneLOD ratio
		 * value
		 */
		virtual	real GetBoneLodRatio(  ) = 0;

		/**
		 * Decides the maximum limit of how many bones can be connected to each vertex. If for
		 * example set to 1, then each vertex will only be linked to 1 bone. @return value the
		 * maximum bones per vertex
		 */
		virtual	unsigned int GetMaxBonePerVertex(  ) = 0;

		/**
		 * This is the PixelSize that will be used to calculate how many bones can be removed.
		 * As many bones as possible will be removed, as long as the removal wont be noticeable
		 * at the set pixel size on screen.  @param value the new BoneLOD pixel size
		 */
		virtual	void SetBoneLodPixelSize( unsigned int value ) = 0;

		/**
		 * This is the PixelSize that will be used to calculate how many bones can be removed.
		 * As many bones as possible will be removed, as long as the removal wont be noticeable
		 * at the set pixel size on screen.  @return the BoneLOD pixel size
		 */
		virtual	unsigned int GetBoneLodPixelSize(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IBoneSettings
	 * Settings for the Simplygon Reduction/Remeshing classes  With the BoneSettings object,
	 * the user can setup all the parameters for how the BoneLOD processor should simplify
	 * the links between geometries  and bones.   Bones can be un-linked from the geometry
	 * either with a set ratio or  depending on a selected pixel size on screen.
	 */
	typedef CountedPointer<IBoneSettings> spBoneSettings;

	class IRealArray;

	/**
	 * Settings for the IReductionProcessor class. Handles all the settings for Simplygons
	 * simplification algorithms. The user can tell the reduction processor which features
	 * are important by using the FeatureFlags?parameter, and also the relative importance
	 * of these features using the Set{feature}Importance methods. Also settings for things
	 * like symmetry are set here.
	 */
	class IReductionSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IReductionSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IReductionSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IReductionSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IReductionSettings pointer
		 * @return a pointer to the IReductionSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IReductionSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IReductionSettings") )
				return static_cast<IReductionSettings*>(ptr);
			return NULL;
			}
		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetEdgeSetImportance( real value ) = 0;

		/**
		 * Get SymmetryOffset, the position on the symmetry axis where the symmetry plane is
		 * placed. @return the current value of SymmetryOffset
		 */
		virtual	real GetSymmetryOffset(  ) = 0;

		/**
		 * Gets if the reducer currently allows usage of DirectX This flag is recommended to
		 * be enabled unless DirectX specific issues are being experienced @return the current
		 * value of AllowDirectX
		 */
		virtual	bool GetAllowDirectX(  ) = 0;

		/**
		 * Get the flag that specifies how big "freedom" Simplygon has when it comes to altering
		 * vertex/triangle data. Allowing more altered data means it will be easier to create
		 * good looking LODs, but without altered data it will be easier to keep the memory-usage
		 * in the LOD-chain  more optimized. Possible options are: <ul><li>SG_DATACREATIONPREFERENCES_USE_ONLY_ORIGINAL_DATA</li>
		 * <li>SG_DATACREATIONPREFERENCES_PREFER_ORIGINAL_DATA</li> <li>SG_DATACREATIONPREFERENCES_PREFER_OPTIMIZED_RESULT</li></ul>
		 * @return the current value of the DataCreationPreferences flag.
		 */
		virtual	unsigned int GetDataCreationPreferences(  ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetMaterialImportance( real value ) = 0;

		/**
		 * Set the FeatureFlags mask value. Tells the reducer which data-fields you want to
		 * use to guide the simplification. @param value is the mask to which FeatureFlags will
		 * be set
		 */
		virtual	void SetFeatureFlags( unsigned int value ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetVertexColorImportance( real value ) = 0;

		/**
		 * Set SymmetryOffset, the position on the symmetry axis where the symmetry plane is
		 * placed. @param value is the value to which SymmetryOffset will be set
		 */
		virtual	void SetSymmetryOffset( real value ) = 0;

		/**
		 * Sets the percentage of materials to keep. The reducer will replace materials with
		 * other materials that gives the least visual difference. @param value is the number
		 * of materials to replace
		 */
		virtual	void SetKeepPercentageOfMaterials( real value ) = 0;

		/**
		 * Set the flag that specifies how big "freedom" Simplygon has when it comes to altering
		 * vertex/triangle data.  Allowing more altered data means it will be easier to create
		 * good looking LODs, but without altered data it will be easier to keep the memory-usage
		 * in the LOD-chain  more optimized. Possible options are: <ul><li>SG_DATACREATIONPREFERENCES_USE_ONLY_ORIGINAL_DATA</li>
		 * <li>SG_DATACREATIONPREFERENCES_PREFER_ORIGINAL_DATA</li> <li>SG_DATACREATIONPREFERENCES_PREFER_OPTIMIZED_RESULT</li></ul>
		 * @param value is the value to which the DataCreationPreferences flag will be set.
		 * 		 */
		virtual	void SetDataCreationPreferences( unsigned int value ) = 0;

		/**
		 * Get the MaxDeviation value, the maximum surface-deviation between the  reduced geometry
		 * and the original. @return the current value of MaxDeviation
		 */
		virtual	real GetMaxDeviation(  ) = 0;

		/**
		 * Set the EnablePostprocessing flag.  Postprocessing involved normal recalculation
		 * / normal fix up and setting up the material casting data. Should only be disabled
		 * if processing speed is of high importance. @param value is the bool to which EnablePostprocessing
		 * will be set
		 */
		virtual	void SetEnablePostprocessing( bool value ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetSkinningImportance( real value ) = 0;

		/**
		 * Set the UseSymmetryQuadRetriangulator flag. If true, and KeepSymmetry is on, any
		 * triangles that have been triangulated from symmetrical quads into unsymmetrical triangles
		 * are detected and fixed. The edges of said triangles are flipped across the old quad
		 * so that the mesh becomes symmetrical again. @param value is the bool to which UseSymmetryQuadRetriangulator
		 * will be set
		 */
		virtual	void SetUseSymmetryQuadRetriangulator( bool value ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetSkinningImportance(  ) = 0;

		/**
		 * Get what axis to be used for symmetry calculations. @return the current value of
		 * SymmetryAxis. <ul><li>0 = x</li><li>1 = y</li><li>2 = z</li></ul>
		 */
		virtual	unsigned int GetSymmetryAxis(  ) = 0;

		/**
		 * Get the FeatureFlags mask value. @return the current value of the FeatureFlags mask
		 */
		virtual	unsigned int GetFeatureFlags(  ) = 0;

		/**
		 * Get the UseSymmetryQuadRetriangulator flag. If true, and KeepSymmetry is on, any
		 * triangles that have been triangulated from symmetrical quads into unsymmetrical triangles
		 * are detected and fixed. The edges of said triangles are flipped across the old quad
		 * so that the mesh becomes symmetrical again. @return the current value of the UseSymmetryQuadRetriangulator
		 * bool
		 */
		virtual	bool GetUseSymmetryQuadRetriangulator(  ) = 0;

		/**
		 * Get the CreateGeomorphGeometry value. If set, the reducer will create a GeometryData
		 * object that is a morphed version of the original GeometryData, that can be used to
		 * morph between the original geometry and the reduced geometry. Should not be used
		 * together with TJunctionRemover, NormalRecalculation or Material LOD. @return the
		 * current value of the CreateGeomorphGeometry bool
		 */
		virtual	bool GetCreateGeomorphGeometry(  ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetShadingImportance( real value ) = 0;

		/**
		 * Set the UseVertexWeighting value. If set, the reducer will weight the reduction based
		 * on the weights in the "VertexWeighting" vertex field. @param value is the bool to
		 * which UseVertexWeights will be set
		 */
		virtual	void SetUseVertexWeights( bool value ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetGroupImportance(  ) = 0;

		/**
		 * Set the MaxDeviation value, the maximum surface-deviation between the  reduced geometry
		 * and the original. @param value is the value to which MaxDeviation will be set
		 */
		virtual	void SetMaxDeviation( real value ) = 0;

		/**
		 * Sets if the reducer will use material part removal thresholds for object removal
		 * @param value is the value to which UseMaterialPartRemover will be set
		 */
		virtual	void SetUseMaterialPartRemover( bool value ) = 0;

		/**
		 * Get the flag that decides how precise the reducer will be during the mesh reduction.
		 * <ul> <li>SG_REDUCTIONHEURISTICS_FAST -> Reducer will be faster, but pixelsize and
		 * trianglecount will not match perfectly. </li> <li>SG_REDUCTIONHEURISTICS_CONSISTENT
		 * -> Reducer will be slower, but pixelsize and trianglecount will consistently give
		 * matching results.</li> </ul> @return the current value of ReductionHeuristics. 
		 */
		virtual	unsigned int GetReductionHeuristics(  ) = 0;

		/**
		 * Set the SymmetryDetectionTolerance, the tolerance used when detecting symmetry. Values
		 * in the ranges 1e-5 to 1e-3 will usually produce good results. This specific tolerance
		 * corresponds to the off-plane tolerance, ie. the tolerance of the coordinate components
		 * that are not the symmetry axis. The in-plane tolerance is always 10 times the off-plane
		 * tolerance. This value is relative to the size of the Geometry, so 0.01 would mean
		 * 1% of the bounding box size of the Geometry. @param value is the value to which SymmetryDetectionTolerance
		 * will be set
		 */
		virtual	void SetSymmetryDetectionTolerance( real value ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetGroupImportance( real value ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetTextureImportance( real value ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetGeometryImportance( real value ) = 0;

		/**
		 * Get the wanted reduction ratio. The range is 0->1, the number of  triangles in the
		 * processed geometry, divided by the number in the original geometry.  A value of 1
		 * will leave all triangles in the geometry, 0 will remove as many triangles as possible.
		 * The reduction ratio may not be reachable, if other restrictions  are in place, such
		 * as a MaxDeviation. It depends on the StopCondition. @return the current value of
		 * ReductionRatio
		 */
		virtual	real GetReductionRatio(  ) = 0;

		/**
		 * Sets whether or not all hidden materials should be  replaced / removed. @param value
		 * the new flag.
		 */
		virtual	void SetReplaceHiddenMaterials( bool value ) = 0;

		/**
		 * Gets the percentage of materials to keep. @return the current number of materials
		 * to replace
		 */
		virtual	real GetKeepPercentageOfMaterials(  ) = 0;

		/**
		 * Sets the maximum length of the triangles edges after reduction. Can be used to limit
		 * output triangle size. @param value is the new value of MaxEdgeLength
		 */
		virtual	void SetMaxEdgeLength( real value ) = 0;

		/**
		 * Set the flag for if the reduction process should store geomorph data in the processed
		 * GeometryData object. This data is an array with same size as the vertexcount was
		 * before the reduction process, and will have the coordinates for each vertex on its
		 * corresponding position on the reduced GeometryData's surface. Can be used to give
		 * smooth transition from a highlevel LOD to a lowlevel LOD. This array can be accessed
		 * with " GeomObj->GetCustomField( "MappedVertexCoords" ) " @param value is the bool
		 * to which GenerateGeomorphData will be set
		 */
		virtual	void SetGenerateGeomorphData( bool value ) = 0;

		/**
		 * Set the flag that decides how far the reducer will go, and what settings it uses.
		 * For extremely heavy reductions, it is recommended to use a max deviation condition,
		 * as the max deviation reduction can be run on multiple cores. <ul> <li>SG_STOPCONDITION_REDUCTIONRATIO
		 * -> it will stop when the triangle-ratio has been reached.</li> <li>SG_STOPCONDITION_MAXDEVIATION
		 * -> it will stop when the maximum surface-deviation has been reached.</li> <li>SG_STOPCONDITION_BOTH_ARE_REACHED
		 * -> it will keep going until both reduction-ratio AND max-deviation has been reached.
		 * This means that it will give you the lowest trianglecount of either reduction-ratio
		 * or max-deviation.</li> <li>SG_STOPCONDITION_EITHER_IS_REACHED -> it will stop once
		 * either reduction-ratio OR max-deviation has been reached. This means that it will
		 * give you the highest  trianglecount of reduction-ratio and max-deviation.</li> </ul>
		 * @param value is the flag to which StopConditions will be set. The options are:
		 */
		virtual	void SetStopCondition( unsigned int value ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetTextureImportance(  ) = 0;

		/**
		 * Get the flag that decides how far the reducer will go, and what settings it uses.
		 * <ul> <li>SG_STOPCONDITION_REDUCTIONRATIO -> it will stop when the triangle-ratio
		 * has been reached.</li> <li>SG_STOPCONDITION_MAXDEVIATION -> it will stop when the
		 * maximum surface-deviation has been reached.</li> <li>SG_STOPCONDITION_BOTH_ARE_REACHED
		 * -> it will keep going until both reduction-ratio AND max-deviation has been reached.
		 * This means that it will give you the lowest trianglecount of either reduction-ratio
		 * or max-deviation.</li> <li>SG_STOPCONDITION_EITHER_IS_REACHED -> it will stop once
		 * either reduction-ratio OR max-deviation has been reached. This means that it will
		 * give you the highest  trianglecount of reduction-ratio and max-deviation.</li> </ul>
		 * @return the current value of StopCondition. 
		 */
		virtual	unsigned int GetStopCondition(  ) = 0;

		/**
		 * Get the inward move multiplier, how much the mesh is allowed to shrink its silhouette
		 * perimeter @return the current value of InwardMoveMultiplier
		 */
		virtual	real GetInwardMoveMultiplier(  ) = 0;

		/**
		 * Gets if the reducer will use material part removal thresholds for object removal
		 * @return the current value of UseMaterialPartRemover
		 */
		virtual	bool GetUseMaterialPartRemover(  ) = 0;

		/**
		 * Get the "UseHighQualityNormalCalculation" flag, which decided if the reducer will
		 * do a much more precise way of calculating the vertex normals or not. @return the
		 * current value of the UseHighQualityNormalCalculation bool
		 */
		virtual	bool GetUseHighQualityNormalCalculation(  ) = 0;

		/**
		 * Set the CreateGeomorphGeometry value. If set, the reducer will create a GeometryData
		 * object that is a morphed version of the original GeometryData, that can be used to
		 * morph between the original geometry and the reduced geometry. Should not be used
		 * together with TJunctionRemover, NormalRecalculation or Material LOD. @param value
		 * is the bool to which CreateGeomorphGeometry will be set
		 */
		virtual	void SetCreateGeomorphGeometry( bool value ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetVertexColorImportance(  ) = 0;

		/**
		 * Set the wanted reduction ratio. The range is 0->1, the number of  triangles in the
		 * processed geometry, divided by the number in the original geometry.  A value of 1
		 * will leave all triangles in the geometry, 0 will remove as many triangles as possible.
		 * The reduction ratio may not be reachable, if other restrictions  are in place, such
		 * as a MaxDeviation. It depends on the StopCondition. @param value is the value to
		 * which ReductionRatio will be set
		 */
		virtual	void SetReductionRatio( real value ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetGeometryImportance(  ) = 0;

		/**
		 * Gets the maximum length of the triangles edges after reduction. Can be used to limit
		 * output triangle size. @return the current value of MaxEdgeLength
		 */
		virtual	real GetMaxEdgeLength(  ) = 0;

		/**
		 * Set the flag that decides how precise the reducer will be during the mesh reduction.
		 * <ul> <li>SG_REDUCTIONHEURISTICS_FAST -> Reducer will be faster, but pixelsize and
		 * trianglecount will not match perfectly. </li> <li>SG_REDUCTIONHEURISTICS_CONSISTENT
		 * -> Reducer will be slower, but pixelsize and trianglecount will consistently give
		 * matching results.</li> </ul> @return the current value of ReductionHeuristics. 
		 */
		virtual	void SetReductionHeuristics( unsigned int value ) = 0;

		/**
		 * Gets whether or not all hidden materials should be  replaced / removed. @return the
		 * current flag.
		 */
		virtual	bool GetReplaceHiddenMaterials(  ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetShadingImportance(  ) = 0;

		/**
		 * Set to true and the reducer will do a much more precise way of calculating the vertex
		 * normals. It will however be slower. Set to false and it will do a much more rough
		 * estimation of what the vertex normals will look like, but faster. @param value is
		 * the value to which UseHighQualityNormalCalculation will be set
		 */
		virtual	void SetUseHighQualityNormalCalculation( bool value ) = 0;

		/**
		 * Set the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. A higher number means higher importance. @param value is
		 * the value to which the importance will be set
		 */
		virtual	void SetValidityImportance( real value ) = 0;

		/**
		 * Set what axis to be used for symmetry calculations.  @param value is the value to
		 * which SymmetryAxis will be set. <ul><li>0 = x</li><li>1 = y</li><li>2 = z</li></ul>
		 */
		virtual	void SetSymmetryAxis( unsigned int value ) = 0;

		/**
		 * Get the flag for if the reduction process should store geomorph data in the processed
		 * GeometryData object. This data is an array with same size as the vertexcount was
		 * before the reduction process, and will have the coordinates for each vertex on its
		 * corresponding position on the reduced GeometryData's surface. Can be used to give
		 * smooth transition from a highlevel LOD to a lowlevel LOD. This array can be accessed
		 * with " GeomObj->GetCustomField( "MappedVertexCoords" ) " @return the current value
		 * of the GenerateGeomorphData bool
		 */
		virtual	bool GetGenerateGeomorphData(  ) = 0;

		/**
		 * Sets the reduction ratio using a fixed triangle count. The actual ratio will be set
		 * once the processing has started, which means that the updated ratio is only gettable
		 * after the reduction has taken place. @param value is the triangle count target of
		 * the reduced mesh
		 */
		virtual	void SetReductionRatioUsingTriangleCount( rid value ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetEdgeSetImportance(  ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetMaterialImportance(  ) = 0;

		/**
		 * Get the importance value of the relevant feature, meaning the relative importance
		 * of the specific mesh feature.  The importance is defined as a range 1/8 -> 8 where
		 * 1 is the default value. @return the current value of the importance of the feature
		 */
		virtual	real GetValidityImportance(  ) = 0;

		/**
		 * Get the SymmetryDetectionTolerance, the tolerance used when detecting symmetry. Values
		 * in the ranges 1e-5 to 1e-3 will usually produce good results. This specific tolerance
		 * corresponds to the off-plane tolerance, ie. the tolerance of the coordinate components
		 * that are not the symmetry axis. The in-plane tolerance is always 10 times the off-plane
		 * tolerance. This value is relative to the size of the Geometry, so 0.01 would mean
		 * 1% of the bounding box size of the Geometry. @return the current value of SymmetryDetectionTolerance
		 */
		virtual	real GetSymmetryDetectionTolerance(  ) = 0;

		/**
		 * Get the outward move multiplier, how much the mesh is allowed to grow its silhouette
		 * perimeter @return the current value of OutwardMoveMultiplier
		 */
		virtual	real GetOutwardMoveMultiplier(  ) = 0;

		/**
		 * Gets the material part cutoff percentages array @return the material part cutoff
		 * percentages array<br />Description of IRealArray: IRealArray is the real implementation
		 * of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetMaterialPartCutoffs(  ) = 0;

		/**
		 * Get the UseVertexWeighting value. If set, the reducer will weight the reduction based
		 * on the weights in the "VertexWeighting" vertex field. @return the current value of
		 * the UseVertexWeights bool
		 */
		virtual	bool GetUseVertexWeights(  ) = 0;

		/**
		 * Set the outward move multiplier, how much the mesh is allowed to grow its silhouette
		 * perimeter @param value is the value to which OutwardMoveMultiplier will be set
		 */
		virtual	void SetOutwardMoveMultiplier( real value ) = 0;

		/**
		 * Set the AllowDegenerateTexCoords flag. If true, texture coordinates are allowed to
		 * become degenerate (triangles can have 0 area in texture space).  This may sometimes
		 * look better, but if tangent space normals are used, tangent spaces may become degenerate.
		 * @param value is the bool to which AllowDegenerateTexCoords will be set
		 */
		virtual	void SetAllowDegenerateTexCoords( bool value ) = 0;

		/**
		 * Set the EnablePreprocessing flag.  Preprocessing is the repair stage, so disabling
		 * this means the reductionProcessor will skip the Welding and T-junction steps. Should
		 * only be disabled if the loaded Geometry is guaranteed to have no cracks or un-welded
		 * parts, and if processing speed is of high importance. @param value is the bool to
		 * which EnablePreprocessing will be set
		 */
		virtual	void SetEnablePreprocessing( bool value ) = 0;

		/**
		 * Get the EnablePreprocessing flag. 	 Preprocessing is the repair stage, so disabling
		 * this means the reductionProcessor will skip the Welding and T-junction steps. Should
		 * only be disabled if the loaded Geometry is guaranteed to have no cracks or un-welded
		 * parts, and if processing speed is of high importance. @return the current value of
		 * the EnablePreprocessing bool
		 */
		virtual	bool GetEnablePreprocessing(  ) = 0;

		/**
		 * Get the EnablePostprocessing flag. 	 Postprocessing involved normal recalculation
		 * / normal fix up and setting up the material casting data. Should only be disabled
		 * if processing speed is of high importance. @return the current value of the EnablePostprocessing
		 * bool
		 */
		virtual	bool GetEnablePostprocessing(  ) = 0;

		/**
		 * Set the inward move multiplier, how much the mesh is allowed to shrink its silhouette
		 * perimeter @param value is the value to which InwardMoveMultiplier will be set
		 */
		virtual	void SetInwardMoveMultiplier( real value ) = 0;

		/**
		 * Get the AllowDegenerateTexCoords flag. If true, texture coordinates are allowed to
		 * become degenerate (triangles can have 0 area in texture space).  This may sometimes
		 * look better, but if tangent space normals are used, tangent spaces may become degenerate.
		 * @return the current value of the AllowDegenerateTexCoords bool
		 */
		virtual	bool GetAllowDegenerateTexCoords(  ) = 0;

		/**
		 * Set the KeepSymmetry flag. If set, the reducer will detect symmetric features, and
		 * retain symmetry during processing. Please note that for a geometry to be considered
		 * symmetrical, also the texture coordinates must be mirrored. @param value is the bool
		 * to which KeepSymmetry will be set
		 */
		virtual	void SetKeepSymmetry( bool value ) = 0;

		/**
		 * Get the KeepSymmetry flag. If set, the reducer will detect symmetric features, and
		 * retain symmetry during processing. Please note that for a geometry to be considered
		 * symmetrical, also the texture coordinates must be mirrored. @return the current value
		 * of the KeepSymmetry bool
		 */
		virtual	bool GetKeepSymmetry(  ) = 0;

		/**
		 * Set the AutomaticSymmetryDetection flag. If set, and KeepSymmetry is on, the reducer
		 * will detect any X,Y,Z symmetry plane and will override any user set symmetry plane
		 * with the detected one. If no symmetry is found, KeepSymmetry will be turned off before
		 * reduction. @param value is the bool to which AutomaticSymmetryDetection will be set
		 */
		virtual	void SetUseAutomaticSymmetryDetection( bool value ) = 0;

		/**
		 * Sets if the reducer will be allowed to use DirectX. This flag is recommended to be
		 * enabled unless DirectX specific issues are being experienced @param value is the
		 * value to which AllowDirectX will be set
		 */
		virtual	void SetAllowDirectX( bool value ) = 0;

		/**
		 * Get the AutomaticSymmetryDetection flag. If set, and KeepSymmetry is on, the reducer
		 * will automatically detect and use any X,Y,Z symmetry plane and will override any
		 * user set symmetry plane with the detected one. If no symmetry is found, KeepSymmetry
		 * will be turned off before reduction. @return the current value of the AutomaticSymmetryDetection
		 * bool
		 */
		virtual	bool GetUseAutomaticSymmetryDetection(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IReductionSettings
	 * Settings for the IReductionProcessor class. Handles all the settings for Simplygons
	 * simplification algorithms. The user can tell the reduction processor which features
	 * are important by using the FeatureFlags?parameter, and also the relative importance
	 * of these features using the Set{feature}Importance methods. Also settings for things
	 * like symmetry are set here.
	 */
	typedef CountedPointer<IReductionSettings> spReductionSettings;


	/**
	 * Settings for the normal recalculation 
	 */
	class INormalCalculationSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if INormalCalculationSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("INormalCalculationSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalCalculationSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalCalculationSettings pointer
		 * @return a pointer to the INormalCalculationSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static INormalCalculationSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("INormalCalculationSettings") )
				return static_cast<INormalCalculationSettings*>(ptr);
			return NULL;
			}
		/**
		 * Get HardEdgeAngle. If the angle between two triangles are above this value, the normals
		 * will not be smooth over the edge between those two triangles. Set in degrees. @return
		 * the current value of HardEdgeAngle
		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * Set/Get the RepairInvalidNormals flag If set, normals that are invalid will be replaced.
		 * All others are left intact. Bad normals are those that are either Zero length, or
		 * simply points away from the surface
		 */
		virtual	void SetRepairInvalidNormals( bool value ) = 0;

		/**
		 * Get the ScaleByArea flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the area of the triangle. @return the current value of the
		 * ScaleByArea bool
		 */
		virtual	bool GetScaleByArea(  ) = 0;

		/**
		 * Set HardEdgeAngle. If the angle between two triangles are above this value, the normals
		 * will not be smooth over the edge between those two triangles. Set in degrees. @param
		 * value is the value to which HardEdgeAngle is to be set
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * Set GenerateNormals flag. If set, it will generate new normals for the Geometry,
		 * and if not set, it will keep the normals from the original normal-set (or not add
		 * normals at all if none were present). Please note that if the original geometry contains
		 * normals, the normal repairer will replace invalid  normals even if ReplaceNormals
		 * is set to false. @param value is the value to which the ReplaceNormals bool is to
		 * be set
		 */
		virtual	void SetReplaceNormals( bool value ) = 0;

		/**
		 * Set/Get the RepairInvalidNormals flag If set, normals that are invalid will be replaced.
		 * All others are left intact. Bad normals are those that are either Zero length, or
		 * simply points away from the surface
		 */
		virtual	bool GetRepairInvalidNormals(  ) = 0;

		/**
		 * Set the ScaleByArea flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the area of the triangle. @param value is the value to which
		 * the ScaleByArea bool is to be set
		 */
		virtual	void SetScaleByArea( bool value ) = 0;

		/**
		 * Get the ScaleByAngle flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the angle of the corner at the vertex. @return the current
		 * value of the ScaleByAngle bool
		 */
		virtual	bool GetScaleByAngle(  ) = 0;

		/**
		 * Set the ScaleByAngle flag.  If set, the influence of a triangle normal upon the vertex
		 * normals  is scaled by the angle of the corner at the vertex. @param value is the
		 * value to which the ScaleByAngle bool is to be set
		 */
		virtual	void SetScaleByAngle( bool value ) = 0;

		/**
		 * Get GenerateNormals flag. If set, it will generate new normals for the Geometry,
		 * and if not set, it will keep the normals from the original normal-set (or not add
		 * normals at all if none were present). Please note that if the original geometry contains
		 * normals, the normal repairer will replace invalid  normals even if ReplaceNormals
		 * is set to false. @return the current value of the ReplaceNormals bool
		 */
		virtual	bool GetReplaceNormals(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an INormalCalculationSettings
	 * Settings for the normal recalculation 
	 */
	typedef CountedPointer<INormalCalculationSettings> spNormalCalculationSettings;


	/**
	 * Settings for the Simplygon mapping classes  These settings control the properties
	 * of the mapping image that will be generated in the current simplification processor
	 * (reducer/remesher  etc).   The mapping image will be used when casting a new texture
	 * on the  simplified geometry. In the settings object, the user is able to set  the
	 * dimensions of the image (width/height) as well as whether the LOD should have new
	 * texture coordinates and some parameters for how they  should be generated and all
	 * other settings regarding the mapping image.
	 */
	class IMappingImageSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImageSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMappingImageSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImageSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImageSettings pointer
		 * @return a pointer to the IMappingImageSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMappingImageSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMappingImageSettings") )
				return static_cast<IMappingImageSettings*>(ptr);
			return NULL;
			}
		/**
		 * Set the texture coordinate level used for mapping image and texture generation. Default
		 * is 0. @param value the desired texture coordinate level
		 */
		virtual	void SetTexCoordLevel( rid value ) = 0;

		/**
		 * Get the height of the texture to use. If called with an id, it will get the height
		 * of that specific texture if using multiple mapping image outputs. @return the current
		 * value of Height
		 */
		virtual	unsigned int GetHeight(  ) = 0;

		/**
		 * Set the number of input materials used in the original geometry for mapping to multiple
		 * output materials. This needs to be set before you can set any specific in-out material
		 * mapping.  0 signifies that no in-out material mapping is used, ie. the process will
		 * produce one resulting mapping image. @param value is the number of inputs
		 */
		virtual	void SetInputMaterialCount( unsigned int value ) = 0;

		/**
		 * Get the minimum number of pixels between charts. If called with an id, it will set
		 * the width of that specific texture if using multiple mapping image outputs. @return
		 * the current value of GutterSpace
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

		/**
		 * Get the previously set material mapping for mat_id. @return the currently mapped
		 * output material for InMaterialId. -1 means mapping is not set.
		 */
		virtual	int GetInputOutputMaterialMapping( unsigned int InMaterialId ) = 0;

		/**
		 * Get the number of input materials set earlier. 0 signifies that no in-out material
		 * mapping is used. @return the current value of InputMaterialCount
		 */
		virtual	unsigned int GetInputMaterialCount(  ) = 0;

		/**
		 * Set the minimum number of pixels between charts. If called with an id, it will set
		 * the width of that specific texture if using multiple mapping image outputs. @param
		 * value is the value to which GutterSpace will be set
		 */
		virtual	void SetGutterSpace( unsigned int id , unsigned int value ) = 0;

		/**
		 * The maximum allowed texture stretch. Range 0->1 @param value the desired maximum
		 * allowed texture stretch
		 */
		virtual	void SetMaxStretch( real value ) = 0;

		/**
		 * Set the number of output mapping images that are to be generated. If this is set
		 * to more than 1, the material mapping also needs to be set. @param value is the number
		 * of outputs
		 */
		virtual	void SetOutputMaterialCount( unsigned int value ) = 0;

		/**
		 * Get the width of the texture to use. If called with an id, it will get the width
		 * of that specific texture if using multiple mapping image outputs. @return the current
		 * value of Width
		 */
		virtual	unsigned int GetWidth( unsigned int id ) = 0;

		/**
		 * Sets the GenerateTexCoords flag. If true, generates a new texcoords field at the
		 * position specified by TexCoordLevel. Will be ignored and always generate texcoords
		 * if none are available  in the Geometry, at same time as GenerateMappingImage is enabled.
		 * @param value the desired GenerateTexCoords flag
		 */
		virtual	void SetGenerateTexCoords( bool value ) = 0;

		/**
		 * Get the maximum number of layers in the mapping image. If a remeshed geometry has
		 * a lot of transparent triangles, use a higher  number to be able to find intersections
		 * on the inside of parts of  the geometry. This setting only has effect in the remeshing,
		 * when  running reduction the number of layers is always 1.  @return the current number
		 * of layers in the mapping image
		 */
		virtual	unsigned int GetMaximumLayers(  ) = 0;

		/**
		 * Set/Get the full retexturing flag. If set, all original texture sets are replaced
		 * by the one generated for the mapping image, and the TexCoordLevel value is always
		 * set to 0. This flag has no effect on the remeshing, which always does a full retexturing.
		 * @return the current FullRetexturing flag
		 */
		virtual	bool GetFullRetexturing(  ) = 0;

		/**
		 * Set the full retexturing flag. If set, all original texture sets are replaced by
		 * the one generated for the mapping image, and the TexCoordLevel value is always set
		 * to 0. This flag has no effect on the remeshing, which always does a full retexturing.
		 * @param value the desired FullRetexturing flag
		 */
		virtual	void SetFullRetexturing( bool value ) = 0;

		/**
		 * If set, the charts from original geometry will be scaled relative to corresponding
		 * area in 3D space. @return the current flag
		 */
		virtual	bool GetBaseAtlasOnOriginalUseAreaWeighting(  ) = 0;

		/**
		 * Set the height of the texture to use. If called with an id, it will set the height
		 * of that specific texture if using multiple mapping image outputs. @param value is
		 * the value to which Height will be set
		 */
		virtual	void SetHeight( unsigned int value ) = 0;

		/**
		 * Set the height of the texture to use. If called with an id, it will set the height
		 * of that specific texture if using multiple mapping image outputs. @param value is
		 * the value to which Height will be set
		 */
		virtual	void SetHeight( unsigned int id , unsigned int value ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the  texture sizes to be a power
		 * of 2 @return the current flag
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * Get the minimum number of pixels between charts. If called with an id, it will set
		 * the width of that specific texture if using multiple mapping image outputs. @return
		 * the current value of GutterSpace
		 */
		virtual	unsigned int GetGutterSpace( unsigned int id ) = 0;

		/**
		 * Get the width of the texture to use. If called with an id, it will get the width
		 * of that specific texture if using multiple mapping image outputs. @return the current
		 * value of Width
		 */
		virtual	unsigned int GetWidth(  ) = 0;

		/**
		 * Sets the GenerateTangents flag. If true, generates a new tangent space fields at
		 * position specified by TexCoordLevel, based on the vertex normals and texture coordinates.
		 * Tangent space fields will always be created if missing, and GenerateMappingImage
		 * is enabled. If GenerateTexCoords is enabled, new tangents will always be generated.
		 * @param value the desired GenerateTangents flag
		 */
		virtual	void SetGenerateTangents( bool value ) = 0;

		/**
		 * Set the maximum number of layers in the mapping image. If a remeshed geometry has
		 * a lot of transparent triangles, use a higher  number to be able to find intersections
		 * on the inside of parts of  the geometry. This setting only has effect in the remeshing,
		 * when  running reduction the number of layers is always 1.  @param value the desired
		 * number of layers in the mapping image
		 */
		virtual	void SetMaximumLayers( unsigned int value ) = 0;

		/**
		 * Get the number of output mapping images that are to be generated. @return the current
		 * value of OutputMaterialCount
		 */
		virtual	unsigned int GetOutputMaterialCount(  ) = 0;

		/**
		 * Set the multi-sampling level. Values 1-8 are accepted. If called with an id, it will
		 * set the multi-sampling level of that specific texture if using multiple mapping image
		 * outputs. @param value is the value to which MultiSamplingLevel will be set
		 */
		virtual	void SetMultisamplingLevel( unsigned int value ) = 0;

		/**
		 * Set the minimum number of pixels between charts. If called with an id, it will set
		 * the width of that specific texture if using multiple mapping image outputs. @param
		 * value is the value to which GutterSpace will be set
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * Get the texture coordinate level used for mapping image and texture generation. Default
		 * is 0. @return the current texture coordinate level
		 */
		virtual	rid GetTexCoordLevel(  ) = 0;

		/**
		 * Set the GenerateMappingImage flag. If set, the remesher will create a mapping image,
		 * that maps triangles on the reduced geometry back to triangles on  the original geometry.
		 * The texture is insert into the MappingImage object. The image data will contain two
		 * fields:  <li> <ul> * ReRidArray, "TriangleIds", TupleSize:1, The id of the triangle
		 * </ul> <ul> * ReUnsignedShortArra, "BarycentricCoords", TupleSize:2, Items A & B of
		 * the barycentric coordinate on the triangle.  </ul> </li> The user can control the
		 * size of the mapped texture using the values MappingTextureWidth and MappingTextureHeight
		 * @param value the desired GenerateMappingImage flag
		 */
		virtual	void SetGenerateMappingImage( bool value ) = 0;

		/**
		 * Set a texture dimension length multiplier for the automatic  texture size.  @param
		 * value the desired multiplier
		 */
		virtual	void SetAutomaticTextureSizeMultiplier( real value ) = 0;

		/**
		 * Get the current automatic texture size multiplier. @return the current multiplier
		 */
		virtual	real GetAutomaticTextureSizeMultiplier(  ) = 0;

		/**
		 * If UseVisibilityWeights is enabled, the visibility weights generated with the SgVisibilityHandler
		 * will help determine the  segmentation of the UV charts and their UV area. Visibility
		 * weights have to exist before the mapping image is  generated, for them to be used.
		 * @param value the desired flag
		 */
		virtual	void SetUseVisibilityWeights( bool value ) = 0;

		/**
		 * Gets the GenerateTexCoords flag. If true, generates a new texcoords field at the
		 * position specified by TexCoordLevel. Will be ignored and always generate texcoords
		 * if none are available  in the Geometry, at same time as GenerateMappingImage is enabled.
		 * @return the current GenerateTexCoords flag
		 */
		virtual	bool GetGenerateTexCoords(  ) = 0;

		/**
		 * Set the multi-sampling level. Values 1-8 are accepted. If called with an id, it will
		 * set the multi-sampling level of that specific texture if using multiple mapping image
		 * outputs. @param value is the value to which MultiSamplingLevel will be set
		 */
		virtual	void SetMultisamplingLevel( unsigned int id , unsigned int value ) = 0;

		/**
		 * Get the height of the texture to use. If called with an id, it will get the height
		 * of that specific texture if using multiple mapping image outputs. @return the current
		 * value of Height
		 */
		virtual	unsigned int GetHeight( unsigned int id ) = 0;

		/**
		 * Set the material mapping for mat_id, meaning what material of the generated LOD mat_id
		 * will be baked into. Both InputMaterialCount and OutputMaterialCount need to be set
		 * for this mapping to work, and all original materials need to be mapped to an existing
		 * output id. @param InMaterialId is the input material id @param OutMaterialId is the
		 * output material id the corresponding input is to be mapped to
		 */
		virtual	void SetInputOutputMaterialMapping( unsigned int InMaterialId , unsigned int OutMaterialId ) = 0;

		/**
		 * Set the texture coordinate level to get charts from if BaseAtlasOnOriginalTexCoords
		 * is enabled. Default is 0. @return the current texture coordinate level
		 */
		virtual	rid GetBaseAtlasOnOriginalTexCoordLevel(  ) = 0;

		/**
		 * Get the multi-sampling level. Values 1-8 are accepted. If called with an id, it will
		 * set the multi-sampling level of that specific texture if using multiple mapping image
		 * outputs. @return the current value of MultiSamplingLevel
		 */
		virtual	unsigned int GetMultisamplingLevel( unsigned int id ) = 0;

		/**
		 * Get the multi-sampling level. Values 1-8 are accepted. If called with an id, it will
		 * set the multi-sampling level of that specific texture if using multiple mapping image
		 * outputs. @return the current value of MultiSamplingLevel
		 */
		virtual	unsigned int GetMultisamplingLevel(  ) = 0;

		/**
		 * If UseVisibilityWeights is enabled, the visibility weights generated with the SgVisibilityHandler
		 * will help determine the  segmentation of the UV charts and their UV area. Visibility
		 * weights have to exist before the mapping image is  generated, for them to be used.
		 * @return the current flag
		 */
		virtual	bool GetUseVisibilityWeights(  ) = 0;

		/**
		 * Set the width of the texture to use. If called with an id, it will set the width
		 * of that specific texture if using multiple mapping image outputs. @param value is
		 * the value to which Width will be set
		 */
		virtual	void SetWidth( unsigned int value ) = 0;

		/**
		 * If UseVertexWeights is enabled, the weights help determine the segmentation of the
		 * UV charts and their UV area. @return the current flag
		 */
		virtual	bool GetUseVertexWeights(  ) = 0;

		/**
		 * Set the automatic_texture_size flag. If true, then texture sizes will be computed
		 * for the reduced mesh depending on its pixel size on screen. @param value the desired
		 * flag
		 */
		virtual	void SetAutomaticTextureSize( bool value ) = 0;

		/**
		 * The maximum allowed texture stretch. Range 0->1 @return the current maximum allowed
		 * texture stretch
		 */
		virtual	real GetMaxStretch(  ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the  texture sizes to be a power
		 * of 2 @param value the desired flag
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

		/**
		 * Get the GenerateMappingImage flag. If set, the remesher will create a mapping image,
		 * that maps triangles on the reduced geometry back to triangles on  the original geometry.
		 * The texture is insert into the MappingImage object. The image data will contain two
		 * fields:  <li> <ul> * ReRidArray, "TriangleIds", TupleSize:1, The id of the triangle
		 * </ul> <ul> * ReUnsignedShortArra, "BarycentricCoords", TupleSize:2, Items A & B of
		 * the barycentric coordinate on the triangle.  </ul> </li> The user can control the
		 * size of the mapped texture using the values MappingTextureWidth and MappingTextureHeight
		 * @return the current GenerateMappingImage flag
		 */
		virtual	bool GetGenerateMappingImage(  ) = 0;

		/**
		 * Gets the GenerateTangents flag. If true, generates a new tangent space fields at
		 * position specified by TexCoordLevel, based on the vertex normals and texture coordinates.
		 * Tangent space fields will always be created if missing, and GenerateMappingImage
		 * is enabled. If GenerateTexCoords is enabled, new tangents will always be generated.
		 * @return the current GenerateTangents flag
		 */
		virtual	bool GetGenerateTangents(  ) = 0;

		/**
		 * Set the automatic_texture_size flag. If true, then texture sizes will be computed
		 * for the reduced mesh depending on its pixel size on screen. @return the current flag
		 */
		virtual	bool GetAutomaticTextureSize(  ) = 0;

		/**
		 * If UseVertexWeights is enabled, the weights help determine the segmentation of the
		 * UV charts and their UV area. @param value the desired flag
		 */
		virtual	void SetUseVertexWeights( bool value ) = 0;

		/**
		 * If set, the new texture coords will be based on the original texture coords and the
		 * charts only rotated in multiples of 90 degrees. @param the desired flag
		 */
		virtual	void SetBaseAtlasOnOriginalTexCoords( bool value ) = 0;

		/**
		 * Set the width of the texture to use. If called with an id, it will set the width
		 * of that specific texture if using multiple mapping image outputs. @param value is
		 * the value to which Width will be set
		 */
		virtual	void SetWidth( unsigned int id , unsigned int value ) = 0;

		/**
		 * If set, the new texture coords will be based on the original texture coords and the
		 * charts only rotated in multiples of 90 degrees. @return the current flag
		 */
		virtual	bool GetBaseAtlasOnOriginalTexCoords(  ) = 0;

		/**
		 * Set the texture coordinate level to get charts from if BaseAtlasOnOriginalTexCoords
		 * is enabled. Default is 0. @param value the desired texture coordinate level
		 */
		virtual	void SetBaseAtlasOnOriginalTexCoordLevel( rid value ) = 0;

		/**
		 * If set, the charts from original geometry will be scaled relative to corresponding
		 * area in 3D space. @param the desired flag
		 */
		virtual	void SetBaseAtlasOnOriginalUseAreaWeighting( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMappingImageSettings
	 * Settings for the Simplygon mapping classes  These settings control the properties
	 * of the mapping image that will be generated in the current simplification processor
	 * (reducer/remesher  etc).   The mapping image will be used when casting a new texture
	 * on the  simplified geometry. In the settings object, the user is able to set  the
	 * dimensions of the image (width/height) as well as whether the LOD should have new
	 * texture coordinates and some parameters for how they  should be generated and all
	 * other settings regarding the mapping image.
	 */
	typedef CountedPointer<IMappingImageSettings> spMappingImageSettings;

	class ICameraPath;
	class IGeometryData;

	/**
	 * Visibility settings contains the parameters for how to compute the visibility of
	 * a scene and how to use it, both in the  IReductionProcessor and the IRemeshingProcessor.
	 * The visibility information is computed for each part of the mesh  determined by the
	 * visibility from a collection of cameras contained  in the CameraPath.   The visibility
	 * can be used to guide the reducer and/or texture  coordinates generator (parameterizer)
	 * with the flags UseVisibilityWeightsInReducer respective  UseVisibilityWeightsInTexcoordGenerator.
	 * There is also an option to completely throw away triangles that are deemed not visible,
	 * using the CullOccludedGeometry flag.
	 */
	class IVisibilitySettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IVisibilitySettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IVisibilitySettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IVisibilitySettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IVisibilitySettings pointer
		 * @return a pointer to the IVisibilitySettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IVisibilitySettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IVisibilitySettings") )
				return static_cast<IVisibilitySettings*>(ptr);
			return NULL;
			}
		/**
		 * Sets a camera path with cameras placed on a custom sphere determined by the parameters.
		 * @param fidelity value corresponding to the density of camera points. Should be between
		 * 2-5 @param pitch_angle amount of degrees the sphere should be pitch rotated  @param
		 * jaw_angle amount of degrees the sphere should be jaw rotated  @param coverage_angle
		 * 360?would be entire sphere, 180?would be hemisphere, 0?would be no sphere.
		 */
		virtual	void SetCustomSphereCameraPath( real fidelity , real pitch_angle , real jaw_angle , real coverage_angle ) = 0;

		/**
		 * Sets a default camera path. Cameras are placed uniformly around the model.
		 */
		virtual	void SetDefaultCameraPath(  ) = 0;

		/**
		 * If set to true, visibility weights will be used when generating new texture coordinates.
		 * @return the current UseVisibilityWeightsInTexcoordGenerator value
		 */
		virtual	bool GetUseVisibilityWeightsInTexcoordGenerator(  ) = 0;

		/**
		 * Set how aggressively reducer should handle low visibility weights. @param value Power
		 * of influence (default 1.0).
		 */
		virtual	void SetVisibilityWeightsPower( real value ) = 0;

		/**
		 * If set to true, visibility weights will be used in the reducer. @param UseVisibilityWeightsInReducer
		 * the new UseVisibilityWeightsInReducer value
		 */
		virtual	void SetUseVisibilityWeightsInReducer( bool value ) = 0;

		/**
		 * Occluders are geometries that occlude the scene. @param the geometry that will occlude
		 * the scene.
		 */
		virtual	void AddOccluder( IGeometryData *geom ) = 0;

		/**
		 * Set the camera path to a pre-existing path @param camera_path the camera path to
		 * copy cameras from
		 */
		virtual	void SetCameraPath( ICameraPath *camera_path ) = 0;

		/**
		 * If set to true, visibility weights will be used in the reducer. @return the current
		 * UseVisibilityWeightsInReducer value
		 */
		virtual	bool GetUseVisibilityWeightsInReducer(  ) = 0;

		/**
		 * How aggressively reducer should handle low visibility weights. @return the current
		 * VisibilityWeightsPower value
		 */
		virtual	real GetVisibilityWeightsPower(  ) = 0;

		/**
		 * If set to true, visibility weights will be used when generating new texture coordinates.
		 * @param UseVisibilityWeightsInTexcoordGenerator the new UseVisibilityWeightsInTexcoordGenerator
		 * value
		 */
		virtual	void SetUseVisibilityWeightsInTexcoordGenerator( bool value ) = 0;

		/**
		 * If set to true, geometry that is not visible will be removed. @param CullOccludedGeometry
		 * the new CullOccludedGeometry value
		 */
		virtual	void SetCullOccludedGeometry( bool value ) = 0;

		/**
		 * If set to true, geometry that is not visible will be removed. @return the current
		 * CullOccludedGeometry value
		 */
		virtual	bool GetCullOccludedGeometry(  ) = 0;

		/**
		 * Set the ForceVisibilityCalculation if true, visibility weights will definitely be
		 * computed for the geometry, even if the visibility isn't specifically being used for
		 * reduction/materialLOD/culling according to the VisibilitySettings. @param ForceVisibilityCalculation
		 * the new forceVisibilityCalculation value
		 */
		virtual	void SetForceVisibilityCalculation( bool value ) = 0;

		/**
		 * Get the ForceVisibilityCalculation if true, visibility weights will definitely be
		 * computed for the geometry, even if the visibility isn't specifically being used for
		 * reduction/materialLOD/culling according to the VisibilitySettings. @return the current
		 * ForceVisibilityCalculation value
		 */
		virtual	bool GetForceVisibilityCalculation(  ) = 0;

		/**
		 * Set whether triangles should be regarded visible when viewed from the back. @param
		 * value the desired flag value
		 */
		virtual	void SetIsBackfaceCullingEnabled( bool value ) = 0;

		/**
		 * Get whether triangles should be regarded visible when viewed from the back. @return
		 * the current flag value
		 */
		virtual	bool GetIsBackfaceCullingEnabled(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IVisibilitySettings
	 * Visibility settings contains the parameters for how to compute the visibility of
	 * a scene and how to use it, both in the  IReductionProcessor and the IRemeshingProcessor.
	 * The visibility information is computed for each part of the mesh  determined by the
	 * visibility from a collection of cameras contained  in the CameraPath.   The visibility
	 * can be used to guide the reducer and/or texture  coordinates generator (parameterizer)
	 * with the flags UseVisibilityWeightsInReducer respective  UseVisibilityWeightsInTexcoordGenerator.
	 * There is also an option to completely throw away triangles that are deemed not visible,
	 * using the CullOccludedGeometry flag.
	 */
	typedef CountedPointer<IVisibilitySettings> spVisibilitySettings;

	class ISceneNode;
	class IGeometryData;
	class IMappingImage;
	class IRepairSettings;
	class IReductionSettings;
	class IBoneSettings;
	class INormalCalculationSettings;
	class IMappingImageSettings;
	class IVisibilitySettings;

	/**
	 * IReductionProcessor welds, removes t-junctions, removes double-triangles and reduces
	 * the trianglecount of the Geometry. It also calculates new normals for the reduced
	 * and optimized Geometry.
	 */
	class IReductionProcessor : public IProcessingObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IReductionProcessor is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IReductionProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IReductionProcessor pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IReductionProcessor pointer
		 * @return a pointer to the IReductionProcessor object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IReductionProcessor *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IReductionProcessor") )
				return static_cast<IReductionProcessor*>(ptr);
			return NULL;
			}
		/**
		 * Clears the processing, and resets all internal states.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the morphed geometry data object. This will return NULL if  CreateGeomorphGeometry
		 * isn't set in the ReductionSettings. @return the morphed geometry data that can be
		 * used for smooth LOD switches from the Original Geometry.<br />Description of IGeometryData:
		 * IGeometryData represents a geometric structure  consisting of point data (Vertices)
		 * and topological data (Triangles). IGeometryData may represent a whole geometric object,
		 * but can also be used by streaming data filters, and in this way, only represents
		 * a part of the object. <br><br> Different fields in the Vertices and Triangles fields
		 * data  objects will contain point data and topological data. The standard  naming
		 * convention used in the filters/renderers are as follows: (Case sensitive naming,
		 * other fields may also be present) <br><br> 'Coords' <br> Positional coordinates of
		 * a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0' -
		 * 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetGeomorphGeometry(  ) = 0;

		/**
		 * Returns the max deviation reached for the last processing @return the max deviation
		 * of the last processing
		 */
		virtual	real GetMaxDeviation(  ) = 0;

		/**
		 * The settings for the normal repair process. @return the normal repair settings object
		 * associated with the processor	<br />Description of INormalCalculationSettings: Settings
		 * for the normal recalculation 
		 */
		virtual	CountedPointer<INormalCalculationSettings> GetNormalCalculationSettings(  ) = 0;

		/**
		 * Set the geometry data object to reduce. If SceneRoot is set, this parameter is ignored
		 * by the reducer. @param value is is the geometry data that is to be reduced
		 */
		virtual	void SetGeometry( IGeometryData *value ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  reduction processing. @return the
		 * current top scene node<br />Description of ISceneNode: ISceneNode is the base class
		 * for all scene graph nodes in simplygon. It has relative transformation to its parent,
		 * and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetSceneRoot(  ) = 0;

		/**
		 * The settings for the bone removal process. @return the bone settings object associated
		 * with the processor	<br />Description of IBoneSettings: Settings for the Simplygon
		 * Reduction/Remeshing classes  With the BoneSettings object, the user can setup all
		 * the parameters for how the BoneLOD processor should simplify the links between geometries
		 * and bones.   Bones can be un-linked from the geometry either with a set ratio or
		 * depending on a selected pixel size on screen.
		 */
		virtual	CountedPointer<IBoneSettings> GetBoneSettings(  ) = 0;

		/**
		 * The settings for the reduction process. @return the reduction settings object associated
		 * with the processor	<br />Description of IReductionSettings: Settings for the IReductionProcessor
		 * class. Handles all the settings for Simplygons simplification algorithms. The user
		 * can tell the reduction processor which features are important by using the FeatureFlags?
		 * parameter, and also the relative importance of these features using the Set{feature}Importance
		 * methods. Also settings for things like symmetry are set here.
		 */
		virtual	CountedPointer<IReductionSettings> GetReductionSettings(  ) = 0;

		/**
		 * Get the MappingImage object that is generated if  MappingImageSettings::GenerateMappingImage
		 * is set. The object is of type IMappingImage. If called with an id, it will fetch
		 * that specific mapping image if using multi-material output. A new object is generated
		 * for each call to RunProcessing(). @return the generated mappingimage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  reduction processing. @param value
		 * is the node that is to be set as the top scene node
		 */
		virtual	void SetSceneRoot( ISceneNode *value ) = 0;

		/**
		 * Get the geometry data object to reduce. If SceneRoot is set, this parameter is ignored
		 * by the reducer. @return the geometry data currently setup for reduction<br />Description
		 * of IGeometryData: IGeometryData represents a geometric structure  consisting of point
		 * data (Vertices) and topological data (Triangles). IGeometryData may represent a whole
		 * geometric object, but can also be used by streaming data filters, and in this way,
		 * only represents a part of the object. <br><br> Different fields in the Vertices and
		 * Triangles fields data  objects will contain point data and topological data. The
		 * standard  naming convention used in the filters/renderers are as follows: (Case sensitive
		 * naming, other fields may also be present) <br><br> 'Coords' <br> Positional coordinates
		 * of a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0'
		 * - 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetGeometry(  ) = 0;

		/**
		 * Get the MappingImage object that is generated if  MappingImageSettings::GenerateMappingImage
		 * is set. The object is of type IMappingImage. If called with an id, it will fetch
		 * that specific mapping image if using multi-material output. A new object is generated
		 * for each call to RunProcessing(). @return the generated mappingimage<br />Description
		 * of IMappingImage: IMappingImage stores the mapping between a processed geometry and
		 * the source geometry it is based on. The mapping image object also stores multisampling
		 * settings. It can be used to cast information from the original geometry to the processed
		 * geometry, such as surface transfer or calculating normal maps. See IMaterialCaster
		 * and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage( rid OutputMaterialId ) = 0;

		/**
		 * The settings for the repair process. @return the repair settings object associated
		 * with the processor	<br />Description of IRepairSettings: Settings for handling unconnected
		 * parts and unwanted gaps in the geometry. It consists of two parts, Welding and T-junction
		 * removal. Welding merges vertices that are closer than a set distance from each other.
		 * T-junction removal finds open edges that lies within a set distance from other open
		 * edges, but without matching vertices. It then splits those triangles into smaller,
		 * matching triangles and fuses them together.
		 */
		virtual	CountedPointer<IRepairSettings> GetRepairSettings(  ) = 0;

		/**
		 * The settings for the image mapping process. @return the mappingimage settings object
		 * associated with the processor	<br />Description of IMappingImageSettings: Settings
		 * for the Simplygon mapping classes  These settings control the properties of the mapping
		 * image that will be generated in the current simplification processor (reducer/remesher
		 * etc).   The mapping image will be used when casting a new texture on the  simplified
		 * geometry. In the settings object, the user is able to set  the dimensions of the
		 * image (width/height) as well as whether the LOD should have new texture coordinates
		 * and some parameters for how they  should be generated and all other settings regarding
		 * the mapping image.
		 */
		virtual	CountedPointer<IMappingImageSettings> GetMappingImageSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. @return the visibility settings object
		 * associated with the processor	<br />Description of IVisibilitySettings:  Visibility
		 * settings contains the parameters for how to compute the visibility of a scene and
		 * how to use it, both in the  IReductionProcessor and the IRemeshingProcessor.  The
		 * visibility information is computed for each part of the mesh  determined by the visibility
		 * from a collection of cameras contained  in the CameraPath.   The visibility can be
		 * used to guide the reducer and/or texture  coordinates generator (parameterizer) with
		 * the flags UseVisibilityWeightsInReducer respective  UseVisibilityWeightsInTexcoordGenerator.
		 * There is also an option to completely throw away triangles that are deemed not visible,
		 * using the CullOccludedGeometry flag.
		 */
		virtual	CountedPointer<IVisibilitySettings> GetVisibilitySettings(  ) = 0;

		/**
		 * Runs the reduction process on the geometry.
		 */
		virtual	void RunProcessing(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IReductionProcessor
	 * IReductionProcessor welds, removes t-junctions, removes double-triangles and reduces
	 * the trianglecount of the Geometry. It also calculates new normals for the reduced
	 * and optimized Geometry.
	 */
	typedef CountedPointer<IReductionProcessor> spReductionProcessor;


	/**
	 * Remeshing settings for the IRemeshingProcessor class. The remesher creates a completely
	 * new lightweight mesh from the input geometry, and is intended to be viewed from the
	 * outside. Here you will set the OnScreenSize (larger numbers means a more detailed
	 * mesh), merge distance (which fills in smaller gaps) and a cutting plane (where all
	 * parts of the input mesh on the far side of that plane will be culled). 
	 */
	class IRemeshingSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRemeshingSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingSettings pointer
		 * @return a pointer to the IRemeshingSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRemeshingSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRemeshingSettings") )
				return static_cast<IRemeshingSettings*>(ptr);
			return NULL;
			}
		/**
		 * Get the TransferNormals flag. If set, the vertex normals channel will be sampled
		 * from the original mesh @return the current value of the TransferNormals bool
		 */
		virtual	bool GetTransferNormals(  ) = 0;

		/**
		 * Get the TransferColors flag. If set, vertex color channels will be sampled from the
		 * original mesh @return the current value of the TransferColors bool 
		 */
		virtual	bool GetTransferColors(  ) = 0;

		/**
		 * The maximum size in pixels of a generated triangle Any value from 5 pixels and above
		 * is allowed. @param value is the value MaxTriangleSize will be set to
		 */
		virtual	void SetMaxTriangleSize( unsigned int value ) = 0;

		/**
		 * Set/Get the normal hard angle cutoff (in radians) @param value is the value to which
		 * HardEdgeAngle will be set
		 */
		virtual	void SetHardEdgeAngle( real value ) = 0;

		/**
		 * The maximum size in pixels of a generated triangle Any value from 5 pixels and above
		 * is allowed. @return the current value of MaxTriangleSize
		 */
		virtual	unsigned int GetMaxTriangleSize(  ) = 0;

		/**
		 * Set to true to cap the mesh with a ground plane  @param value is the bool UseGroundPlane
		 * will be set to
		 */
		virtual	void SetUseGroundPlane( bool value ) = 0;

		/**
		 * Set the TransferColors flag. If set, vertex color channels will be sampled from the
		 * original mesh @param value is the bool to which TransferColors will be set
		 */
		virtual	void SetTransferColors( bool value ) = 0;

		/**
		 * Gets if the remesher currently allows usage of DirectX This flag is recommended to
		 * be enabled unless DirectX specific issues are being experienced @return the current
		 * value of AllowDirectX
		 */
		virtual	bool GetAllowDirectX(  ) = 0;

		/**
		 * Get the level  @param value is the value to which GroundPlaneLevel will be set All
		 * parts of the mesh below the GroundPlaneLevel will be culled in the generated mesh.
		 * @return the current value of GroundPlaneLevel 
		 */
		virtual	real GetGroundPlaneLevel(  ) = 0;

		/**
		 * Set the surface transfer mode, options are SG_SURFACETRANSFER_FAST and SG_SURFACETRANSFER_ACCURATE
		 * @param value is the new surface transfer mode
		 */
		virtual	void SetSurfaceTransferMode( rid value ) = 0;

		/**
		 * Get the axis index for the ground plane <ul><li>0 - X Axis (YZ plane)</li><li>1 -
		 * Y Axis (XZ plane)</li><li>2-Z Axis (XY plane)</li></ul> @return the current index
		 * of the ground plane axis.
		 */
		virtual	rid GetGroundPlaneAxisIndex(  ) = 0;

		/**
		 * Set/Get the normal hard angle cutoff (in radians) @return the current value of HardEdgeAngle
		 * 		 */
		virtual	real GetHardEdgeAngle(  ) = 0;

		/**
		 * Set the on-screen rendering size of the geometry. Allowed values are in the range
		 * 40 to 4000 pixels. @param value is the value OnScreenSize will be set to
		 */
		virtual	void SetOnScreenSize( unsigned int value ) = 0;

		/**
		 * Get the surface transfer mode, options are SG_SURFACETRANSFER_FAST and SG_SURFACETRANSFER_ACCURATE
		 * @return the current surface transfer mode
		 */
		virtual	rid GetSurfaceTransferMode(  ) = 0;

		/**
		 * Get the on-screen merge distance in pixels. @return the current value of MergeDistance
		 */
		virtual	unsigned int GetMergeDistance(  ) = 0;

		/**
		 * Set the on-screen merge distance in pixels. Smaller cavities will be removed. This
		 * will be capped to the on-screen size of the remeshing. @param value is the value
		 * MergeDistance will be set to
		 */
		virtual	void SetMergeDistance( unsigned int value ) = 0;

		/**
		 * Get the on-screen rendering size of the geometry. Allowed values are in the range
		 * 40 to 4000 pixels. @return the current value of OnScreenSize
		 */
		virtual	unsigned int GetOnScreenSize(  ) = 0;

		/**
		 * Set the TransferNormals flag. If set, the vertex normals channel will be sampled
		 * from the original mesh @param value is the value to which TransferNormals will be
		 * set
		 */
		virtual	void SetTransferNormals( bool value ) = 0;

		/**
		 * Get the current value of UseGroundPlane @return the current value of UseGroundPlane
		 */
		virtual	bool GetUseGroundPlane(  ) = 0;

		/**
		 * Sets if the remesher will be allowed to use DirectX. This flag is recommended to
		 * be enabled unless DirectX specific issues are being experienced @param value is the
		 * value to which AllowDirectX will be set
		 */
		virtual	void SetAllowDirectX( bool value ) = 0;

		/**
		 * Set the axis index for the ground plane <ul><li>0 - X Axis (YZ plane)</li><li>1 -
		 * Y Axis (XZ plane)</li><li>2-Z Axis (XY plane)</li></ul> @param value is the index
		 * of the axis. 
		 */
		virtual	void SetGroundPlaneAxisIndex( rid value ) = 0;

		/**
		 * The parameter that decides which side of the GroundPlane that will be culled. Set
		 * to true to use negative halfspace for model, and reject the positive halfspace. @param
		 * value is the bool to which GroundPlaneNegativeHalfspace will be set
		 */
		virtual	void SetGroundPlaneNegativeHalfspace( bool value ) = 0;

		/**
		 * Get the value of GroundPlaneNegativeHalfspace bool for the remesher. This is the
		 * parameter that decides which side of the GroundPlane that will be culled. @return
		 * the current value of the GroundPlaneNegativeHalfspace bool
		 */
		virtual	bool GetGroundPlaneNegativeHalfspace(  ) = 0;

		/**
		 * Set the level  @param value is the value to which GroundPlaneLevel will be set All
		 * parts of the mesh below the GroundPlaneLevel will be culled in the generated mesh.
		 */
		virtual	void SetGroundPlaneLevel( real value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRemeshingSettings
	 * Remeshing settings for the IRemeshingProcessor class. The remesher creates a completely
	 * new lightweight mesh from the input geometry, and is intended to be viewed from the
	 * outside. Here you will set the OnScreenSize (larger numbers means a more detailed
	 * mesh), merge distance (which fills in smaller gaps) and a cutting plane (where all
	 * parts of the input mesh on the far side of that plane will be culled). 
	 */
	typedef CountedPointer<IRemeshingSettings> spRemeshingSettings;

	class ISceneNode;
	class IMappingImage;
	class IRemeshingSettings;
	class IMappingImageSettings;
	class IBoneSettings;
	class IVisibilitySettings;

	/**
	 * IRemeshingProcessor creates a new geometry that is based on the input geometry, but
	 * that is topologically based on the size of the input geometry rendered at a specific
	 * screen size, and allowed pixel error. The remesher will on demand also add texture
	 * coordinates and a mapping texture to the output remeshed geometry. The geometry 
	 * that is to be remeshed can be defined either using an in-memory  geometry data object,
	 * or using a geometry file placed on disk, the latter being the preferred method, if
	 * the source geometry is very large as it can be swapped in/out of memory as needed.
	 */
	class IRemeshingProcessor : public IProcessingObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IRemeshingProcessor is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IRemeshingProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IRemeshingProcessor pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IRemeshingProcessor pointer
		 * @return a pointer to the IRemeshingProcessor object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IRemeshingProcessor *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IRemeshingProcessor") )
				return static_cast<IRemeshingProcessor*>(ptr);
			return NULL;
			}
		/**
		 * Get the top scene node of a scene tree used for  reduction processing. All mesh nodes
		 * in the whole scene  tree will be replaced by one proxy mesh. @return the current
		 * scene root node<br />Description of ISceneNode: ISceneNode is the base class for
		 * all scene graph nodes in simplygon. It has relative transformation to its parent,
		 * and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetSceneRoot(  ) = 0;

		/**
		 * Runs the remeshing of the geometry. 
		 */
		virtual	void RemeshGeometry(  ) = 0;

		/**
		 * Clears the processing, and resets all internal states.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the MappingImage object that is generated if  MappingImageSettings::GenerateMappingImage
		 * is set. The object is of type IMappingImage. A new object is generated for each call
		 * to RunProcessing(). @return the current mappingimage<br />Description of IMappingImage:
		 * IMappingImage stores the mapping between a processed geometry and the source geometry
		 * it is based on. The mapping image object also stores multisampling settings. It can
		 * be used to cast information from the original geometry to the processed geometry,
		 * such as surface transfer or calculating normal maps. See IMaterialCaster and subclasses
		 * for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  reduction processing. All mesh nodes
		 * in the whole scene  tree will be replaced by one proxy mesh. @param value is the
		 * scene node to which SceneRoot will be set
		 */
		virtual	void SetSceneRoot( ISceneNode *value ) = 0;

		/**
		 * The settings for the remeshing process. @return the remeshing settings object<br
		 * />Description of IRemeshingSettings: Remeshing settings for the IRemeshingProcessor
		 * class. The remesher creates a completely new lightweight mesh from the input geometry,
		 * and is intended to be viewed from the outside. Here you will set the OnScreenSize
		 * (larger numbers means a more detailed mesh), merge distance (which fills in smaller
		 * gaps) and a cutting plane (where all parts of the input mesh on the far side of that
		 * plane will be culled). 
		 */
		virtual	CountedPointer<IRemeshingSettings> GetRemeshingSettings(  ) = 0;

		/**
		 * The settings for the image mapping process. @return the mapping image settings object<br
		 * />Description of IMappingImageSettings: Settings for the Simplygon mapping classes
		 * These settings control the properties of the mapping image that will be generated
		 * in the current simplification processor (reducer/remesher  etc).   The mapping image
		 * will be used when casting a new texture on the  simplified geometry. In the settings
		 * object, the user is able to set  the dimensions of the image (width/height) as well
		 * as whether the LOD should have new texture coordinates and some parameters for how
		 * they  should be generated and all other settings regarding the mapping image.
		 */
		virtual	CountedPointer<IMappingImageSettings> GetMappingImageSettings(  ) = 0;

		/**
		 * The settings for the bone removal process. @return the bone settings object<br />Description
		 * of IBoneSettings: Settings for the Simplygon Reduction/Remeshing classes  With the
		 * BoneSettings object, the user can setup all the parameters for how the BoneLOD processor
		 * should simplify the links between geometries  and bones.   Bones can be un-linked
		 * from the geometry either with a set ratio or  depending on a selected pixel size
		 * on screen.
		 */
		virtual	CountedPointer<IBoneSettings> GetBoneSettings(  ) = 0;

		/**
		 * The settings for handling visibility weights. @return the visibility settings object
		 * associated with the processor	<br />Description of IVisibilitySettings:  Visibility
		 * settings contains the parameters for how to compute the visibility of a scene and
		 * how to use it, both in the  IReductionProcessor and the IRemeshingProcessor.  The
		 * visibility information is computed for each part of the mesh  determined by the visibility
		 * from a collection of cameras contained  in the CameraPath.   The visibility can be
		 * used to guide the reducer and/or texture  coordinates generator (parameterizer) with
		 * the flags UseVisibilityWeightsInReducer respective  UseVisibilityWeightsInTexcoordGenerator.
		 * There is also an option to completely throw away triangles that are deemed not visible,
		 * using the CullOccludedGeometry flag.
		 */
		virtual	CountedPointer<IVisibilitySettings> GetVisibilitySettings(  ) = 0;

		/**
		 * Runs the remeshing of the geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IRemeshingProcessor
	 * IRemeshingProcessor creates a new geometry that is based on the input geometry, but
	 * that is topologically based on the size of the input geometry rendered at a specific
	 * screen size, and allowed pixel error. The remesher will on demand also add texture
	 * coordinates and a mapping texture to the output remeshed geometry. The geometry 
	 * that is to be remeshed can be defined either using an in-memory  geometry data object,
	 * or using a geometry file placed on disk, the latter being the preferred method, if
	 * the source geometry is very large as it can be swapped in/out of memory as needed.
	 */
	typedef CountedPointer<IRemeshingProcessor> spRemeshingProcessor;

	class ISceneNode;
	class IMaterialTable;
	class ISceneBoneTable;
	class ITextureTable;
	class IMatrix4x4;
	class IValueArray;

	/**
	 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
	 * with materials, textures, etc. to describe a full scene. 
	 */
	class IScene : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IScene is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IScene",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IScene pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IScene pointer
		 * @return a pointer to the IScene object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IScene *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IScene") )
				return static_cast<IScene*>(ptr);
			return NULL;
			}
		/**
		 * Checks if a custom field is present in the scene @param name is the name of the field
		 * to be checked @return true is the field exists, false otherwise
		 */
		virtual	bool HasCustomField( const char * name ) = 0;

		/**
		 * Removes all bones in the scene that are not  linked by any ISceneMesh's geometry
		 * data. Note that the removal only removes leaf nodes in the scene.
		 */
		virtual	void RemoveUnlinkedBones(  ) = 0;

		/**
		 * Evaluates the global transformation of the specified node at a specific time. EvaluateDefaultGlobalTransformation
		 * is used to evaluate the default transformation, regardless of node animation. @param
		 * node is the node to evaluate @param global_transform is the transformation matrix
		 * that receives the global transformation 
		 */
		virtual	void EvaluateDefaultGlobalTransformation( ISceneNode *node , IMatrix4x4 *global_transform ) = 0;

		/**
		 * Get the root node of the scene. @return the root node<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetRootNode(  ) = 0;

		/**
		 * Will remove mesh nodes that consist of empty geometry. The node  transformation will
		 * be added to its children's transformation. If the root node is a sceneMesh with empty
		 * geometry, it will be replaced with a generic sceneNode having the same transformation.
		 * 		 */
		virtual	void Compact(  ) = 0;

		/**
		 * Gets a node defined by an id. @param node_id is the id of the node to get @return
		 * the node associated with the id<br />Description of ISceneNode: ISceneNode is the
		 * base class for all scene graph nodes in simplygon. It has relative transformation
		 * to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetNodeByID( const char * node_id ) = 0;

		/**
		 * Get the material table of the scene @return the material table<br />Description of
		 * IMaterialTable: IMaterialTable keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetMaterialTable(  ) = 0;

		/**
		 * Get the bone table of the scene @return the bone table<br />Description of ITextureTable:
		 * ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetTextureTable(  ) = 0;

		/**
		 * Show a debug window with the scene graph tree. This debug method returns when the
		 * window is closed.
		 */
		virtual	void ShowSceneDebugWindow(  ) = 0;

		/**
		 * Get the bone table of the scene @return the bone table<br />Description of ISceneBoneTable:
		 * ISceneBoneTable keeps information on bones used while rendering.
		 */
		virtual	CountedPointer<ISceneBoneTable> GetBoneTable(  ) = 0;

		/**
		 * Saves a scene to file @param path is the path to which the scene file will be saved
		 * @return true on success, false if file could not be written to
		 */
		virtual	bool SaveToFile( const char * path ) = 0;

		/**
		 * Clears the whole scene and releases all items in the graph.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Loads a scene from file @param path is the path of the scene file @return true on
		 * success, false if file was not found
		 */
		virtual	bool LoadFromFile( const char * path ) = 0;

		/**
		 * Adds/Removes/Gets a custom data field. @param name is the name of the field to be
		 * fetched @return an array containing the field data<br />Description of IValueArray:
		 * ReValueArray adds methods to arrays to generically  add, set and get tuples, through
		 * real values.
		 */
		virtual	CountedPointer<IValueArray> GetCustomField( const char * name ) = 0;

		/**
		 * Removes a custom data field. @param name is the name of the field to be removed
		 */
		virtual	void RemoveCustomField( const char * name ) = 0;

		/**
		 * Get the inferior (minimum) extent of the scene @return the minimum extent of the
		 * scene@param dest_param a pointer to the destination memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Get the superior (maximum) extent of the scene @return the maximum extent of the
		 * scene@param dest_param a pointer to the destination memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * Get the scene radius. @return the radius of the scene
		 */
		virtual	real GetRadius(  ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the whole  scene. If the node tree contains
		 * no geometric data, or all data is hidden, the bounding box is not calculated, and
		 * the method returns false. @returns true if the calculation succeeded
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * Gets a node defined by a path. Please note that the  path must contain names for
		 * each level to be able to find the specified node. @param path the path of the node
		 * to get @return the node associated with path<br />Description of ISceneNode: ISceneNode
		 * is the base class for all scene graph nodes in simplygon. It has relative transformation
		 * to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetNodeFromPath( const char * path ) = 0;

		/**
		 * Gets a node defined by an id from the specified node tree. @param node_id is the
		 * id of the node to get @return the node associated with the id<br />Description of
		 * ISceneNode: ISceneNode is the base class for all scene graph nodes in simplygon.
		 * It has relative transformation to its parent, and functions to add children to the
		 * node.
		 */
		virtual	CountedPointer<ISceneNode> GetNodeByID( const char * node_id , ISceneNode *node ) = 0;

		/**
		 * Adds a custom data field. To be able to add a field, it must have a name that does
		 * not  conflict with the existing custom fields. @param base_type is the is the type
		 * of the field to be added @param name is the name of the new field @param tuple_size
		 * is the tuple size of the new field<br />Description of IValueArray: ReValueArray
		 * adds methods to arrays to generically  add, set and get tuples, through real values.
		 */
		virtual	CountedPointer<IValueArray> AddCustomField( rid base_type , const char * name , unsigned int tuple_size ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IScene
	 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
	 * with materials, textures, etc. to describe a full scene. 
	 */
	typedef CountedPointer<IScene> spScene;

	class IScene;
	class ISceneNode;
	class IMatrix4x4;

	/**
	 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
	 * transformation to its parent, and functions to add children to the node.
	 */
	class ISceneNode : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneNode",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneNode pointer
		 * @return a pointer to the ISceneNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneNode") )
				return static_cast<ISceneNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @return the value of the isFrozen bool
		 */
		virtual	bool GetIsFrozen(  ) = 0;

		/**
		 * Get the superior (maximum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * Get the parent node of this node @return the parent node<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetParent(  ) = 0;

		/**
		 * Sets the unique id for this node. @param nid is the node id of type string 
		 */
		virtual	void SetNid( const char * value ) = 0;

		/**
		 * Set the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @param value is a string the name is to
		 * be set to
		 */
		virtual	void SetOriginalName( const char * value ) = 0;

		/**
		 * Get the scene object of the node @return the scene object<br />Description of IScene:
		 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
		 * with materials, textures, etc. to describe a full scene. 
		 */
		virtual	CountedPointer<IScene> GetScene(  ) = 0;

		/**
		 * Evaluates the default global transformation of the node, regardless of node animation.
		 * @param global_transform the transformation matrix that receives the global transformation
		 * 		 */
		virtual	void EvaluateDefaultGlobalTransformation( IMatrix4x4 *global_transform ) = 0;

		/**
		 * Adds a child node to this node. If the child is already a child of another node,
		 * it is removed from this node @param child the child object.
		 */
		virtual	void AddChild( ISceneNode *child ) = 0;

		/**
		 * Removes all children of this node
		 */
		virtual	void RemoveChildren(  ) = 0;

		/**
		 * Removes this node from its parent.
		 */
		virtual	void RemoveFromParent(  ) = 0;

		/**
		 * Get the path to this node in the scene. Please note that only paths where each node
		 * has a name can be used to get to the node using the path. @return the path to this
		 * node in the scene
		 */
		virtual	rstring GetPath(  ) = 0;

		/**
		 * Get the number of direct children of this node @return the number of direct children
		 * of this node
		 */
		virtual	unsigned int GetChildCount(  ) = 0;

		/**
		 * Get a pointer to the i:th child of this node @param index the local index of the
		 * child (0->GetChildCount()-1)<br />Description of ISceneNode: ISceneNode is the base
		 * class for all scene graph nodes in simplygon. It has relative transformation to its
		 * parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetChild( rid index ) = 0;

		/**
		 * Set the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @param value
		 * is the bool that IsModified is to be set to
		 */
		virtual	void SetIsModified( bool value ) = 0;

		/**
		 * Finds the first child that has the name @param name the name of the child to look
		 * for<br />Description of ISceneNode: ISceneNode is the base class for all scene graph
		 * nodes in simplygon. It has relative transformation to its parent, and functions to
		 * add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> FindNamedChild( const char * name ) = 0;

		/**
		 * Removes a child from the node. @param child the child to be removed
		 */
		virtual	void RemoveChild( ISceneNode *child ) = 0;

		/**
		 * Get the relative transformation of this node @return the relative transformation
		 * as a 4x4 matrix<br />Description of IMatrix4x4: IMatrix4x4 is used to represent and
		 * manipulate 4x4  transformation matrices, which can be either standard matrices, or
		 * homogeneous 4x4 matrices used to transform 3D homogeneous coordinates  [x y z w].
		 * The transformations are defined in row-major order.
		 */
		virtual	CountedPointer<IMatrix4x4> GetRelativeTransform(  ) = 0;

		/**
		 * Set the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @param value is the bool that isFrozen is to be set to
		 */
		virtual	void SetIsFrozen( bool value ) = 0;

		/**
		 * Returns true if the node has the specified child @param child the child node to look
		 * for @return true if child exists in the scene, otherwise false
		 */
		virtual	bool HasChild( ISceneNode *child ) = 0;

		/**
		 * Get the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @return the value of the OriginalName string
		 */
		virtual	rstring GetOriginalName(  ) = 0;

		/**
		 * Deep copies this node tree (this node and all the descendants of this node) and returns
		 * the copy top node. Please note that the copy is not added to any scene, and can be
		 * added anywhere.  @return a new copy of the ISceneNode<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> NewCopy(  ) = 0;

		/**
		 * Clones this node tree (this node and all the descendants of this node) and returns
		 * the cloned top node. Please note that the copy is not added to any scene, and can
		 * be added anywhere. Also note that the clone shares all data pointers with the original
		 * nodes, such as geometry data objects.  @return a new clone of the ISceneNode<br />Description
		 * of ISceneNode: ISceneNode is the base class for all scene graph nodes in simplygon.
		 * It has relative transformation to its parent, and functions to add children to the
		 * node.
		 */
		virtual	CountedPointer<ISceneNode> NewClone(  ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the  node and all its children. If the
		 * node tree contains no geometric data, or all data is hidden, the bounding box is
		 * not calcluated, and the method returns false. @returns true if the calculation succeeded
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @param value is the bool that
		 * isVisible is to be set to
		 */
		virtual	void SetIsVisible( bool value ) = 0;

		/**
		 * Get the inferior (minimum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @return the value of the isVisible
		 * bool
		 */
		virtual	bool GetIsVisible(  ) = 0;

		/**
		 * Get the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @return the
		 * value of the IsModified bool
		 */
		virtual	bool GetIsModified(  ) = 0;

		/**
		 * Gets the unique id for this node. @return the GUID for this node
		 */
		virtual	rstring GetNid(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneNode
	 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
	 * transformation to its parent, and functions to add children to the node.
	 */
	typedef CountedPointer<ISceneNode> spSceneNode;

	class ISceneNode;

	/**
	 * ISceneNodeCollection holds a number of ISceneNode  objects. The objects can be looked
	 * up by their names (if they have  been named through IObject::SetName() ).
	 */
	class ISceneNodeCollection : public IObjectCollection
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneNodeCollection is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneNodeCollection",type)==0 )
				return true;
			return IObjectCollection::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneNodeCollection pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneNodeCollection pointer
		 * @return a pointer to the ISceneNodeCollection object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneNodeCollection *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneNodeCollection") )
				return static_cast<ISceneNodeCollection*>(ptr);
			return NULL;
			}
		/**
		 * Finds a named object. @param name is the name of the searched for object @return
		 * the found node, or NULL if no mathing node is found<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> FindSceneNode( const char * name ) = 0;

		/**
		 * Gets the object the handle is referring to. @param objhandle is the handle of the
		 * node @return the node associated with the handle<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetSceneNode( rhandle objhandle ) = 0;

		/**
		 * Adds an object to the collection, as AddObject, but sorts the object into the collection
		 * based on its name. @param obj is the object that is to be added to the collection
		 * @param ascending determines the sorting order @return the handle of the added object
		 * in the collection
		 */
		virtual	rhandle AddObjectSorted( IObject *obj , bool ascending ) = 0;

		/**
		 * Returns the handle of the i:th item @param index is the index of an object in the
		 * collection @return the handle of the object with the relevant index
		 */
		virtual	rhandle GetItem( unsigned int index ) = 0;

		/**
		 * Removes all items from the collection.
		 */
		virtual	void RemoveAllItems(  ) = 0;

		/**
		 * Finds a named object in the collection. The first object  with this name is returned.
		 * The search is case-sensitive. @param name is the name of an object in the collection
		 * @return the object with the relevant name, or NULL if none is found
		 */
		virtual	CountedPointer<IObject> FindObject( const char * name ) = 0;

		/**
		 * Returns the object of the next item. @param phandle is the handle of a node in the
		 * collection @return the node after phandle<br />Description of ISceneNode: ISceneNode
		 * is the base class for all scene graph nodes in simplygon. It has relative transformation
		 * to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetNextItemAsSceneNode( rhandle *phandle ) = 0;

		/**
		 * Returns true if the object is in the collection @param pobj is an arbitrary node
		 * @return true if pobj is in the current collection, false otherwise
		 */
		virtual	bool IsSceneNodeInCollection( ISceneNode *pobj ) = 0;

		/**
		 * Returns the handle to the next item in the collection. Use  GetFirstItem and this
		 * method to step through the collection. If the return is NULL, the end of the collection
		 * has been reached. @param objhandle is the handle of an object i @return the handle
		 * of the object i+1
		 */
		virtual	rhandle GetNextItem( rhandle objhandle ) = 0;

		/**
		 * Returns the object of the i:th item @param index is the index of an object in the
		 * collection @return the object with the relevant index
		 */
		virtual	CountedPointer<IObject> GetItemAsObject( unsigned int index ) = 0;

		/**
		 * Get the number of items in the collection. @return the number of items in the collection
		 */
		virtual	unsigned int GetItemCount(  ) = 0;

		/**
		 * Returns true if the object is in the collection @param pobj is the object to be checked
		 * for @return true if the collection contains pobj, false otherwise
		 */
		virtual	bool IsObjectInCollection( IObject *pobj ) = 0;

		/**
		 * Adds an object to the collection. The handle refers to the object until the object
		 * is removed from the collection again. @param obj is the object that is to be added
		 * to the collection @return the handle of the added object in the collection
		 */
		virtual	rhandle AddObject( IObject *obj ) = 0;

		/**
		 * Returns true if the item is in the collection @param objhandle is the handle of an
		 * object to be checked for @return true if the collection contains the object, false
		 * otherwise
		 */
		virtual	bool IsItemInCollection( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurrence of the object is
		 * removed.  @param pobj is the node to be be removed
		 */
		virtual	void RemoveSceneNode( ISceneNode *pobj ) = 0;

		/**
		 * Returns the start of the collection. The handle returned refers to the first object
		 * in the collection. If the handle is  NULL, then the collection is empty. @return
		 * the first item in collection, or NULL if collection is empty
		 */
		virtual	rhandle GetFirstItem(  ) = 0;

		/**
		 * Adds an object object to the collection. The handle refers  to the object until it
		 * is removed from the collection again. @param obj is the node that is to be added
		 * to the collection @return the handle of the added node in the collection
		 */
		virtual	rhandle AddSceneNode( ISceneNode *obj ) = 0;

		/**
		 * Gets the object the handle is referring to. @param objhandle is the handle of an
		 * object in the collection @return the object associated with the handle
		 */
		virtual	CountedPointer<IObject> GetItemsObject( rhandle objhandle ) = 0;

		/**
		 * Removes an item from the collection. The handle returned is the first item after
		 * this item that is in the collection. If the return is NULL, the item was the last
		 * item in the collection. Warning! The handle is invalid after the removal of the object.
		 * @param objhandle is the handle of the object that is to be removed @return the handle
		 * to the item following the removed one, or NULL if collection is now empty
		 */
		virtual	rhandle RemoveItem( rhandle objhandle ) = 0;

		/**
		 * Removes an object from the collection. Only the first occurance of the object is
		 * removed from the collection.  @param pobj is the object that is to be removed
		 */
		virtual	void RemoveObject( IObject *pobj ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneNodeCollection
	 * ISceneNodeCollection holds a number of ISceneNode  objects. The objects can be looked
	 * up by their names (if they have  been named through IObject::SetName() ).
	 */
	typedef CountedPointer<ISceneNodeCollection> spSceneNodeCollection;

	class IScene;
	class ISceneNode;
	class IMatrix4x4;
	class IGeometryData;

	/**
	 * ISceneMesh is the mesh node in the simplygon scene graph
	 */
	class ISceneMesh : public ISceneNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneMesh is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneMesh",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneMesh pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneMesh pointer
		 * @return a pointer to the ISceneMesh object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneMesh *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneMesh") )
				return static_cast<ISceneMesh*>(ptr);
			return NULL;
			}
		/**
		 * Deep copies this node tree (this node and all the descendants of this node) and returns
		 * the copy top node. Please note that the copy is not added to any scene, and can be
		 * added anywhere.  @return a new copy of the ISceneNode<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> NewCopy(  ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @return the value of the isVisible
		 * bool
		 */
		virtual	bool GetIsVisible(  ) = 0;

		/**
		 * Evaluates the default global transformation of the node, regardless of node animation.
		 * @param global_transform the transformation matrix that receives the global transformation
		 * 		 */
		virtual	void EvaluateDefaultGlobalTransformation( IMatrix4x4 *global_transform ) = 0;

		/**
		 * Get the scene object of the node @return the scene object<br />Description of IScene:
		 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
		 * with materials, textures, etc. to describe a full scene. 
		 */
		virtual	CountedPointer<IScene> GetScene(  ) = 0;

		/**
		 * Removes this node from its parent.
		 */
		virtual	void RemoveFromParent(  ) = 0;

		/**
		 * Get the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @return the
		 * value of the IsModified bool
		 */
		virtual	bool GetIsModified(  ) = 0;

		/**
		 * Set the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @param value is a string the name is to
		 * be set to
		 */
		virtual	void SetOriginalName( const char * value ) = 0;

		/**
		 * Get the geometry data of the mesh node @return the geometrydata associated with the
		 * scene mesh<br />Description of IGeometryData: IGeometryData represents a geometric
		 * structure  consisting of point data (Vertices) and topological data (Triangles).
		 * IGeometryData may represent a whole geometric object, but can also be used by streaming
		 * data filters, and in this way, only represents a part of the object. <br><br> Different
		 * fields in the Vertices and Triangles fields data  objects will contain point data
		 * and topological data. The standard  naming convention used in the filters/renderers
		 * are as follows: (Case sensitive naming, other fields may also be present) <br><br>
		 * 'Coords' <br> Positional coordinates of a vertex, expressed with a 3-component real
		 * field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br> Texture coordinates of a
		 * vertex, expressed with a 2 components real field. By convention, the existing fields
		 * must be sequential, and  must start with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal
		 * vector for the vertex,	expressed  with a 3-component real field, a  normalized (XYZ)
		 * vector. <br><br> 'VertexIds'	 <br> The id of the primitive's current vertex.  This
		 * field is present even if the  vertex data	is directly specified in the  primitive's
		 * data, to specify topology. The field is of type rid. <br><br> 'MaterialIds' <br>
		 * The material of the primitive.  The field is of type rid. <br><br> The 'Coords' and
		 * 'VertexIds' fields always exist in the object, but the other fields are optional.
		 * Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetGeometry(  ) = 0;

		/**
		 * Sets the unique id for this node. @param nid is the node id of type string 
		 */
		virtual	void SetNid( const char * value ) = 0;

		/**
		 * Gets the unique id for this node. @return the GUID for this node
		 */
		virtual	rstring GetNid(  ) = 0;

		/**
		 * Set the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @param value is the bool that isFrozen is to be set to
		 */
		virtual	void SetIsFrozen( bool value ) = 0;

		/**
		 * Get the parent node of this node @return the parent node<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetParent(  ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @param value is the bool that
		 * isVisible is to be set to
		 */
		virtual	void SetIsVisible( bool value ) = 0;

		/**
		 * Get the superior (maximum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * Returns true if the node has the specified child @param child the child node to look
		 * for @return true if child exists in the scene, otherwise false
		 */
		virtual	bool HasChild( ISceneNode *child ) = 0;

		/**
		 * Removes a child from the node. @param child the child to be removed
		 */
		virtual	void RemoveChild( ISceneNode *child ) = 0;

		/**
		 * Get the inferior (minimum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Get the number of direct children of this node @return the number of direct children
		 * of this node
		 */
		virtual	unsigned int GetChildCount(  ) = 0;

		/**
		 * Get a pointer to the i:th child of this node @param index the local index of the
		 * child (0->GetChildCount()-1)<br />Description of ISceneNode: ISceneNode is the base
		 * class for all scene graph nodes in simplygon. It has relative transformation to its
		 * parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetChild( rid index ) = 0;

		/**
		 * Finds the first child that has the name @param name the name of the child to look
		 * for<br />Description of ISceneNode: ISceneNode is the base class for all scene graph
		 * nodes in simplygon. It has relative transformation to its parent, and functions to
		 * add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> FindNamedChild( const char * name ) = 0;

		/**
		 * Removes all children of this node
		 */
		virtual	void RemoveChildren(  ) = 0;

		/**
		 * Get the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @return the value of the isFrozen bool
		 */
		virtual	bool GetIsFrozen(  ) = 0;

		/**
		 * Adds a child node to this node. If the child is already a child of another node,
		 * it is removed from this node @param child the child object.
		 */
		virtual	void AddChild( ISceneNode *child ) = 0;

		/**
		 * Clones this node tree (this node and all the descendants of this node) and returns
		 * the cloned top node. Please note that the copy is not added to any scene, and can
		 * be added anywhere. Also note that the clone shares all data pointers with the original
		 * nodes, such as geometry data objects.  @return a new clone of the ISceneNode<br />Description
		 * of ISceneNode: ISceneNode is the base class for all scene graph nodes in simplygon.
		 * It has relative transformation to its parent, and functions to add children to the
		 * node.
		 */
		virtual	CountedPointer<ISceneNode> NewClone(  ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the  node and all its children. If the
		 * node tree contains no geometric data, or all data is hidden, the bounding box is
		 * not calcluated, and the method returns false. @returns true if the calculation succeeded
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * Get the path to this node in the scene. Please note that only paths where each node
		 * has a name can be used to get to the node using the path. @return the path to this
		 * node in the scene
		 */
		virtual	rstring GetPath(  ) = 0;

		/**
		 * Set the geometry data of the mesh node @param value is the geometry that is to be
		 * set
		 */
		virtual	void SetGeometry( IGeometryData *value ) = 0;

		/**
		 * Get the relative transformation of this node @return the relative transformation
		 * as a 4x4 matrix<br />Description of IMatrix4x4: IMatrix4x4 is used to represent and
		 * manipulate 4x4  transformation matrices, which can be either standard matrices, or
		 * homogeneous 4x4 matrices used to transform 3D homogeneous coordinates  [x y z w].
		 * The transformations are defined in row-major order.
		 */
		virtual	CountedPointer<IMatrix4x4> GetRelativeTransform(  ) = 0;

		/**
		 * Get the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @return the value of the OriginalName string
		 */
		virtual	rstring GetOriginalName(  ) = 0;

		/**
		 * Set the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @param value
		 * is the bool that IsModified is to be set to
		 */
		virtual	void SetIsModified( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneMesh
	 * ISceneMesh is the mesh node in the simplygon scene graph
	 */
	typedef CountedPointer<ISceneMesh> spSceneMesh;

	class IScene;
	class ISceneNode;
	class IMatrix4x4;
	class IRealArray;

	/**
	 * ISceneLodGroup is a LOD grouping for the scene graph
	 */
	class ISceneLodGroup : public ISceneNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneLodGroup is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneLodGroup",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneLodGroup pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneLodGroup pointer
		 * @return a pointer to the ISceneLodGroup object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneLodGroup *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneLodGroup") )
				return static_cast<ISceneLodGroup*>(ptr);
			return NULL;
			}
		/**
		 * Get the superior (maximum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * Removes this node from its parent.
		 */
		virtual	void RemoveFromParent(  ) = 0;

		/**
		 * Set the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @param value
		 * is the bool that IsModified is to be set to
		 */
		virtual	void SetIsModified( bool value ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @return the value of the isVisible
		 * bool
		 */
		virtual	bool GetIsVisible(  ) = 0;

		/**
		 * Returns the child node to use for rendering based on the distance parameter and the
		 * current threshold values. @param distance @return the LOD with the thresholds that
		 * contain distance<br />Description of ISceneNode: ISceneNode is the base class for
		 * all scene graph nodes in simplygon. It has relative transformation to its parent,
		 * and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetLodForDistance( real distance ) = 0;

		/**
		 * Get the scene object of the node @return the scene object<br />Description of IScene:
		 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
		 * with materials, textures, etc. to describe a full scene. 
		 */
		virtual	CountedPointer<IScene> GetScene(  ) = 0;

		/**
		 * Evaluates the default global transformation of the node, regardless of node animation.
		 * @param global_transform the transformation matrix that receives the global transformation
		 * 		 */
		virtual	void EvaluateDefaultGlobalTransformation( IMatrix4x4 *global_transform ) = 0;

		/**
		 * Removes all children of this node
		 */
		virtual	void RemoveChildren(  ) = 0;

		/**
		 * Returns true if the node has the specified child @param child the child node to look
		 * for @return true if child exists in the scene, otherwise false
		 */
		virtual	bool HasChild( ISceneNode *child ) = 0;

		/**
		 * Get the relative transformation of this node @return the relative transformation
		 * as a 4x4 matrix<br />Description of IMatrix4x4: IMatrix4x4 is used to represent and
		 * manipulate 4x4  transformation matrices, which can be either standard matrices, or
		 * homogeneous 4x4 matrices used to transform 3D homogeneous coordinates  [x y z w].
		 * The transformations are defined in row-major order.
		 */
		virtual	CountedPointer<IMatrix4x4> GetRelativeTransform(  ) = 0;

		/**
		 * Get the number of direct children of this node @return the number of direct children
		 * of this node
		 */
		virtual	unsigned int GetChildCount(  ) = 0;

		/**
		 * Get the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @return the value of the isFrozen bool
		 */
		virtual	bool GetIsFrozen(  ) = 0;

		/**
		 * Sets the unique id for this node. @param nid is the node id of type string 
		 */
		virtual	void SetNid( const char * value ) = 0;

		/**
		 * Get the inferior (minimum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Deep copies this node tree (this node and all the descendants of this node) and returns
		 * the copy top node. Please note that the copy is not added to any scene, and can be
		 * added anywhere.  @return a new copy of the ISceneNode<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> NewCopy(  ) = 0;

		/**
		 * Set the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @param value is a string the name is to
		 * be set to
		 */
		virtual	void SetOriginalName( const char * value ) = 0;

		/**
		 * Get a pointer to the i:th child of this node @param index the local index of the
		 * child (0->GetChildCount()-1)<br />Description of ISceneNode: ISceneNode is the base
		 * class for all scene graph nodes in simplygon. It has relative transformation to its
		 * parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetChild( rid index ) = 0;

		/**
		 * Get the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @return the value of the OriginalName string
		 */
		virtual	rstring GetOriginalName(  ) = 0;

		/**
		 * Gets the unique id for this node. @return the GUID for this node
		 */
		virtual	rstring GetNid(  ) = 0;

		/**
		 * Get the parent node of this node @return the parent node<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetParent(  ) = 0;

		/**
		 * Finds the first child that has the name @param name the name of the child to look
		 * for<br />Description of ISceneNode: ISceneNode is the base class for all scene graph
		 * nodes in simplygon. It has relative transformation to its parent, and functions to
		 * add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> FindNamedChild( const char * name ) = 0;

		/**
		 * Get the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @return the
		 * value of the IsModified bool
		 */
		virtual	bool GetIsModified(  ) = 0;

		/**
		 * Adds a child node to this node. If the child is already a child of another node,
		 * it is removed from this node @param child the child object.
		 */
		virtual	void AddChild( ISceneNode *child ) = 0;

		/**
		 * Removes a child from the node. @param child the child to be removed
		 */
		virtual	void RemoveChild( ISceneNode *child ) = 0;

		/**
		 * Clones this node tree (this node and all the descendants of this node) and returns
		 * the cloned top node. Please note that the copy is not added to any scene, and can
		 * be added anywhere. Also note that the clone shares all data pointers with the original
		 * nodes, such as geometry data objects.  @return a new clone of the ISceneNode<br />Description
		 * of ISceneNode: ISceneNode is the base class for all scene graph nodes in simplygon.
		 * It has relative transformation to its parent, and functions to add children to the
		 * node.
		 */
		virtual	CountedPointer<ISceneNode> NewClone(  ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the  node and all its children. If the
		 * node tree contains no geometric data, or all data is hidden, the bounding box is
		 * not calcluated, and the method returns false. @returns true if the calculation succeeded
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * Get the path to this node in the scene. Please note that only paths where each node
		 * has a name can be used to get to the node using the path. @return the path to this
		 * node in the scene
		 */
		virtual	rstring GetPath(  ) = 0;

		/**
		 * Gets the threshold distances associated with the LODs of the LOD group.  @return
		 * the thresholds of the LODs as a realarray<br />Description of IRealArray: IRealArray
		 * is the real implementation of IValueArray. See IValueArray for a description.
		 */
		virtual	CountedPointer<IRealArray> GetThresholds(  ) = 0;

		/**
		 * Set the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @param value is the bool that isFrozen is to be set to
		 */
		virtual	void SetIsFrozen( bool value ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @param value is the bool that
		 * isVisible is to be set to
		 */
		virtual	void SetIsVisible( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneLodGroup
	 * ISceneLodGroup is a LOD grouping for the scene graph
	 */
	typedef CountedPointer<ISceneLodGroup> spSceneLodGroup;

	class IScene;
	class ISceneNode;
	class IMatrix4x4;
	class IRidArray;

	/**
	 * ISceneBone is the bone node in the simplygon scene graph
	 */
	class ISceneBone : public ISceneNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneBone is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneBone",type)==0 )
				return true;
			return ISceneNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneBone pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneBone pointer
		 * @return a pointer to the ISceneBone object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneBone *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneBone") )
				return static_cast<ISceneBone*>(ptr);
			return NULL;
			}
		/**
		 * Removes a child from the node. @param child the child to be removed
		 */
		virtual	void RemoveChild( ISceneNode *child ) = 0;

		/**
		 * If set, then this bone will be forced to be removed in the BoneLOD process. UNLESS
		 * the LockFromBoneLOD flag is true. @param value is the bool to which the ForceBoneRemoval
		 * flag will be set
		 */
		virtual	void SetForceBoneRemoval( bool value ) = 0;

		/**
		 * Get the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @return the
		 * value of the IsModified bool
		 */
		virtual	bool GetIsModified(  ) = 0;

		/**
		 * Set the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @param value is a string the name is to
		 * be set to
		 */
		virtual	void SetOriginalName( const char * value ) = 0;

		/**
		 * Get the parent node of this node @return the parent node<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetParent(  ) = 0;

		/**
		 * Get the OriginalName parameter which can be used to specify  the original name of
		 * a node, for debugging of merging purposes.  This parameter is not copied or cloned,
		 * and is not used internally by Simplygon. @return the value of the OriginalName string
		 */
		virtual	rstring GetOriginalName(  ) = 0;

		/**
		 * Get the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @return the value of the isFrozen bool
		 */
		virtual	bool GetIsFrozen(  ) = 0;

		/**
		 * Looks through the hierarchy and fetches the previous BoneNode. If none is found,
		 * this is a Root-Bone-Node. -1 means it has no parent, otherwise, the ID is the parent
		 * ID. @return the id of the parent bone, or -1 if no parent exists
		 */
		virtual	rid GetParentBone(  ) = 0;

		/**
		 * Get the path to this node in the scene. Please note that only paths where each node
		 * has a name can be used to get to the node using the path. @return the path to this
		 * node in the scene
		 */
		virtual	rstring GetPath(  ) = 0;

		/**
		 * Sets the unique id for this node. @param nid is the node id of type string 
		 */
		virtual	void SetNid( const char * value ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @return the value of the isVisible
		 * bool
		 */
		virtual	bool GetIsVisible(  ) = 0;

		/**
		 * Calculates the axis-aligned bounding box of the  node and all its children. If the
		 * node tree contains no geometric data, or all data is hidden, the bounding box is
		 * not calcluated, and the method returns false. @returns true if the calculation succeeded
		 */
		virtual	bool CalculateExtents(  ) = 0;

		/**
		 * Returns true if the node has the specified child @param child the child node to look
		 * for @return true if child exists in the scene, otherwise false
		 */
		virtual	bool HasChild( ISceneNode *child ) = 0;

		/**
		 * Deep copies this node tree (this node and all the descendants of this node) and returns
		 * the copy top node. Please note that the copy is not added to any scene, and can be
		 * added anywhere.  @return a new copy of the ISceneNode<br />Description of ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> NewCopy(  ) = 0;

		/**
		 * Set the IsFrozen flag. If set, the node will not be modified by processing modules.
		 * @param value is the bool that isFrozen is to be set to
		 */
		virtual	void SetIsFrozen( bool value ) = 0;

		/**
		 * Finds the first child that has the name @param name the name of the child to look
		 * for<br />Description of ISceneNode: ISceneNode is the base class for all scene graph
		 * nodes in simplygon. It has relative transformation to its parent, and functions to
		 * add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> FindNamedChild( const char * name ) = 0;

		/**
		 * Get the IsVisible flag. If set, the node is visible. @param value is the bool that
		 * isVisible is to be set to
		 */
		virtual	void SetIsVisible( bool value ) = 0;

		/**
		 * Set the IsModified flag. If set, the node is new, copied, or modified by processing
		 * modules. This can be useful to track modifications in the scene graph. @param value
		 * is the bool that IsModified is to be set to
		 */
		virtual	void SetIsModified( bool value ) = 0;

		/**
		 * Get the BoneId @return the id of the current scene bone
		 */
		virtual	rid GetBoneId(  ) = 0;

		/**
		 * Get a pointer to the i:th child of this node @param index the local index of the
		 * child (0->GetChildCount()-1)<br />Description of ISceneNode: ISceneNode is the base
		 * class for all scene graph nodes in simplygon. It has relative transformation to its
		 * parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetChild( rid index ) = 0;

		/**
		 * Removes this node from its parent.
		 */
		virtual	void RemoveFromParent(  ) = 0;

		/**
		 * Adds a child node to this node. If the child is already a child of another node,
		 * it is removed from this node @param child the child object.
		 */
		virtual	void AddChild( ISceneNode *child ) = 0;

		/**
		 * If set, then this bone will be forced to be removed in the BoneLOD process. UNLESS
		 * the LockFromBoneLOD flag is true. @return the current value of the ForceBoneRemoval
		 * bool
		 */
		virtual	bool GetForceBoneRemoval(  ) = 0;

		/**
		 * Gets the unique id for this node. @return the GUID for this node
		 */
		virtual	rstring GetNid(  ) = 0;

		/**
		 * If set, then this bone will be locked, and cant be removed in the BoneLod process.
		 * @return the current value of the LockFromBoneLOD bool
		 */
		virtual	bool GetLockFromBoneLOD(  ) = 0;

		/**
		 * Evaluates the default global transformation of the node, regardless of node animation.
		 * @param global_transform the transformation matrix that receives the global transformation
		 * 		 */
		virtual	void EvaluateDefaultGlobalTransformation( IMatrix4x4 *global_transform ) = 0;

		/**
		 * Get the relative transformation of this node @return the relative transformation
		 * as a 4x4 matrix<br />Description of IMatrix4x4: IMatrix4x4 is used to represent and
		 * manipulate 4x4  transformation matrices, which can be either standard matrices, or
		 * homogeneous 4x4 matrices used to transform 3D homogeneous coordinates  [x y z w].
		 * The transformations are defined in row-major order.
		 */
		virtual	CountedPointer<IMatrix4x4> GetRelativeTransform(  ) = 0;

		/**
		 * Get the scene object of the node @return the scene object<br />Description of IScene:
		 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
		 * with materials, textures, etc. to describe a full scene. 
		 */
		virtual	CountedPointer<IScene> GetScene(  ) = 0;

		/**
		 * Get the inferior (minimum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetInf( real dest_param[3] ) = 0;

		/**
		 * Looks through the sub-tree and collects the IDs of the bones found. @param child_bones
		 * is the array to which the ids of found child bones will be written
		 */
		virtual	void CollectAllChildBones( IRidArray *child_bones ) = 0;

		/**
		 * Get the superior (maximum) extent of the node@param dest_param a pointer to the destination
		 * memory area
		 */
		virtual	void GetSup( real dest_param[3] ) = 0;

		/**
		 * Get the number of direct children of this node @return the number of direct children
		 * of this node
		 */
		virtual	unsigned int GetChildCount(  ) = 0;

		/**
		 * Clones this node tree (this node and all the descendants of this node) and returns
		 * the cloned top node. Please note that the copy is not added to any scene, and can
		 * be added anywhere. Also note that the clone shares all data pointers with the original
		 * nodes, such as geometry data objects.  @return a new clone of the ISceneNode<br />Description
		 * of ISceneNode: ISceneNode is the base class for all scene graph nodes in simplygon.
		 * It has relative transformation to its parent, and functions to add children to the
		 * node.
		 */
		virtual	CountedPointer<ISceneNode> NewClone(  ) = 0;

		/**
		 * Removes all children of this node
		 */
		virtual	void RemoveChildren(  ) = 0;

		/**
		 * If set, then this bone will be locked, and cant be removed in the BoneLod process.
		 * @param value is the bool to which the LockFromBoneLOD flag will be set
		 */
		virtual	void SetLockFromBoneLOD( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneBone
	 * ISceneBone is the bone node in the simplygon scene graph
	 */
	typedef CountedPointer<ISceneBone> spSceneBone;

	class ISceneBone;

	/**
	 * ISceneBoneTable keeps information on bones used while rendering.
	 */
	class ISceneBoneTable : public ITable
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneBoneTable is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneBoneTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneBoneTable pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneBoneTable pointer
		 * @return a pointer to the ISceneBoneTable object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneBoneTable *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneBoneTable") )
				return static_cast<ISceneBoneTable*>(ptr);
			return NULL;
			}
		/**
		 * Returns the i:th item, using the id of the item @param id is the id of the requested
		 * object @return the found object
		 */
		virtual	CountedPointer<IObject> GetItem( rid id ) = 0;

		/**
		 * Removes an item, and invalidates the id. The id will not point at a valid item, until
		 * Clear is called and new items are added up until the id. @param id the id of the
		 * object that should be removed
		 */
		virtual	void RemoveItem( rid id ) = 0;

		/**
		 * Gets the number of item id:s in the table. If an item has been removed, using RemoveItem,
		 * the id is still  counted in this method. GetIdsCount also equals the id that will
		 * be applied to the next item added to the table. @return the itemcount of the table
		 */
		virtual	unsigned int GetItemsCount(  ) = 0;

		/**
		 * Adds a bone to the table. The returned value is  the id of the bone within the table.
		 * @param bone is the scenebone to be added @return the id of the added bone within
		 * the table
		 */
		virtual	rid AddBone( ISceneBone *bone ) = 0;

		/**
		 * Finds the id of an item in the table, using the name. If multiple items have the
		 * same name, the first will be returned. If no item was found, the return will be -1.
		 * @param name is the string that is to be searched for @return the id of the found
		 * object, or -1 if no match was found
		 */
		virtual	rid FindItemId( const char * name ) = 0;

		/**
		 * Returns the number of bones in the table @return the number of bones in the table
		 */
		virtual	unsigned int GetBonesCount(  ) = 0;

		/**
		 * Sets an item in the table. The id must exist in the table. @param id is the id that
		 * is to be set @param item is the object set to the id 
		 */
		virtual	void SetItem( rid id , IObject *item ) = 0;

		/**
		 * Clears the table, and removes all items. If AddItem is called after Clear, the item
		 * ids will start over from 0
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Removes a bone. If GetBone is called with the bone id, the value returned will be
		 * NULL. @param id is the id of the bone that is to be removed
		 */
		virtual	void RemoveBone( rid id ) = 0;

		/**
		 * Finds a named item in the table. If multiple items  have the same name, the first
		 * will be returned. If no item  was found, the return will be NULL. @param name is
		 * the string that is to be searched for @return the matching object, or NULL if no
		 * match was found
		 */
		virtual	CountedPointer<IObject> FindItem( const char * name ) = 0;

		/**
		 * Finds a bone in the table, using the bone name. If multiple bones have the same name,
		 * the first will be returned. If the bone was not found, the return will be NULL. @param
		 * name is the string to be searched for @return the first matching bone, or NULL if
		 * no matches are found<br />Description of ISceneBone: ISceneBone is the bone node
		 * in the simplygon scene graph
		 */
		virtual	CountedPointer<ISceneBone> FindBone( const char * name ) = 0;

		/**
		 * Returns the i:th bone, using the id of the bone @param id is the id of the wanted
		 * bone @return the bone corresponding to the id<br />Description of ISceneBone: ISceneBone
		 * is the bone node in the simplygon scene graph
		 */
		virtual	CountedPointer<ISceneBone> GetBone( rid id ) = 0;

		/**
		 * Finds the id of a bone in the table, using the bone name. If multiple bones have
		 * the same name, the first will be returned. If the bone was not found, the return
		 * will be -1. @param name is the string to be searched for @return the id of the first
		 * matching bone, or -1 if no matches are found
		 */
		virtual	rid FindBoneId( const char * name ) = 0;

		/**
		 * Adds an item to the table. The returned value is  the id of the item within the table,
		 * which can be used to retrieve the item using GetItem().  @param item is the item
		 * that is to be added to the table @return the id of the added item in the table
		 */
		virtual	rid AddItem( IObject *item ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneBoneTable
	 * ISceneBoneTable keeps information on bones used while rendering.
	 */
	typedef CountedPointer<ISceneBoneTable> spSceneBoneTable;

	class IImageData;

	/**
	 * IMaterial keeps information on materials used while rendering.
	 */
	class ITexture : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ITexture is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ITexture",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITexture pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITexture pointer
		 * @return a pointer to the ITexture object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ITexture *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ITexture") )
				return static_cast<ITexture*>(ptr);
			return NULL;
			}
		/**
		 * Get the file path of the texture.  @returns the texture file name
		 */
		virtual	rstring GetFilePath(  ) = 0;

		/**
		 * Set the file path of the texture.  @param texture_filename the texture file name
		 */
		virtual	void SetFilePath( const char * value ) = 0;

		/**
		 * Set a named texture image data. If this is defined, it will be used instead of the
		 * texture file defined in SetFilePath() @param image the image object
		 */
		virtual	void SetImageData( IImageData *value ) = 0;

		/**
		 * Get a named texture image data. If this is defined, it will be used instead of the
		 * texture file defined in SetFilePath() @returns the texture object<br />Description
		 * of IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetImageData(  ) = 0;

		/**
		 * Changes the prefix path (drive, directory) in the texture, with the new one, if the
		 * current path matches the current_path_prefix.  This method is useful when external
		 * textures are placed in a specific folder, which needs to be moved @param current_path_prefix
		 * the current prefix path, either relative or absolute @param new_path_prefix the new
		 * prefix path
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ITexture
	 * IMaterial keeps information on materials used while rendering.
	 */
	typedef CountedPointer<ITexture> spTexture;

	class ITexture;

	/**
	 * ITextureTable keeps information on textures used while rendering.
	 */
	class ITextureTable : public ITable
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ITextureTable is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ITextureTable",type)==0 )
				return true;
			return ITable::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ITextureTable pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ITextureTable pointer
		 * @return a pointer to the ITextureTable object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ITextureTable *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ITextureTable") )
				return static_cast<ITextureTable*>(ptr);
			return NULL;
			}
		/**
		 * Returns the i:th texture, using the id of the texture @param id the id of the texture
		 * in the table @return the the texture in the table<br />Description of ITexture: IMaterial
		 * keeps information on materials used while rendering.
		 */
		virtual	CountedPointer<ITexture> GetTexture( rid id ) = 0;

		/**
		 * Sets a texture in the table.  @param id the id of the texture in the table @param
		 * texture the texture to set into the table
		 */
		virtual	void SetTexture( rid id , ITexture *texture ) = 0;

		/**
		 * Finds the id of an item in the table, using the name. If multiple items have the
		 * same name, the first will be returned. If no item was found, the return will be -1.
		 * @param name is the string that is to be searched for @return the id of the found
		 * object, or -1 if no match was found
		 */
		virtual	rid FindItemId( const char * name ) = 0;

		/**
		 * Removes a texture. If GetTexture is called with the texture id, the value returned
		 * will be NULL. @param id the id of the texture in the table
		 */
		virtual	void RemoveTexture( rid id ) = 0;

		/**
		 * Finds a named item in the table. If multiple items  have the same name, the first
		 * will be returned. If no item  was found, the return will be NULL. @param name is
		 * the string that is to be searched for @return the matching object, or NULL if no
		 * match was found
		 */
		virtual	CountedPointer<IObject> FindItem( const char * name ) = 0;

		/**
		 * Returns the number of textures in the table
		 */
		virtual	unsigned int GetTexturesCount(  ) = 0;

		/**
		 * Sets an item in the table. The id must exist in the table. @param id is the id that
		 * is to be set @param item is the object set to the id 
		 */
		virtual	void SetItem( rid id , IObject *item ) = 0;

		/**
		 * Returns the i:th item, using the id of the item @param id is the id of the requested
		 * object @return the found object
		 */
		virtual	CountedPointer<IObject> GetItem( rid id ) = 0;

		/**
		 * Removes an item, and invalidates the id. The id will not point at a valid item, until
		 * Clear is called and new items are added up until the id. @param id the id of the
		 * object that should be removed
		 */
		virtual	void RemoveItem( rid id ) = 0;

		/**
		 * Changes the prefix path (drive, directory) of all matching texture paths in all the
		 * textures in the table, with the new one.  This method is useful when external textures
		 * are placed in a specific folder, which needs to be moved @param current_path_prefix
		 * the current prefix path, either relative or absolute @param new_path_prefix the new
		 * prefix path		
		 */
		virtual	void ChangeTexturePrefixPath( const char * current_path_prefix , const char * new_path_prefix ) = 0;

		/**
		 * Clears the table, and removes all items. If AddItem is called after Clear, the item
		 * ids will start over from 0
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Gets the number of item id:s in the table. If an item has been removed, using RemoveItem,
		 * the id is still  counted in this method. GetIdsCount also equals the id that will
		 * be applied to the next item added to the table. @return the itemcount of the table
		 */
		virtual	unsigned int GetItemsCount(  ) = 0;

		/**
		 * Adds an item to the table. The returned value is  the id of the item within the table,
		 * which can be used to retrieve the item using GetItem().  @param item is the item
		 * that is to be added to the table @return the id of the added item in the table
		 */
		virtual	rid AddItem( IObject *item ) = 0;

		/**
		 * Adds a texture to the table. The returned value is  the id of the texture within
		 * the table. @param texture the texture to add into the table @return the texture id
		 * of the texture in the table
		 */
		virtual	rid AddTexture( ITexture *texture ) = 0;

		/**
		 * Finds a texture in the table, using the texture name. If multiple textures have the
		 * same name, the first will be returned. If the texture was not found, the return will
		 * be NULL. @param name the texture name to look for @return the texture, if found,
		 * NULL otherwise<br />Description of ITexture: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<ITexture> FindTexture( const char * name ) = 0;

		/**
		 * Finds the id of a texture in the table, using the texture name. If multiple textures
		 * have the same name, the first will be returned. If the texture was not found, the
		 * return will be -1. @param name the texture name to look for @return the texture id
		 * if found, -1 otherwise
		 */
		virtual	rid FindTextureId( const char * name ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ITextureTable
	 * ITextureTable keeps information on textures used while rendering.
	 */
	typedef CountedPointer<ITextureTable> spTextureTable;

	class IImageData;

	/**
	 * Class for loading image data from different file formats.
	 */
	class IImageDataImporter : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IImageDataImporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IImageDataImporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageDataImporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageDataImporter pointer
		 * @return a pointer to the IImageDataImporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IImageDataImporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IImageDataImporter") )
				return static_cast<IImageDataImporter*>(ptr);
			return NULL;
			}
		/**
		 * Set MaxHeight. If set to a value above 0, the image that is higher will be rescaled
		 * to MaxHeight. @param value the desired MaxHeight
		 */
		virtual	void SetMaxHeight( unsigned int value ) = 0;

		/**
		 * Set OnlyHeader. If set to true only gets header information from the  image, and
		 * does not load the actual file into memory. @param value the desired OnlyHeader
		 */
		virtual	void SetOnlyHeader( bool value ) = 0;

		/**
		 * Set/Get MaxWidth. If set to a value above 0, the image that is wider will be rescaled
		 * to MaxWidth. @param value the desired MaxWidth
		 */
		virtual	void SetMaxWidth( unsigned int value ) = 0;

		/**
		 * Close any open file or stream, release any allocated data.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * After RunImport(), returns the NumberOfChannels (1, 3, 4) in the source image. @return
		 * the current NumberOfChannels
		 */
		virtual	unsigned int GetNumberOfChannels(  ) = 0;

		/**
		 * Get CapToPowerOfTwo. If set, the width and height of the loaded image will be capped
		 * to the closest power of two below the size of the image. @return the current CapToPowerOfTwo
		 * flag
		 */
		virtual	bool GetCapToPowerOfTwo(  ) = 0;

		/**
		 * Set the main import file path. This must always be set.  @param value the desired
		 * main import file path
		 */
		virtual	void SetImportFilePath( const char * value ) = 0;

		/**
		 * Get the main import file path. This must always be set.  @return the main import
		 * file path
		 */
		virtual	rstring GetImportFilePath(  ) = 0;

		/**
		 * Get MaxWidth. If set to a value above 0, the image that is wider will be rescaled
		 * to MaxWidth. @return the current MaxWidth
		 */
		virtual	unsigned int GetMaxWidth(  ) = 0;

		/**
		 * Runs the import. Note that all parameters must be setup before importing.
		 */
		virtual	bool RunImport(  ) = 0;

		/**
		 * Get MaxHeight. If set to a value above 0, the image that is higher will be rescaled
		 * to MaxHeight. @return the current MaxHeight
		 */
		virtual	unsigned int GetMaxHeight(  ) = 0;

		/**
		 * After RunImport(), returns the BitsPerPixel (8bpp-64bpp). If divided by NumberOfChannels,
		 * will give the number of bits per channel. @return the current BitsPerPixel
		 */
		virtual	unsigned int GetBitsPerPixel(  ) = 0;

		/**
		 * Set the override file extension. This is specified including the dot, eg ".tga" @param
		 * value the desired override file extension
		 */
		virtual	void SetExtensionOverride( const char * value ) = 0;

		/**
		 * Get the override file extension. This is specified including the dot, eg ".tga".
		 * @return the current override file extension
		 */
		virtual	rstring GetExtensionOverride(  ) = 0;

		/**
		 * Get the imported image data. @return the imported image data<br />Description of
		 * IImageData: IImageData holds unpacked image data. The data is  stored in an IFieldData
		 * object as value fields. For simplicity all  images are implemented as 3D images,
		 * but has an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for
		 * 1D images. Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 */
		virtual	CountedPointer<IImageData> GetImage(  ) = 0;

		/**
		 * Set CapToPowerOfTwo. If set, the width and height of the loaded image will be capped
		 * to the closest power of two below the size of the image. @param value the desired
		 * CapToPowerOfTwo flag
		 */
		virtual	void SetCapToPowerOfTwo( bool value ) = 0;

		/**
		 * Get ImageType. Return the type of the image used. The supported formats are  enumerated
		 * in the ImageFileType enumeration. @return the current ImageType
		 */
		virtual	rid GetImageType(  ) = 0;

		/**
		 * Get OnlyHeader. If set to true the call to RunImport() only gets header information
		 * from the image, and does not load the actual file into memory. MaxHeight, MaxWidth,
		 * BitsPerPixel, NumberOfChannels and ImageType will be set by call to RunImport().
		 * @return the current OnlyHeader
		 */
		virtual	bool GetOnlyHeader(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IImageDataImporter
	 * Class for loading image data from different file formats.
	 */
	typedef CountedPointer<IImageDataImporter> spImageDataImporter;


	/**
	 * IMappingImageMeshData stores the mapped meshes and their paths in the original scene.
	 * This can be used to find a specific triangle on the original mesh in the scene from
	 * the combined id in the mapping image.
	 */
	class IMappingImageMeshData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IMappingImageMeshData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IMappingImageMeshData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IMappingImageMeshData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IMappingImageMeshData pointer
		 * @return a pointer to the IMappingImageMeshData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IMappingImageMeshData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IMappingImageMeshData") )
				return static_cast<IMappingImageMeshData*>(ptr);
			return NULL;
			}
		/**
		 * Get the mesh path in the scene of the geometry at the specified index. @param GeometryIndex
		 * the index of the geometry in the list of mapped geometries. @return the path in the
		 * scene of the mesh that has this geometry
		 */
		virtual	rstring GetScenePathOfGeometry( rid GeometryIndex ) = 0;

		/**
		 * Clear the MappingImageMeshData
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the MappedGeometriesCount, the number of mapped geometries  @return the number
		 * of mapped geometries in the mapping image
		 */
		virtual	unsigned int GetMappedGeometriesCount(  ) = 0;

		/**
		 * Get the Id of the first triangle of the geometry at the specified index. @param GeometryIndex
		 * the index of the geometry in the list of mapped geometries. @return the start triangle
		 * id of the geometry
		 */
		virtual	rid GetStartTriangleIdOfGeometry( rid GeometryIndex ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IMappingImageMeshData
	 * IMappingImageMeshData stores the mapped meshes and their paths in the original scene.
	 * This can be used to find a specific triangle on the original mesh in the scene from
	 * the combined id in the mapping image.
	 */
	typedef CountedPointer<IMappingImageMeshData> spMappingImageMeshData;

	class ICameraPath;
	class IGeometryData;
	class IMaterialTable;

	/**
	 * A Renderer using DirectX 11 that can be used to preview an  IGeometryData object
	 * by rendering it from the ICamera objects in an  ICameraPath and then storing the
	 * frames to disc.   If using a Shading Node Network (having an IShadingNode assigned
	 * to the  IMaterial), then the material can be previewed with the generated HLSL shader.
	 */
	class IDirectXRenderer : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IDirectXRenderer is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IDirectXRenderer",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IDirectXRenderer pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IDirectXRenderer pointer
		 * @return a pointer to the IDirectXRenderer object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IDirectXRenderer *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IDirectXRenderer") )
				return static_cast<IDirectXRenderer*>(ptr);
			return NULL;
			}
		/**
		 * Creates a previewer with the specified window dimensions. @param _width the window
		 * width @param _height the window height @return true if the previewer was successfully
		 * created
		 */
		virtual	bool CreatePreviewer( int _width , int _height ) = 0;

		/**
		 * Render from each camera position in the camera target  direction specified in the
		 * camera path and stores the frame to the file path specified. @param camera_path the
		 * camera path to render from @param file_name_base the desired directory and file name
		 * @param format picture format (PNG or RAW)
		 */
		virtual	void RenderAlongCameraPathAndStorePics( ICameraPath *camera_path , char *file_name_base , char *format ) = 0;

		/**
		 * Sets the render mode to wire frame @param flag true if render mode should be enabled
		 */
		virtual	void SetWireFrameMode( bool flag ) = 0;

		/**
		 * Loads a geometry data object and its materials into the  previewer.  @param geom
		 * the geometry data object to preview @param materials the material table of the geometry.
		 * Can be NULL if no material table exists. @return true if the geometry data was successfully
		 * loaded
		 */
		virtual	bool LoadGeometryData( IGeometryData *geom , IMaterialTable *materials ) = 0;

		/**
		 * Loads a geometry data object and its materials into the  previewer. The material
		 * should have a shading network attached to it.  @param geom the geometry data object
		 * to preview @param materials the material table of the geometry. @return true if the
		 * geometry data was successfully loaded
		 */
		virtual	bool LoadGeometryDataWithMaterialShadingNetwork( IGeometryData *geom , IMaterialTable *materials ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IDirectXRenderer
	 * A Renderer using DirectX 11 that can be used to preview an  IGeometryData object
	 * by rendering it from the ICamera objects in an  ICameraPath and then storing the
	 * frames to disc.   If using a Shading Node Network (having an IShadingNode assigned
	 * to the  IMaterial), then the material can be previewed with the generated HLSL shader.
	 */
	typedef CountedPointer<IDirectXRenderer> spDirectXRenderer;

	class ICamera;

	/**
	 * A Camera path object that can contain a number of ICamera objects. The ICamera objects
	 * are either added to the path by the user or created from a few default member functions
	 * that creates parameterized  procedural camera paths.
	 */
	class ICameraPath : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ICameraPath is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ICameraPath",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ICameraPath pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ICameraPath pointer
		 * @return a pointer to the ICameraPath object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ICameraPath *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ICameraPath") )
				return static_cast<ICameraPath*>(ptr);
			return NULL;
			}
		/**
		 * Creates a camera path of cameras surrounding the scene and pointing at the center
		 * of the scene. @param camera_type specifies type of path @param radius set the distance
		 * of the path to the center of the scene @param _camera_angles set the number of camera
		 * angles in the path
		 */
		virtual	void CreateSurroundingCameraPath( int camera_type , float radius , int _camera_angles ) = 0;

		/**
		 * Creates a spinning camera path with number_of_angles cameras at radius distance,
		 * the cameras are  raised and pointing slightly downward to the center of the scene.
		 * @param radius the distance from the center of the scene @param number_of_angles the
		 * number of cameras in the path
		 */
		virtual	void CreateSpinningCameraPath( float radius , int number_of_angles ) = 0;

		/**
		 * Creates a horizontal spinning camera path with number_of_angles cameras at radius
		 * distance from the center of the scene. @param radius the distance from the center
		 * of the scene @param number_of_angles the number of cameras in the path
		 */
		virtual	void CreateHorizontalSpinningCameraPath( float radius , int number_of_angles ) = 0;

		/**
		 * Creates a camera path with cameras placed on a custom sphere determined by the parameters.
		 * @param radius at what distance the cameras should be placed. @param fidelity value
		 * corresponding to the density of camera points. Should be between 2-5 @param pitch_angle
		 * amount of degrees the sphere should be pitch rotated  @param jaw_angle amount of
		 * degrees the sphere should be jaw rotated  @param coverage_angle 360?would be entire
		 * sphere, 180?would be hemisphere, 0?would be no sphere.
		 */
		virtual	void CreateCustomSphereCameraPath( real radius , int fidelity , real pitch_angle , real jaw_angle , real coverage_angle ) = 0;

		/**
		 * Add a copy of a ICamera to the path. @param _camera the camera to add.
		 */
		virtual	void AddCamera( ICamera *_camera ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ICameraPath
	 * A Camera path object that can contain a number of ICamera objects. The ICamera objects
	 * are either added to the path by the user or created from a few default member functions
	 * that creates parameterized  procedural camera paths.
	 */
	typedef CountedPointer<ICameraPath> spCameraPath;

	class ICamera;

	/**
	 * A Camera object that has an XYZ-position. It can either be an omni directional camera
	 * or a target camera. The camera can be put into a camera path.  The camera has a quadratic
	 * FOV.
	 */
	class ICamera : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ICamera is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ICamera",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ICamera pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ICamera pointer
		 * @return a pointer to the ICamera object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ICamera *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ICamera") )
				return static_cast<ICamera*>(ptr);
			return NULL;
			}
		virtual	void SetTarget( float _posx , float _posy , float _posz ) = 0;

		/**
		 * Sets whether the camera coordinates are normalized and centered around the model,
		 * or if they are absolute in the same coordinate system as the object. If true; the
		 * camera coordinate length unit is the model_diameter. The point (0, 0, 0) is in the
		 * center of the model, and the point (0, 0, 1) is offset 1 model_radius in the positive
		 * z-direction from the center of the model. Set to true by default. @param value What
		 * the flag should be set to.
		 */
		virtual	void SetUsingNormalizedCoordinates( bool value ) = 0;

		/**
		 * Sets whether the camera coordinates are normalized and centered around the model,
		 * or if they are absolute in the same coordinate system as the object. If true; the
		 * camera coordinate length unit is the model_diameter. The point (0, 0, 0) is in the
		 * center of the model, and the point (0, 0, 1) is offset 1 model_radius in the positive
		 * z-direction from the center of the model. Set to true by default. @return The current
		 * flag value.
		 */
		virtual	bool GetUsingNormalizedCoordinates(  ) = 0;

		/**
		 * The field of view (in radians) of the camera. @return the current field of view of
		 * the camera.
		 */
		virtual	float GetFOV(  ) = 0;

		virtual	void DeepCopy( ICamera *camera ) = 0;

		/**
		 * Sets the position to the parameter values and sets a valid up-vector,  preferably
		 * y+ @param _posx the x coordinate @param _posy the y coordinate @param _posz the z
		 * coordinate
		 */
		virtual	void SetCamera( float _posx , float _posy , float _posz ) = 0;

		/**
		 * The field of view (in radians) of the camera. @param value the new field of view
		 * of the camera.
		 */
		virtual	void SetFOV( float value ) = 0;

		/**
		 * Whether the camera is an omni directional or a target camera. If it is an OmniDirectional
		 * camera, the Target is not used. @param value Sets whether the camera is an omni directional
		 * or a target camera.
		 */
		virtual	void SetOmniDirectional( bool value ) = 0;

		/**
		 * Whether the camera is an omni directional or a target camera. If it is an OmniDirectional
		 * camera, the Target is not used. @return Whether the camera is an omni directional
		 * or a target camera.
		 */
		virtual	bool GetOmniDirectional(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ICamera
	 * A Camera object that has an XYZ-position. It can either be an omni directional camera
	 * or a target camera. The camera can be put into a camera path.  The camera has a quadratic
	 * FOV.
	 */
	typedef CountedPointer<ICamera> spCamera;


	/**
	 * IShadingNode is the parent of all nodes in a shading network.
	 */
	class IShadingNode : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingNode",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingNode pointer
		 * @return a pointer to the IShadingNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingNode") )
				return static_cast<IShadingNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingNode
	 * IShadingNode is the parent of all nodes in a shading network.
	 */
	typedef CountedPointer<IShadingNode> spShadingNode;

	class IShadingNode;

	/**
	 * IFilterNode is the parent of all non-source nodes in a shading network.
	 */
	class IShadingFilterNode : public IShadingNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingFilterNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingFilterNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingFilterNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingFilterNode pointer
		 * @return a pointer to the IShadingFilterNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingFilterNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingFilterNode") )
				return static_cast<IShadingFilterNode*>(ptr);
			return NULL;
			}
		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingFilterNode
	 * IFilterNode is the parent of all non-source nodes in a shading network.
	 */
	typedef CountedPointer<IShadingFilterNode> spShadingFilterNode;


	/**
	 * ITextureNode describes a texture source node in a shading network.
	 */
	class IShadingTextureNode : public IShadingNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingTextureNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingTextureNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingTextureNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingTextureNode pointer
		 * @return a pointer to the IShadingTextureNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingTextureNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingTextureNode") )
				return static_cast<IShadingTextureNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Gets the path of the texture file for casting. If both this and texture image is
		 * set, the casting uses the texture image. @return the path the texture will be read
		 * from.
		 */
		virtual	rstring GetTextureName(  ) = 0;

		/**
		 * Sets the TileV value, which is multiplied into the U-coordinate when sampling @param
		 * value is the flag to use sRGB.
		 */
		virtual	void SetTileV( real value ) = 0;

		/**
		 * Gets the TileV value, which is multiplied into the U-coordinate when sampling @param
		 * value is the flag to use sRGB.
		 */
		virtual	real GetTileV(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Gets the TileU value, which is multiplied into the U-coordinate when sampling @param
		 * value is the flag to use sRGB.
		 */
		virtual	real GetTileU(  ) = 0;

		/**
		 * Gets the use of sRGB when decoding the texture into an RGBA value @param value is
		 * the flag to use sRGB.
		 */
		virtual	bool GetUseSRGB(  ) = 0;

		/**
		 * Sets the TileU value, which is multiplied into the U-coordinate when sampling @param
		 * value is the flag to use sRGB.
		 */
		virtual	void SetTileU( real value ) = 0;

		/**
		 * Gets the texture level. This is the UV-set id which will be used for sampling this
		 * texture. @return the texture level.
		 */
		virtual	rstring GetTexCoordSet(  ) = 0;

		/**
		 * Sets the texture level. This is the UV-set which will be used for sampling this texture.
		 * @param value is the uv-set the texture node will use for sampling.
		 */
		virtual	void SetTexCoordSet( const char * value ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Sets the path of the texture file for casting. If both this and texture image is
		 * set, the casting uses the texture image. @param value is the path the texture will
		 * be read from.
		 */
		virtual	void SetTextureName( const char * value ) = 0;

		/**
		 * Sets the use of sRGB when decoding the texture into an RGBA value @param value is
		 * the flag to use sRGB.
		 */
		virtual	void SetUseSRGB( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingTextureNode
	 * ITextureNode describes a texture source node in a shading network.
	 */
	typedef CountedPointer<IShadingTextureNode> spShadingTextureNode;

	class IShadingNode;

	/**
	 * IInterpolateNode describes a single interpolating shading node node in a shading
	 * network.  Input 1 and Input 2 is interpolated per-component using Input 3. Blend
	 * values below 0 and over 1 will be clamped.
	 */
	class IShadingSwizzlingNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingSwizzlingNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingSwizzlingNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingSwizzlingNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingSwizzlingNode pointer
		 * @return a pointer to the IShadingSwizzlingNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingSwizzlingNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingSwizzlingNode") )
				return static_cast<IShadingSwizzlingNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the component index in the input color that Red component will be copied from
		 * @returns the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	unsigned int GetRedComponent(  ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the component index in the input color that Blue component will be copied from
		 * @returns the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	unsigned int GetBlueComponent(  ) = 0;

		/**
		 * Set the component index in the input color that Blue component will be copied from
		 * @param value the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	void SetBlueComponent( unsigned int value ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Set the component index in the input color that Green component will be copied from
		 * @param value the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	void SetGreenComponent( unsigned int value ) = 0;

		/**
		 * Set the component index in the input color that Red component will be copied from
		 * @param value the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	void SetRedComponent( unsigned int value ) = 0;

		/**
		 * Get the component index in the input color that Green component will be copied from
		 * @returns the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	unsigned int GetGreenComponent(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Set the component index in the input color that Alpha component will be copied from
		 * @param value the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	void SetAlphaComponent( unsigned int value ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the component index in the input color that Alpha component will be copied from
		 * @returns the input component index. Allowed values are 0:R 1:G 2:B 3:A
		 */
		virtual	unsigned int GetAlphaComponent(  ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingSwizzlingNode
	 * IInterpolateNode describes a single interpolating shading node node in a shading
	 * network.  Input 1 and Input 2 is interpolated per-component using Input 3. Blend
	 * values below 0 and over 1 will be clamped.
	 */
	typedef CountedPointer<IShadingSwizzlingNode> spShadingSwizzlingNode;


	/**
	 * IColorNode describes a single color source node in a shading network
	 */
	class IShadingColorNode : public IShadingNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingColorNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingColorNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingColorNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingColorNode pointer
		 * @return a pointer to the IShadingColorNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingColorNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingColorNode") )
				return static_cast<IShadingColorNode*>(ptr);
			return NULL;
			}
		virtual	void SetColor( real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingColorNode
	 * IColorNode describes a single color source node in a shading network
	 */
	typedef CountedPointer<IShadingColorNode> spShadingColorNode;

	class IShadingNode;

	/**
	 * IAddNode describes a single addition shading node in a shading network. Input 1 and
	 * 2 are added per-component to produce the output.
	 */
	class IShadingAddNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingAddNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingAddNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingAddNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingAddNode pointer
		 * @return a pointer to the IShadingAddNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingAddNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingAddNode") )
				return static_cast<IShadingAddNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingAddNode
	 * IAddNode describes a single addition shading node in a shading network. Input 1 and
	 * 2 are added per-component to produce the output.
	 */
	typedef CountedPointer<IShadingAddNode> spShadingAddNode;

	class IShadingNode;

	/**
	 * ISubtractNode describes a single subtracting shading node in a shading network. 
	 * Input 2 is subtracted from Input 1 per-component.
	 */
	class IShadingSubtractNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingSubtractNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingSubtractNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingSubtractNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingSubtractNode pointer
		 * @return a pointer to the IShadingSubtractNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingSubtractNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingSubtractNode") )
				return static_cast<IShadingSubtractNode*>(ptr);
			return NULL;
			}
		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingSubtractNode
	 * ISubtractNode describes a single subtracting shading node in a shading network. 
	 * Input 2 is subtracted from Input 1 per-component.
	 */
	typedef CountedPointer<IShadingSubtractNode> spShadingSubtractNode;

	class IShadingNode;

	/**
	 * IMultiplyNode describes a single multiplying shading node in a shading network. 
	 * Input 1 and Input 2 is multiplied per-component.
	 */
	class IShadingMultiplyNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingMultiplyNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingMultiplyNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingMultiplyNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingMultiplyNode pointer
		 * @return a pointer to the IShadingMultiplyNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingMultiplyNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingMultiplyNode") )
				return static_cast<IShadingMultiplyNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingMultiplyNode
	 * IMultiplyNode describes a single multiplying shading node in a shading network. 
	 * Input 1 and Input 2 is multiplied per-component.
	 */
	typedef CountedPointer<IShadingMultiplyNode> spShadingMultiplyNode;

	class IShadingNode;

	/**
	 * IDivideNode describes a single division shading node node in a shading network. 
	 * Input 1 is divided by Input 2 per-component to produce the output.
	 */
	class IShadingDivideNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingDivideNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingDivideNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingDivideNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingDivideNode pointer
		 * @return a pointer to the IShadingDivideNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingDivideNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingDivideNode") )
				return static_cast<IShadingDivideNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingDivideNode
	 * IDivideNode describes a single division shading node node in a shading network. 
	 * Input 1 is divided by Input 2 per-component to produce the output.
	 */
	typedef CountedPointer<IShadingDivideNode> spShadingDivideNode;

	class IShadingNode;

	/**
	 * IClampNode describes a single clamp shading node in a shading network.  Input 1 is
	 * clamped per-component between Input 2 and 3.
	 */
	class IShadingClampNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingClampNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingClampNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingClampNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingClampNode pointer
		 * @return a pointer to the IShadingClampNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingClampNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingClampNode") )
				return static_cast<IShadingClampNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingClampNode
	 * IClampNode describes a single clamp shading node in a shading network.  Input 1 is
	 * clamped per-component between Input 2 and 3.
	 */
	typedef CountedPointer<IShadingClampNode> spShadingClampNode;

	class IShadingNode;

	/**
	 * IMaxNode describes a single max shading node in a shading network.  The output has
	 * the per-channel max values of the two inputs.
	 */
	class IShadingMaxNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingMaxNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingMaxNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingMaxNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingMaxNode pointer
		 * @return a pointer to the IShadingMaxNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingMaxNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingMaxNode") )
				return static_cast<IShadingMaxNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingMaxNode
	 * IMaxNode describes a single max shading node in a shading network.  The output has
	 * the per-channel max values of the two inputs.
	 */
	typedef CountedPointer<IShadingMaxNode> spShadingMaxNode;

	class IShadingNode;

	/**
	 * IMinNode describes a single min shading node in a shading network.  The output has
	 * the per-channel min values of the two inputs.
	 */
	class IShadingMinNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingMinNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingMinNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingMinNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingMinNode pointer
		 * @return a pointer to the IShadingMinNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingMinNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingMinNode") )
				return static_cast<IShadingMinNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingMinNode
	 * IMinNode describes a single min shading node in a shading network.  The output has
	 * the per-channel min values of the two inputs.
	 */
	typedef CountedPointer<IShadingMinNode> spShadingMinNode;

	class IShadingNode;

	/**
	 * IMaxNode describes a single step shading node, where the per-component output is
	 * either 1 or 0 depending on if input0 is larger or smaller than input1. Basically,
	 * (Input0 >= Input1) ? 1 : 0
	 */
	class IShadingStepNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingStepNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingStepNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingStepNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingStepNode pointer
		 * @return a pointer to the IShadingStepNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingStepNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingStepNode") )
				return static_cast<IShadingStepNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingStepNode
	 * IMaxNode describes a single step shading node, where the per-component output is
	 * either 1 or 0 depending on if input0 is larger or smaller than input1. Basically,
	 * (Input0 >= Input1) ? 1 : 0
	 */
	typedef CountedPointer<IShadingStepNode> spShadingStepNode;


	/**
	 * IVertexColorNode describes a vertex color source node in a shading network.
	 */
	class IShadingVertexColorNode : public IShadingNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingVertexColorNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingVertexColorNode",type)==0 )
				return true;
			return IShadingNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingVertexColorNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingVertexColorNode pointer
		 * @return a pointer to the IShadingVertexColorNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingVertexColorNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingVertexColorNode") )
				return static_cast<IShadingVertexColorNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Sets the vertex color index. This is the vertex color field in the geometry which
		 * will be used for casting with this node. @param value vertex color index which will
		 * be used.
		 */
		virtual	void SetVertexColorIndex( rid value ) = 0;

		/**
		 * Gets the vertex color index. This is the vertex color field in the geometry which
		 * will be used for casting with this node. @return the vertex color index.
		 */
		virtual	rid GetVertexColorIndex(  ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingVertexColorNode
	 * IVertexColorNode describes a vertex color source node in a shading network.
	 */
	typedef CountedPointer<IShadingVertexColorNode> spShadingVertexColorNode;

	class IShadingNode;

	/**
	 * IInterpolateNode describes a single interpolating shading node node in a shading
	 * network.  Input 1 and Input 2 is interpolated per-component using Input 3. Blend
	 * values below 0 and over 1 will be clamped.
	 */
	class IShadingInterpolateNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingInterpolateNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingInterpolateNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingInterpolateNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingInterpolateNode pointer
		 * @return a pointer to the IShadingInterpolateNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingInterpolateNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingInterpolateNode") )
				return static_cast<IShadingInterpolateNode*>(ptr);
			return NULL;
			}
		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingInterpolateNode
	 * IInterpolateNode describes a single interpolating shading node node in a shading
	 * network.  Input 1 and Input 2 is interpolated per-component using Input 3. Blend
	 * values below 0 and over 1 will be clamped.
	 */
	typedef CountedPointer<IShadingInterpolateNode> spShadingInterpolateNode;

	class IShadingNode;

	/**
	 * ICustomNode describes a custom shading node in a shading  network. The output is
	 * produced based on customizable user specified  operations.  The custom node has a
	 * user specified amount of input parameters. Use  SetInputCount() to specify the number
	 * of inputs.  The user has to assign and implement event handlers (called observers)
	 * for the custom node to be able to evaluate to colors.  See CustomNodeExample and
	 * API documentation for further explanations  and code samples.
	 */
	class IShadingCustomNode : public IShadingFilterNode
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShadingCustomNode is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShadingCustomNode",type)==0 )
				return true;
			return IShadingFilterNode::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShadingCustomNode pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShadingCustomNode pointer
		 * @return a pointer to the IShadingCustomNode object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShadingCustomNode *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShadingCustomNode") )
				return static_cast<IShadingCustomNode*>(ptr);
			return NULL;
			}
		/**
		 * Set the default parameter values @param parameter_id is the id of the input to be
		 * set. @param r is the value of red to which the default input will be set. @param
		 * g is the value of green to which the default input will be set. @param b is the value
		 * of blue to which the default input will be set. @param a is the value of alpha to
		 * which the default input will be set.
		 */
		virtual	void SetDefaultParameter( rid parameter_id , real r , real g , real b , real a ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Red default parameter value
		 */
		virtual	real GetDefaultParameterRed( rid parameter_id ) = 0;

		virtual	unsigned int GetInputCount(  ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Green default parameter value
		 */
		virtual	real GetDefaultParameterGreen( rid parameter_id ) = 0;

		virtual	void SetInputCount( unsigned int value ) = 0;

		/**
		 * Get the name of a parameter @return the name of the parameter
		 */
		virtual	rstring GetParameterName( rid parameter_id ) = 0;

		/**
		 * Set the default node inputs @param input_id is the id of the input to be set. @param
		 * input_node is the node to be set as input
		 */
		virtual	bool SetInput( rid input_id , IShadingNode *input_node ) = 0;

		/**
		 * Get the default node inputs @param input_id is the id of the input to be fetched.
		 * @return the input node<br />Description of IShadingNode: IShadingNode is the parent
		 * of all nodes in a shading network.
		 */
		virtual	CountedPointer<IShadingNode> GetInput( rid input_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Blue default parameter value
		 */
		virtual	real GetDefaultParameterBlue( rid parameter_id ) = 0;

		/**
		 * Get the default parameter values @param parameter_id is the id of the input to be
		 * fetched. @return the Alpha default parameter value
		 */
		virtual	real GetDefaultParameterAlpha( rid parameter_id ) = 0;

		/**
		 * Get if the parameter is inputable. If true, a different node can be set as this parameters
		 * value.  If false, the parameter can only be set manually and not through a node input.
		 * @param param_id is the id of the parameter to be checked. @return true if parameter
		 * is inputable, false if it is not
		 */
		virtual	bool GetParameterIsInputable( rid param_id ) = 0;

		/**
		 * Get the input count @return the input count
		 */
		virtual	unsigned int GetParameterCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShadingCustomNode
	 * ICustomNode describes a custom shading node in a shading  network. The output is
	 * produced based on customizable user specified  operations.  The custom node has a
	 * user specified amount of input parameters. Use  SetInputCount() to specify the number
	 * of inputs.  The user has to assign and implement event handlers (called observers)
	 * for the custom node to be able to evaluate to colors.  See CustomNodeExample and
	 * API documentation for further explanations  and code samples.
	 */
	typedef CountedPointer<IShadingCustomNode> spShadingCustomNode;

	class IMaterial;
	class IStringArray;
	class IRidArray;

	/**
	 * Given a material, the shader data class keeps the relevant shader data and is able
	 * to generate a GLSL/HLSL shader.
	 */
	class IShaderData : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IShaderData is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IShaderData",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IShaderData pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IShaderData pointer
		 * @return a pointer to the IShaderData object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IShaderData *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IShaderData") )
				return static_cast<IShaderData*>(ptr);
			return NULL;
			}
		/**
		 * Returns a string containing the entire HLSL shader GenerateShader must have been
		 * called prior to this call
		 */
		virtual	rstring GetHLSLCode(  ) = 0;

		/**
		 * Returns a string containing the entire HLSL shader configured to work with the Simplygon
		 * GUI GenerateShader must have been called prior to this call
		 */
		virtual	rstring GetGUIHLSLCode(  ) = 0;

		/**
		 * Sets the material, for which to create a shader @param _material the material to
		 * generate a shader from
		 */
		virtual	void SetMaterial( IMaterial *_material ) = 0;

		/**
		 * Gets the material, for which to create a shader @void the current material to generate
		 * a shader from<br />Description of IMaterial: IMaterial keeps information on materials
		 * used while rendering.
		 */
		virtual	CountedPointer<IMaterial> GetMaterial(  ) = 0;

		/**
		 * Get an array of the unique UV sets used in  the material. For the shader to use these
		 * UV sets, they  are required to be uploaded as texture coordinates  corresponding
		 * to their position in the array. The shader  will generate the texcoords variables
		 * with the naming  convention "tex_i" (i : the array index of the UV set).  GenerateShader
		 * must have been called prior to this call  @return the array of UV sets (texcoords)<br
		 * />Description of IRidArray: IRidArray is the rid implementation of IValueArray. See
		 * IValueArray for a description.
		 */
		virtual	CountedPointer<IRidArray> GetShaderInputUVSets(  ) = 0;

		/**
		 * Get an array of the unique vertex colors used in the material. For the shader to
		 * use these vertex colors, they are required to be uploaded as vertex color corresponding
		 * to their position in the array. The shader will generate the vertex color variables
		 * with the naming convention "vertexcolor_i" (i : the array index of the  vertex color).
		 * GenerateShader must have been called prior to this call  @return the array of vetex
		 * colors<br />Description of IRidArray: IRidArray is the rid implementation of IValueArray.
		 * See IValueArray for a description.
		 */
		virtual	CountedPointer<IRidArray> GetShaderInputVertexColors(  ) = 0;

		/**
		 * Unloads all shader data and resets it.
		 */
		virtual	void UnloadData(  ) = 0;

		/**
		 * Generates a shader, given a material that uses shading node networks @return will
		 * return true if the shader could be generated from the material
		 */
		virtual	bool GenerateShaderData(  ) = 0;

		/**
		 * Returns a string containing the GLSL fragment shader GenerateShader must have been
		 * called prior to this call
		 */
		virtual	rstring GetGLSLFragmentCode(  ) = 0;

		/**
		 * Get an array of the unique texture paths used in  the material. For the shader to
		 * use these textures, they  are required to be uploaded to the texture channel  corresponding
		 * to their position in the array. The shader will generate these sampler variables
		 * with the naming  convention "map_i" (i : the array index of the texture).  GenerateShader
		 * must have been called prior to this call  @return the array of unique texture paths<br
		 * />Description of IStringArray: ReStringArray is the string implementation of ReValueArray.
		 * See ReValueArray for a description. Please note that conversions to/from real values
		 * will not work on string arrays.
		 */
		virtual	CountedPointer<IStringArray> GetShaderInputTexturePaths(  ) = 0;

		/**
		 * Returns a string containing the GLSL vertex shader GenerateShader must have been
		 * called prior to this call
		 */
		virtual	rstring GetGLSLVertexCode(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IShaderData
	 * Given a material, the shader data class keeps the relevant shader data and is able
	 * to generate a GLSL/HLSL shader.
	 */
	typedef CountedPointer<IShaderData> spShaderData;

	class ISceneNode;
	class IMappingImage;
	class ISceneAggregatorSettings;
	class IMappingImageSettings;
	class IVisibilitySettings;

	/**
	 * ISceneAggregator combines all specified  geometries in the scene into one geometry.
	 * All materials are combined and receive a new shared texture atlas.
	 */
	class ISceneAggregator : public IProcessingObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneAggregator is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneAggregator",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneAggregator pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneAggregator pointer
		 * @return a pointer to the ISceneAggregator object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneAggregator *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneAggregator") )
				return static_cast<ISceneAggregator*>(ptr);
			return NULL;
			}
		/**
		 * Clears the processing, and resets all internal states.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  reduction processing. All mesh nodes
		 * in the whole scene  tree will be replaced by one proxy mesh. @param value is the
		 * scene node to which SceneRoot will be set
		 */
		virtual	void SetSceneRoot( ISceneNode *value ) = 0;

		/**
		 * Runs the combining of the geometry. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Runs the combining of the geometry. 
		 */
		virtual	void CombineGeometry(  ) = 0;

		/**
		 * The settings for the image mapping process. @return the mapping image settings object<br
		 * />Description of IMappingImageSettings: Settings for the Simplygon mapping classes
		 * These settings control the properties of the mapping image that will be generated
		 * in the current simplification processor (reducer/remesher  etc).   The mapping image
		 * will be used when casting a new texture on the  simplified geometry. In the settings
		 * object, the user is able to set  the dimensions of the image (width/height) as well
		 * as whether the LOD should have new texture coordinates and some parameters for how
		 * they  should be generated and all other settings regarding the mapping image.
		 */
		virtual	CountedPointer<IMappingImageSettings> GetMappingImageSettings(  ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  reduction processing. All mesh nodes
		 * in the whole scene  tree will be replaced by one mesh. @return the current scene
		 * root node<br />Description of ISceneNode: ISceneNode is the base class for all scene
		 * graph nodes in simplygon. It has relative transformation to its parent, and functions
		 * to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetSceneRoot(  ) = 0;

		/**
		 * Get the MappingImage object that is generated if  MappingImageSettings::GenerateMappingImage
		 * is set. The object is of type IMappingImage. A new object is generated for each call
		 * to RunProcessing(). @return the current mapping image<br />Description of IMappingImage:
		 * IMappingImage stores the mapping between a processed geometry and the source geometry
		 * it is based on. The mapping image object also stores multisampling settings. It can
		 * be used to cast information from the original geometry to the processed geometry,
		 * such as surface transfer or calculating normal maps. See IMaterialCaster and subclasses
		 * for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * The settings for handling visibility weights. @return the visibility settings object
		 * associated with the processor	<br />Description of IVisibilitySettings:  Visibility
		 * settings contains the parameters for how to compute the visibility of a scene and
		 * how to use it, both in the  IReductionProcessor and the IRemeshingProcessor.  The
		 * visibility information is computed for each part of the mesh  determined by the visibility
		 * from a collection of cameras contained  in the CameraPath.   The visibility can be
		 * used to guide the reducer and/or texture  coordinates generator (parameterizer) with
		 * the flags UseVisibilityWeightsInReducer respective  UseVisibilityWeightsInTexcoordGenerator.
		 * There is also an option to completely throw away triangles that are deemed not visible,
		 * using the CullOccludedGeometry flag.
		 */
		virtual	CountedPointer<IVisibilitySettings> GetVisibilitySettings(  ) = 0;

		/**
		 * The settings for the combining process. @return the combining settings object<br
		 * />Description of ISceneAggregatorSettings: Settings for the ISceneAggregatorSettings
		 * class. The SceneAggregator converts entire scenes containing multiple draw calls
		 * into a single new object with a single texture per material channel.  The user can
		 * set whether or not the SceneAggregator should  create new UVs based on the old UVs
		 * or create a completely new UV parameterization.
		 */
		virtual	CountedPointer<ISceneAggregatorSettings> GetSceneAggregatorSettings(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneAggregator
	 * ISceneAggregator combines all specified  geometries in the scene into one geometry.
	 * All materials are combined and receive a new shared texture atlas.
	 */
	typedef CountedPointer<ISceneAggregator> spSceneAggregator;


	/**
	 * Settings for the ISceneAggregatorSettings class. The SceneAggregator converts entire
	 * scenes containing multiple draw calls into a single new object with a single texture
	 * per material channel.  The user can set whether or not the SceneAggregator should
	 * create new UVs based on the old UVs or create a completely new UV parameterization.
	 */
	class ISceneAggregatorSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISceneAggregatorSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISceneAggregatorSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISceneAggregatorSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISceneAggregatorSettings pointer
		 * @return a pointer to the ISceneAggregatorSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISceneAggregatorSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISceneAggregatorSettings") )
				return static_cast<ISceneAggregatorSettings*>(ptr);
			return NULL;
			}
		/**
		 * Set KeepOriginalChartProportionsFromChannel to an SG_MATERIAL_CHANNEL_[...]. This
		 * channel determines which texture channel to look at when determining which chart
		 * proportions to keep. The default value is SG_MATERIAL_CHANNEL_DIFFUSE. @return the
		 * current KeepOriginalChartProportionsFromChannel value
		 */
		virtual	rstring GetKeepOriginalChartProportionsFromChannel(  ) = 0;

		/**
		 * If KeepOriginalChartProportions and BaseAtlasOnOriginalTexCoords enabled, the proportions
		 * of the charts in the output  texture will match the proportions of the charts in
		 * the input textures. The charts may be rotated multiples of 90 degrees. The value
		 * in KeepOriginalChartProportionsChannel (default: SG_MATERIAL_CHANNEL_DIFFUSE) determines
		 * which input texture channel is used when determining original chart proportions.
		 * This requires that the MaterialTable contains the scene materials. @return the current
		 * value of KeepOriginalChartProportions
		 */
		virtual	bool GetKeepOriginalChartProportions(  ) = 0;

		/**
		 * Set KeepOriginalChartProportionsFromChannel to an SG_MATERIAL_CHANNEL_[...]. This
		 * channel determines which texture channel to look at when determining which chart
		 * proportions to keep. The default value is SG_MATERIAL_CHANNEL_DIFFUSE. @param value
		 * the new KeepOriginalChartProportionsFromChannel value
		 */
		virtual	void SetKeepOriginalChartProportionsFromChannel( const char * value ) = 0;

		/**
		 * Sets whether the new texture coords should be based on  the original texture coords
		 * and the charts only rotated in multiples of 90 degrees, or if the scene should have
		 * completely new texture coords. @param value set to true if the new texture coords
		 * should be based on the original texture coords.
		 */
		virtual	void SetBaseAtlasOnOriginalTexCoords( bool value ) = 0;

		/**
		 * Sets whether the new texture coords should be based on  the original texture coords
		 * and the charts only rotated in multiples of 90 degrees, or if the scene should have
		 * completely new texture coords. @return the current flag value
		 */
		virtual	bool GetBaseAtlasOnOriginalTexCoords(  ) = 0;

		/**
		 * If KeepOriginalChartProportions and BaseAtlasOnOriginalTexCoords are enabled, the
		 * proportions of the charts in the output  texture will match the proportions of the
		 * charts in the input textures. The charts may be rotated multiples of 90 degrees.
		 * The value in KeepOriginalChartProportionsChannel (default: SG_MATERIAL_CHANNEL_DIFFUSE)
		 * determines which input texture channel is used when determining original chart proportions.
		 * This requires that the MaterialTable contains the scene materials. @param value the
		 * new value of KeepOriginalChartProportions
		 */
		virtual	void SetKeepOriginalChartProportions( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISceneAggregatorSettings
	 * Settings for the ISceneAggregatorSettings class. The SceneAggregator converts entire
	 * scenes containing multiple draw calls into a single new object with a single texture
	 * per material channel.  The user can set whether or not the SceneAggregator should
	 * create new UVs based on the old UVs or create a completely new UV parameterization.
	 */
	typedef CountedPointer<ISceneAggregatorSettings> spSceneAggregatorSettings;

	class IGeometryData;
	class IRealArray;
	class IMaterialTable;
	class ITextureTable;

	/**
	 * Computes new texture coordinates for a geometry with overlapping UV charts.
	 */
	class IChartAggregator : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IChartAggregator is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IChartAggregator",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IChartAggregator pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IChartAggregator pointer
		 * @return a pointer to the IChartAggregator object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IChartAggregator *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IChartAggregator") )
				return static_cast<IChartAggregator*>(ptr);
			return NULL;
			}
		/**
		 * Set the number of input materials used in the original geometry for mapping to multiple
		 * output materials. This needs to be set before you can set any specific in-out material
		 * mapping.  0 signifies that no in-out material mapping is used, ie. the process will
		 * produce one resulting mapping image. @param value is the number of outputs
		 */
		virtual	void SetInputMaterialCount( unsigned int value ) = 0;

		/**
		 * Get the height of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureHeight( unsigned int id ) = 0;

		/**
		 * Get the previously set material mapping for mat_id. @return the currently mapped
		 * output material for InMaterialId. -1 means mapping is not set.
		 */
		virtual	int GetInputOutputMaterialMapping( unsigned int InMaterialId ) = 0;

		/**
		 * Get the minimum number of pixels between charts. @return the current value of GutterSpace
		 */
		virtual	unsigned int GetGutterSpace(  ) = 0;

		/**
		 * Set KeepOriginalChartProportionsFromChannel to an SG_MATERIAL_CHANNEL_[...]. This
		 * channel determines which texture channel to look at when determining which chart
		 * sizes to keep. The default value is SG_MATERIAL_CHANNEL_DIFFUSE. @param value the
		 * new KeepOriginalChartProportionsFromChannel value
		 */
		virtual	void SetKeepOriginalChartProportionsFromChannel( const char * value ) = 0;

		/**
		 * The scene's texture table  @param value the scene's texture table 
		 */
		virtual	void SetTextureTable( ITextureTable *value ) = 0;

		/**
		 * Get the number of input materials set earlier. 0 signifies that no in-out material
		 * mapping is used. @return the current value of InputMaterialCount
		 */
		virtual	unsigned int GetInputMaterialCount(  ) = 0;

		/**
		 * If KeepOriginalChartProportions is enabled, the proportions of the charts in the
		 * output  texture will match the proportions of the charts in the input textures. The
		 * charts may be rotated multiples of 90 degrees. The value in KeepOriginalChartProportionsChannel
		 * (default: SG_MATERIAL_CHANNEL_DIFFUSE) determines which input texture channel is
		 * used when determining original chart proportions. This requires that the MaterialTable
		 * contains the scene materials. @return the current value of KeepOriginalChartProportions
		 */
		virtual	bool GetKeepOriginalChartProportions(  ) = 0;

		/**
		 * Set the height of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureHeight( unsigned int value ) = 0;

		/**
		 * Executes the parameterization of the geometry. @param geom is the geometry which
		 * is to be parameterized @return true if the parameterization succeeds, false otherwise
		 */
		virtual	bool Parameterize( IGeometryData *geom , IRealArray *arr ) = 0;

		/**
		 * Get the minimum number of pixels between charts. @return the current value of GutterSpace
		 */
		virtual	unsigned int GetGutterSpace( unsigned int id ) = 0;

		/**
		 * Get flag for whether to rescale charts based on corresponding geometric area in 3D
		 * space. @return current flag for area weighting
		 */
		virtual	bool GetUseAreaWeighting(  ) = 0;

		/**
		 * Set the number of output mapping images that are to be generated. The triangle field
		 * OutputMaterialIds also needs to be set,  or the material ids of the original geometry
		 * needs to be set to a specific output material in this setting object. @param value
		 * is the number of outputs
		 */
		virtual	void SetOutputMaterialCount( unsigned int value ) = 0;

		/**
		 * If KeepOriginalChartProportions is enabled, the proportions of the charts in the
		 * output  texture will match the proportions of the charts in the input textures. The
		 * charts may be rotated multiples of 90 degrees. The value in KeepOriginalChartProportionsChannel
		 * (default: SG_MATERIAL_CHANNEL_DIFFUSE) determines which input texture channel is
		 * used when determining original chart proportions. This requires that the MaterialTable
		 * contains the scene materials. @param value the new value of KeepOriginalChartProportions
		 */
		virtual	void SetKeepOriginalChartProportions( bool value ) = 0;

		/**
		 * Get the number of output mapping images that are to be generated. @return the current
		 * value of OutputMaterialCount
		 */
		virtual	unsigned int GetOutputMaterialCount(  ) = 0;

		/**
		 * Set the automatic_texture_size flag. If true, then texture sizes will be computed
		 * for the reduced mesh depending on its pixel size on screen. @return the current flag
		 */
		virtual	bool GetAutomaticTextureSize(  ) = 0;

		/**
		 * Set the width of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureWidth( unsigned int id , unsigned int value ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the  texture sizes to be a power
		 * of 2 @return the current flag
		 */
		virtual	bool GetForcePower2Texture(  ) = 0;

		/**
		 * The scene's material table  @return the scene's material table 
		 */
		virtual	void SetMaterialTable( IMaterialTable *value ) = 0;

		/**
		 * Set the minimum number of pixels between charts. @param value is the value to which
		 * GutterSpace will be set
		 */
		virtual	void SetGutterSpace( unsigned int id , unsigned int value ) = 0;

		/**
		 * Get TexCoord level to get charts from during reparameterization. @param current TexCoord
		 * level
		 */
		virtual	unsigned int GetTexCoordLevel(  ) = 0;

		/**
		 * Set TexCoord level to get charts from during reparameterization. @param TexCoord
		 * level
		 */
		virtual	void SetTexCoordLevel( unsigned int value ) = 0;

		/**
		 * Get the current automatic texture size multiplier. @return the current multiplier
		 */
		virtual	real GetAutomaticTextureSizeMultiplier(  ) = 0;

		/**
		 * Set flag for whether to rescale charts based on corresponding geometric area in 3D
		 * space. @param flag to enable/disable area weighting
		 */
		virtual	void SetUseAreaWeighting( bool value ) = 0;

		/**
		 * Get the height of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureHeight(  ) = 0;

		/**
		 * Set the material mapping for mat_id, meaning what material of the generated LOD mat_id
		 * will be baked into. Both InputMaterialCount and OutputMaterialCount need to be set
		 * for this mapping to work, and all original materials need to be mapped to an existing
		 * output id. @param value is the number of outputs
		 */
		virtual	void SetInputOutputMaterialMapping( unsigned int InMaterialId , int OutMaterialId ) = 0;

		/**
		 * Set the width of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureWidth( unsigned int value ) = 0;

		/**
		 * Set the automatic_texture_size flag. If true, then texture sizes will be computed
		 * for the reduced mesh depending on its pixel size on screen. @param value the desired
		 * flag
		 */
		virtual	void SetAutomaticTextureSize( bool value ) = 0;

		/**
		 * Set a texture dimension length multiplier for the automatic  texture size.  @param
		 * value the desired multiplier
		 */
		virtual	void SetAutomaticTextureSizeMultiplier( real value ) = 0;

		/**
		 * Get the width of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureWidth(  ) = 0;

		/**
		 * Get the width of the texture to use. @param value is the value to which TextureWidth
		 * will be set
		 */
		virtual	unsigned int GetTextureWidth( unsigned int id ) = 0;

		/**
		 * Set the height of the texture to use. @return the current value of TextureWidth
		 */
		virtual	void SetTextureHeight( unsigned int id , unsigned int value ) = 0;

		/**
		 * Set the minimum number of pixels between charts. @param value is the value to which
		 * GutterSpace will be set
		 */
		virtual	void SetGutterSpace( unsigned int value ) = 0;

		/**
		 * If automatic_texture_size is enabled, then force the  texture sizes to be a power
		 * of 2 @param value the desired flag
		 */
		virtual	void SetForcePower2Texture( bool value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IChartAggregator
	 * Computes new texture coordinates for a geometry with overlapping UV charts.
	 */
	typedef CountedPointer<IChartAggregator> spChartAggregator;

	class ISceneNode;
	class ITextureTable;
	class IMaterialTable;
	class IMappingImage;

	/**
	 * IVertexColorBaker
	 */
	class IVertexColorBaker : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IVertexColorBaker is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IVertexColorBaker",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IVertexColorBaker pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IVertexColorBaker pointer
		 * @return a pointer to the IVertexColorBaker object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IVertexColorBaker *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IVertexColorBaker") )
				return static_cast<IVertexColorBaker*>(ptr);
			return NULL;
			}
		/**
		 * Get the name of the channel to bake to vertex. @return the name of the channel
		 */
		virtual	rstring GetInputChannelName(  ) = 0;

		/**
		 * Set the mapping image between original and processed geometry. @param MappingImage
		 * is the mapping image.
		 */
		virtual	void SetMappingImage( IMappingImage *_MappingImage ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  vertex baking. @return the current
		 * top scene node<br />Description of ISceneNode: ISceneNode is the base class for all
		 * scene graph nodes in simplygon. It has relative transformation to its parent, and
		 * functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetSceneRoot(  ) = 0;

		/**
		 * Get the mapping image between original and processed geometry. @return the mapping
		 * image<br />Description of IMappingImage: IMappingImage stores the mapping between
		 * a processed geometry and the source geometry it is based on. The mapping image object
		 * also stores multisampling settings. It can be used to cast information from the original
		 * geometry to the processed geometry, such as surface transfer or calculating normal
		 * maps. See IMaterialCaster and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Set the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @param value is the texture table to which SourceTextures
		 * will be set
		 */
		virtual	void SetSourceTextures( ITextureTable *value ) = 0;

		/**
		 * Set the color space edge threshold, which will define how many hard color borders
		 * there will be. @param value is the new threshold.
		 */
		virtual	void SetColorSpaceEdgeThreshold( real value ) = 0;

		/**
		 * Get the color space edge threshold, which will define how many hard color borders
		 * there will be. @return the color space edge threshold
		 */
		virtual	real GetColorSpaceEdgeThreshold(  ) = 0;

		/**
		 * Set the level of the color field to bake to. @param OutputColorLevel is the color
		 * field level.
		 */
		virtual	void SetOutputColorLevel( rid value ) = 0;

		/**
		 * Run baking to vertex.
		 */
		virtual	void Bake(  ) = 0;

		/**
		 * Set the material table of the scene. @param MaterialTable is the scene material table
		 * to use for baking.
		 */
		virtual	void SetMaterialTable( IMaterialTable *value ) = 0;

		/**
		 * Set the name of the channel to bake to vertex. @param value is the name of the channel.
		 */
		virtual	void SetChannelName( const char * value ) = 0;

		/**
		 * Get the level of the color field to bake to. @return the color field level
		 */
		virtual	rid GetOutputColorLevel(  ) = 0;

		/**
		 * Get the material table of the scene. @return the specified scene material table to
		 * use for baking<br />Description of IMaterialTable: IMaterialTable keeps information
		 * on materials used while rendering.
		 */
		virtual	CountedPointer<IMaterialTable> GetMaterialTable(  ) = 0;

		/**
		 * Clears the processing, and resets all internal states. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Get the SourceTextures object. The SourceTextures object contains all textures of
		 * the the source geometry.  @return the current SourceTextures material table<br />Description
		 * of ITextureTable: ITextureTable keeps information on textures used while rendering.
		 */
		virtual	CountedPointer<ITextureTable> GetSourceTextures(  ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  vertex baking. @param SceneRoot
		 * is the node that is to be set as the top scene node
		 */
		virtual	void SetSceneRoot( ISceneNode *value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IVertexColorBaker
	 * IVertexColorBaker
	 */
	typedef CountedPointer<IVertexColorBaker> spVertexColorBaker;

	class IGeometryData;

	/**
	 * ...
	 */
	class IGeometryAnalyzer : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IGeometryAnalyzer is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IGeometryAnalyzer",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IGeometryAnalyzer pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IGeometryAnalyzer pointer
		 * @return a pointer to the IGeometryAnalyzer object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IGeometryAnalyzer *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IGeometryAnalyzer") )
				return static_cast<IGeometryAnalyzer*>(ptr);
			return NULL;
			}
		/**
		 * Detects borders in the geometry, and adds a "BorderFlags"  User Triangle-Vertex field
		 * to the geometry with the border flags set
		 */
		virtual	void AnalyzeGeometry( IGeometryData *geom ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IGeometryAnalyzer
	 * ...
	 */
	typedef CountedPointer<IGeometryAnalyzer> spGeometryAnalyzer;

	class IGeometryData;

	/**
	 * ...
	 */
	class INormalAnalyzer : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if INormalAnalyzer is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("INormalAnalyzer",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a INormalAnalyzer pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a INormalAnalyzer pointer
		 * @return a pointer to the INormalAnalyzer object, if the cast can be made, and a NULL pointer otherwise
		 */
		static INormalAnalyzer *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("INormalAnalyzer") )
				return static_cast<INormalAnalyzer*>(ptr);
			return NULL;
			}
		virtual	unsigned int GetNonUnitLenghtNormalsCount(  ) = 0;

		virtual	real GetLargestTangentSpaceOrthogonalDeviation(  ) = 0;

		virtual	real GetMeanTangentSpaceOrthogonalDeviation(  ) = 0;

		virtual	void AnalyzeTangentSpace( IGeometryData *geom , rid channelID ) = 0;

		virtual	void AnalyzeNormals( IGeometryData *geom ) = 0;

		virtual	unsigned int GetBackfacingNormalsCount(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an INormalAnalyzer
	 * ...
	 */
	typedef CountedPointer<INormalAnalyzer> spNormalAnalyzer;

	class IGeometryData;

	/**
	 * ...
	 */
	class IUVAnalyzer : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IUVAnalyzer is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IUVAnalyzer",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IUVAnalyzer pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IUVAnalyzer pointer
		 * @return a pointer to the IUVAnalyzer object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IUVAnalyzer *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IUVAnalyzer") )
				return static_cast<IUVAnalyzer*>(ptr);
			return NULL;
			}
		virtual	real GetMedian2DAreaChart(  ) = 0;

		virtual	rid GetMaxTriangleCountInChart(  ) = 0;

		virtual	real GetMin3DAreaChartRatio(  ) = 0;

		virtual	real GetTotal3DChartArea(  ) = 0;

		virtual	real GetMedian3DAreaChartRatio(  ) = 0;

		virtual	real GetMean2DAreaChart(  ) = 0;

		virtual	rid GetMinTriangleCountInChart(  ) = 0;

		virtual	real GetMean3DAreaChart(  ) = 0;

		virtual	void AnalyzeUVChannel( IGeometryData *geom , rid channelID ) = 0;

		virtual	real GetMaxLargest3D2DEdgeLengthRatioDisparity(  ) = 0;

		virtual	int GetNumberOfChartsWithOverlaps(  ) = 0;

		virtual	real GetStretch(  ) = 0;

		virtual	real GetMean3DAreaChartRatio(  ) = 0;

		virtual	real GetMin3DAreaChart(  ) = 0;

		virtual	bool GetChartsAreOverlapping(  ) = 0;

		virtual	real GetMax2DAreaChartRatio(  ) = 0;

		virtual	real GetMin2DAreaChartRatio(  ) = 0;

		virtual	rid GetChartCount(  ) = 0;

		virtual	real GetMin2DAreaChart(  ) = 0;

		virtual	real GetTotal2DChartArea(  ) = 0;

		virtual	real GetMedian3DAreaChart(  ) = 0;

		virtual	real GetMean2DAreaChartRatio(  ) = 0;

		virtual	real GetMedianLargest3D2DEdgeLengthRatioDisparity(  ) = 0;

		virtual	real GetMeanStretchChart(  ) = 0;

		virtual	real GetMedianStretchChart(  ) = 0;

		virtual	real GetMinLargest3D2DEdgeLengthRatioDisparity(  ) = 0;

		virtual	real GetMax3DAreaChartRatio(  ) = 0;

		virtual	real GetMedian2DAreaChartRatio(  ) = 0;

		virtual	real GetMax3DAreaChart(  ) = 0;

		virtual	real GetMeanLargest3D2DEdgeLengthRatioDisparity(  ) = 0;

		virtual	real GetMeanTrianglesInChart(  ) = 0;

		virtual	rid GetMedianTriangleCountInChart(  ) = 0;

		virtual	rid GetNumberOfChartsWithFewTriangles(  ) = 0;

		virtual	real GetMax2DAreaChart(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IUVAnalyzer
	 * ...
	 */
	typedef CountedPointer<IUVAnalyzer> spUVAnalyzer;

	class IImageData;

	/**
	 * Class for loading image data from different file formats.
	 */
	class IImageDataExporter : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IImageDataExporter is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IImageDataExporter",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImageDataExporter pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImageDataExporter pointer
		 * @return a pointer to the IImageDataExporter object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IImageDataExporter *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IImageDataExporter") )
				return static_cast<IImageDataExporter*>(ptr);
			return NULL;
			}
		/**
		 * Runs the import. Note that all parameters must be setup before importing.
		 */
		virtual	bool RunExport(  ) = 0;

		/**
		 * Set the imported image data. @return the imported image data
		 */
		virtual	void SetImage( IImageData *value ) = 0;

		/**
		 * Close any open file or stream, release any allocated data.
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * Set the main import file path. This must always be set.  @param value the desired
		 * main import file path
		 */
		virtual	void SetExportFilePath( const char * value ) = 0;

		/**
		 * Get the main import file path. This must always be set.  @return the main import
		 * file path
		 */
		virtual	rstring GetExportFilePath(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IImageDataExporter
	 * Class for loading image data from different file formats.
	 */
	typedef CountedPointer<IImageDataExporter> spImageDataExporter;

	class ISceneNode;
	class IGeometryData;
	class IImpostorSettings;
	class IMappingImageSettings;
	class IMappingImage;

	/**
	 * The ImpostorProcessor generates a two-triangle billboard impostor  geometry of an
	 * input geometry from a specific viewing angle, and  casts textures and normals from
	 * the original geometry to the impostor.
	 */
	class IImpostorProcessor : public IProcessingObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IImpostorProcessor is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IImpostorProcessor",type)==0 )
				return true;
			return IProcessingObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImpostorProcessor pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImpostorProcessor pointer
		 * @return a pointer to the IImpostorProcessor object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IImpostorProcessor *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IImpostorProcessor") )
				return static_cast<IImpostorProcessor*>(ptr);
			return NULL;
			}
		/**
		 * Runs the Impostor generator for the scene. 
		 */
		virtual	void Clear(  ) = 0;

		/**
		 * The settings for the ImpostorProcessor. @return the ImpostorProcessor settings object
		 * associated with the processor	<br />Description of IImpostorSettings: Settings for
		 * the ImpostorProccessor
		 */
		virtual	CountedPointer<IImpostorSettings> GetImpostorSettings(  ) = 0;

		/**
		 * The Impostor GeometryData. @return the Impostor GeometryData object created by the
		 * processor<br />Description of IGeometryData: IGeometryData represents a geometric
		 * structure  consisting of point data (Vertices) and topological data (Triangles).
		 * IGeometryData may represent a whole geometric object, but can also be used by streaming
		 * data filters, and in this way, only represents a part of the object. <br><br> Different
		 * fields in the Vertices and Triangles fields data  objects will contain point data
		 * and topological data. The standard  naming convention used in the filters/renderers
		 * are as follows: (Case sensitive naming, other fields may also be present) <br><br>
		 * 'Coords' <br> Positional coordinates of a vertex, expressed with a 3-component real
		 * field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br> Texture coordinates of a
		 * vertex, expressed with a 2 components real field. By convention, the existing fields
		 * must be sequential, and  must start with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal
		 * vector for the vertex,	expressed  with a 3-component real field, a  normalized (XYZ)
		 * vector. <br><br> 'VertexIds'	 <br> The id of the primitive's current vertex.  This
		 * field is present even if the  vertex data	is directly specified in the  primitive's
		 * data, to specify topology. The field is of type rid. <br><br> 'MaterialIds' <br>
		 * The material of the primitive.  The field is of type rid. <br><br> The 'Coords' and
		 * 'VertexIds' fields always exist in the object, but the other fields are optional.
		 * Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetImpostorGeometry(  ) = 0;

		/**
		 * Runs the Impostor generator for the scene. 
		 */
		virtual	void RunProcessing(  ) = 0;

		/**
		 * Set the input geometry used for  impostor processing. The entire geometry will be
		 * replaced by  one proxy mesh. @param value is the input GeometryData
		 */
		virtual	void SetGeometry( IGeometryData *value ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  impostor processing. All mesh nodes
		 * in the whole scene  tree will be replaced by one proxy mesh. @param value is the
		 * scene node to which SceneRoot will be set
		 */
		virtual	void SetSceneRoot( ISceneNode *value ) = 0;

		/**
		 * The MappingImage for the Impostor geometry. @return the MappingImage object associated
		 * with the processor	<br />Description of IMappingImage: IMappingImage stores the mapping
		 * between a processed geometry and the source geometry it is based on. The mapping
		 * image object also stores multisampling settings. It can be used to cast information
		 * from the original geometry to the processed geometry, such as surface transfer or
		 * calculating normal maps. See IMaterialCaster and subclasses for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * The settings for the the MappingImage. @return the MappingImage settings object associated
		 * with the processor	<br />Description of IMappingImageSettings: Settings for the Simplygon
		 * mapping classes  These settings control the properties of the mapping image that
		 * will be generated in the current simplification processor (reducer/remesher  etc).
		 * The mapping image will be used when casting a new texture on the  simplified geometry.
		 * In the settings object, the user is able to set  the dimensions of the image (width/height)
		 * as well as whether the LOD should have new texture coordinates and some parameters
		 * for how they  should be generated and all other settings regarding the mapping image.
		 */
		virtual	CountedPointer<IMappingImageSettings> GetMappingImageSettings(  ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IImpostorProcessor
	 * The ImpostorProcessor generates a two-triangle billboard impostor  geometry of an
	 * input geometry from a specific viewing angle, and  casts textures and normals from
	 * the original geometry to the impostor.
	 */
	typedef CountedPointer<IImpostorProcessor> spImpostorProcessor;


	/**
	 * Settings for the ImpostorProccessor
	 */
	class IImpostorSettings : public ISettingsObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if IImpostorSettings is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("IImpostorSettings",type)==0 )
				return true;
			return ISettingsObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a IImpostorSettings pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a IImpostorSettings pointer
		 * @return a pointer to the IImpostorSettings object, if the cast can be made, and a NULL pointer otherwise
		 */
		static IImpostorSettings *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("IImpostorSettings") )
				return static_cast<IImpostorSettings*>(ptr);
			return NULL;
			}
		/**
		 * Set the UseTightFitting flag. If set, the impostor will exactly conform to the bounds
		 * of the geometry. If false, its dimensions will always be diameter*diameter @param
		 * value is the value UseTightFitting will be set to
		 */
		virtual	void SetUseTightFitting( bool value ) = 0;

		/**
		 * @param dest_param a pointer to the destination memory area
		 */
		virtual	void GetViewDirection( real dest_param[3] ) = 0;

		/**
		 * Get the UseTightFitting flag. If set, the impostor will exactly conform to the bounds
		 * of the geometry. If false, its dimensions will always be diameter*diameter @return
		 * the current value of UseTightFitting
		 */
		virtual	bool GetUseTightFitting(  ) = 0;

		virtual	void SetViewDirection( real value[3] ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an IImpostorSettings
	 * Settings for the ImpostorProccessor
	 */
	typedef CountedPointer<IImpostorSettings> spImpostorSettings;

	class ISceneNode;
	class IGeometryData;
	class IMappingImageSettings;
	class IMappingImage;

	/**
	 * ISurfaceMapper creates a mapping image between two user-defined geometries. The mapper
	 * basically looks for the source geometry in the inverse normal direction from the
	 * outwardly offset destination geometry, and maps pixels accordingly. This means that
	 * you can modify the normals of the destination geometry to adjust the search direction
	 * to your liking.  The geometries can either be set as IGeometryDatas or as the root
	 * nodes of scenes. If both are set, the scene is used.
	 */
	class ISurfaceMapper : public IObject
	{
	public:
		/**
		 * GetClass returns the name of the class of the object.
		 * @return the name of the actual class of the object, as a const rchar string
		 */
		virtual const rchar *GetClass();

		/** 
		 * The IsA function returns true if the object is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the object is, or is a decendant of
		 * @return true if the object is of the specified class, false if not
		 */
		virtual bool IsA( const rchar *type ) const;

		/**
		 * The IsClassA function returns true if ISurfaceMapper is a or is a decendant of the class named as the type parameter
		 * @param type is the name of the class to check if the class is, or is a decendant of
		 * @return true if the class is of the specified class, false if not
		 */
		static bool IsClassA( const rchar *type )
			{
			if( !type )
				return false;
			if( strcmp("ISurfaceMapper",type)==0 )
				return true;
			return IObject::IsClassA(type);
			}
		/** 
		 * SafeCast makes sure the pointer is of a class that can be cast into a ISurfaceMapper pointer, and if this is possible, returns the cast pointer. 
		 * @param ptr is the pointer to be cast into a ISurfaceMapper pointer
		 * @return a pointer to the ISurfaceMapper object, if the cast can be made, and a NULL pointer otherwise
		 */
		static ISurfaceMapper *SafeCast( IObject *ptr )
			{
			if( ptr && ptr->IsA("ISurfaceMapper") )
				return static_cast<ISurfaceMapper*>(ptr);
			return NULL;
			}
		/**
		 * Set the texcoord level in the destination geom to use for the material transfer @param
		 * the texcoord level
		 */
		virtual	void SetDestinationTexCoordSet( rid value ) = 0;

		/**
		 * Set the hard edge angle. If RecalculateSearchDirection is on, the search direction
		 * from the destination mesh to the source mesh will be determined by an internal normal
		 * calculation with the specified hard edge angle. If false, the search direction will
		 * be determined by the existing normals of the destination geometry. @param the new
		 * hard edge angle
		 */
		virtual	void SetSearchDirectionHardEdgeAngle( real value ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  the surface transfer destination
		 * @param SceneRoot is the node that is to be set as the top scene node
		 */
		virtual	void SetDestinationSceneRoot( ISceneNode *value ) = 0;

		/**
		 * Get the RecalculateSearchDirection flag. If set, the search direction from the destination
		 * mesh to the source mesh will be determined by an internal normal calculation with
		 * the specified hard edge angle. If false, the search direction will be determined
		 * by the existing normals of the destination geometry. @return the RecalculateSearchDirection
		 * flag
		 */
		virtual	bool GetRecalculateSearchDirection(  ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  vertex baking. @return the current
		 * top scene node<br />Description of IGeometryData: IGeometryData represents a geometric
		 * structure  consisting of point data (Vertices) and topological data (Triangles).
		 * IGeometryData may represent a whole geometric object, but can also be used by streaming
		 * data filters, and in this way, only represents a part of the object. <br><br> Different
		 * fields in the Vertices and Triangles fields data  objects will contain point data
		 * and topological data. The standard  naming convention used in the filters/renderers
		 * are as follows: (Case sensitive naming, other fields may also be present) <br><br>
		 * 'Coords' <br> Positional coordinates of a vertex, expressed with a 3-component real
		 * field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br> Texture coordinates of a
		 * vertex, expressed with a 2 components real field. By convention, the existing fields
		 * must be sequential, and  must start with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal
		 * vector for the vertex,	expressed  with a 3-component real field, a  normalized (XYZ)
		 * vector. <br><br> 'VertexIds'	 <br> The id of the primitive's current vertex.  This
		 * field is present even if the  vertex data	is directly specified in the  primitive's
		 * data, to specify topology. The field is of type rid. <br><br> 'MaterialIds' <br>
		 * The material of the primitive.  The field is of type rid. <br><br> The 'Coords' and
		 * 'VertexIds' fields always exist in the object, but the other fields are optional.
		 * Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetDestinationGeometry(  ) = 0;

		/**
		 * Get the mapping image settings. Currently, the only applicable settings for this
		 * mapper is size, gutter, and supersampling settings. @return the mapping image settings
		 * object<br />Description of IMappingImageSettings: Settings for the Simplygon mapping
		 * classes  These settings control the properties of the mapping image that will be
		 * generated in the current simplification processor (reducer/remesher  etc).   The
		 * mapping image will be used when casting a new texture on the  simplified geometry.
		 * In the settings object, the user is able to set  the dimensions of the image (width/height)
		 * as well as whether the LOD should have new texture coordinates and some parameters
		 * for how they  should be generated and all other settings regarding the mapping image.
		 */
		virtual	CountedPointer<IMappingImageSettings> GetMappingImageSettings(  ) = 0;

		/**
		 * Set the RecalculateSearchDirection flag. If set, the search direction from the destination
		 * mesh to the source mesh will be determined by an internal normal calculation with
		 * the specified hard edge angle. If false, the search direction will be determined
		 * by the existing normals of the destination geometry. @param the new RecalculateSearchDirection
		 * flag
		 */
		virtual	void SetRecalculateSearchDirection( bool value ) = 0;

		/**
		 * Set the search offset. This is how far out from the destination geometry the search
		 * for the source geometry will begin, propagating inwardly for the length of SearchDistance.
		 * If negative, it will be set to a sane default internally, based on the mesh size.
		 * @param the new search offset
		 */
		virtual	void SetSearchOffset( real value ) = 0;

		/**
		 * Set the search distance. If the source geometry is found within this distance from
		 * the destination geometry, it will be mapped. If negative, it will be set to a sane
		 * default internally, based on the mesh size. @param the new search distance
		 */
		virtual	void SetSearchDistance( real value ) = 0;

		/**
		 * Get the hard edge angle. If RecalculateSearchDirection is set, the search direction
		 * from the destination mesh to the source mesh will be determined by an internal normal
		 * calculation with the specified hard edge angle. If false, the search direction will
		 * be determined by the existing normals of the destination geometry. @return the hard
		 * edge angle
		 */
		virtual	real GetSearchDirectionHardEdgeAngle(  ) = 0;

		/**
		 * Get the texcoord level in the destination geom to use for the material transfer @return
		 * the texcoord level
		 */
		virtual	rid GetDestinationTexCoordSet(  ) = 0;

		/**
		 * Get the RecalculateSearchDirection flag. If set, the search direction from the destination
		 * mesh to the source mesh will be determined by an internal normal calculation with
		 * the specified hard edge angle. @return the search distance
		 */
		virtual	real GetSearchDistance(  ) = 0;

		/**
		 * Get the search offset. This is how far out from the destination geometry the search
		 * for the source geometry will begin, propagating inwardly for the length of SearchDistance.
		 * If negative, it will be set to a sane default internally, based on the mesh size.
		 * @return the search offset
		 */
		virtual	real GetSearchOffset(  ) = 0;

		/**
		 * Get the mapping image. @return the mapping image<br />Description of IMappingImage:
		 * IMappingImage stores the mapping between a processed geometry and the source geometry
		 * it is based on. The mapping image object also stores multisampling settings. It can
		 * be used to cast information from the original geometry to the processed geometry,
		 * such as surface transfer or calculating normal maps. See IMaterialCaster and subclasses
		 * for casting uses.
		 */
		virtual	CountedPointer<IMappingImage> GetMappingImage(  ) = 0;

		/**
		 * Runs the surface mapping
		 */
		virtual	void RunSurfaceMapping(  ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  the surface transfer source @param
		 * SceneRoot is the node that is to be set as the top scene node
		 */
		virtual	void SetSourceSceneRoot( ISceneNode *value ) = 0;

		/**
		 * Set the source geometry data @param SceneRoot is the node that is to be set as the
		 * top scene node
		 */
		virtual	void SetSourceGeometry( IGeometryData *value ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  the surface transfer source @return
		 * the current top scene node<br />Description of ISceneNode: ISceneNode is the base
		 * class for all scene graph nodes in simplygon. It has relative transformation to its
		 * parent, and functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetSourceSceneRoot(  ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  vertex baking. @return the current
		 * top scene node<br />Description of ISceneNode: ISceneNode is the base class for all
		 * scene graph nodes in simplygon. It has relative transformation to its parent, and
		 * functions to add children to the node.
		 */
		virtual	CountedPointer<ISceneNode> GetDestinationSceneRoot(  ) = 0;

		/**
		 * Get the top scene node of a scene tree used for  the surface transfer source @return
		 * the current top scene node<br />Description of IGeometryData: IGeometryData represents
		 * a geometric structure  consisting of point data (Vertices) and topological data (Triangles).
		 * IGeometryData may represent a whole geometric object, but can also be used by streaming
		 * data filters, and in this way, only represents a part of the object. <br><br> Different
		 * fields in the Vertices and Triangles fields data  objects will contain point data
		 * and topological data. The standard  naming convention used in the filters/renderers
		 * are as follows: (Case sensitive naming, other fields may also be present) <br><br>
		 * 'Coords' <br> Positional coordinates of a vertex, expressed with a 3-component real
		 * field (XYZ). <br><br> 'TexCoords0' - 'TexCoords255' <br> Texture coordinates of a
		 * vertex, expressed with a 2 components real field. By convention, the existing fields
		 * must be sequential, and  must start with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal
		 * vector for the vertex,	expressed  with a 3-component real field, a  normalized (XYZ)
		 * vector. <br><br> 'VertexIds'	 <br> The id of the primitive's current vertex.  This
		 * field is present even if the  vertex data	is directly specified in the  primitive's
		 * data, to specify topology. The field is of type rid. <br><br> 'MaterialIds' <br>
		 * The material of the primitive.  The field is of type rid. <br><br> The 'Coords' and
		 * 'VertexIds' fields always exist in the object, but the other fields are optional.
		 * Also, there can exist user fields.
		 */
		virtual	CountedPointer<IGeometryData> GetSourceGeometry(  ) = 0;

		/**
		 * Set the top scene node of a scene tree used for  the surface transfer destination
		 * @param SceneRoot is the node that is to be set as the top scene node
		 */
		virtual	void SetDestinationGeometry( IGeometryData *value ) = 0;

	};

	/**
	 * a CounterPointer smart pointer to an ISurfaceMapper
	 * ISurfaceMapper creates a mapping image between two user-defined geometries. The mapper
	 * basically looks for the source geometry in the inverse normal direction from the
	 * outwardly offset destination geometry, and maps pixels accordingly. This means that
	 * you can modify the normals of the destination geometry to adjust the search direction
	 * to your liking.  The geometries can either be set as IGeometryDatas or as the root
	 * nodes of scenes. If both are set, the scene is used.
	 */
	typedef CountedPointer<ISurfaceMapper> spSurfaceMapper;

	class ISimplygonSDK
	{
	public:
		/**
		 * Creates and returns a counted pointer to an object of type IStringArray
		 * Documentation from IStringArray:
		 * ReStringArray is the string implementation of ReValueArray. See ReValueArray for
		 * a description. Please note that conversions to/from real values will not work on
		 * string arrays.
		 * @return the created object, of type spStringArray
		 */
		virtual CountedPointer<IStringArray> CreateStringArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBoolArray
		 * Documentation from IBoolArray:
		 * IBoolArray is the bool implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spBoolArray
		 */
		virtual CountedPointer<IBoolArray> CreateBoolArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ICharArray
		 * Documentation from ICharArray:
		 * ICharArray is the char implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spCharArray
		 */
		virtual CountedPointer<ICharArray> CreateCharArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDoubleArray
		 * Documentation from IDoubleArray:
		 * IDoubleArray is the double implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spDoubleArray
		 */
		virtual CountedPointer<IDoubleArray> CreateDoubleArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFloatArray
		 * Documentation from IFloatArray:
		 * IFloatArray is the float implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spFloatArray
		 */
		virtual CountedPointer<IFloatArray> CreateFloatArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IIntArray
		 * Documentation from IIntArray:
		 * IIntArray is the int implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spIntArray
		 */
		virtual CountedPointer<IIntArray> CreateIntArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ILongArray
		 * Documentation from ILongArray:
		 * ILongArray is the long implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spLongArray
		 */
		virtual CountedPointer<ILongArray> CreateLongArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRcharArray
		 * Documentation from IRcharArray:
		 * IRcharArray is the rchar implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spRcharArray
		 */
		virtual CountedPointer<IRcharArray> CreateRcharArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRealArray
		 * Documentation from IRealArray:
		 * IRealArray is the real implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spRealArray
		 */
		virtual CountedPointer<IRealArray> CreateRealArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRhandleArray
		 * Documentation from IRhandleArray:
		 * IRhandleArray is the rhandle implementation of IArray. See IArray for a description.
		 * @return the created object, of type spRhandleArray
		 */
		virtual CountedPointer<IRhandleArray> CreateRhandleArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRidArray
		 * Documentation from IRidArray:
		 * IRidArray is the rid implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spRidArray
		 */
		virtual CountedPointer<IRidArray> CreateRidArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShortArray
		 * Documentation from IShortArray:
		 * IShortArray is the short implementation of IValueArray. See IValueArray for a description.
		 * @return the created object, of type spShortArray
		 */
		virtual CountedPointer<IShortArray> CreateShortArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedCharArray
		 * Documentation from IUnsignedCharArray:
		 * IUnsignedCharArray is the uchar implementation of IValueArray. See IValueArray for
		 * a description.
		 * @return the created object, of type spUnsignedCharArray
		 */
		virtual CountedPointer<IUnsignedCharArray> CreateUnsignedCharArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedIntArray
		 * Documentation from IUnsignedIntArray:
		 * IUnsignedIntArray is the uint implementation of IValueArray. See IValueArray for
		 * a description.
		 * @return the created object, of type spUnsignedIntArray
		 */
		virtual CountedPointer<IUnsignedIntArray> CreateUnsignedIntArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedLongArray
		 * Documentation from IUnsignedLongArray:
		 * IUnsignedLongArray is the ulong implementation of IValueArray. See IValueArray for
		 * a description.
		 * @return the created object, of type spUnsignedLongArray
		 */
		virtual CountedPointer<IUnsignedLongArray> CreateUnsignedLongArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUnsignedShortArray
		 * Documentation from IUnsignedShortArray:
		 * IUnsignedShortArray is the ushort implementation of IValueArray. See IValueArray
		 * for a description.
		 * @return the created object, of type spUnsignedShortArray
		 */
		virtual CountedPointer<IUnsignedShortArray> CreateUnsignedShortArray() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IChunkedImageData
		 * Documentation from IChunkedImageData:
		 * ReChunkedImageData holds chunks for ReImageData objects. ReImageData objects can
		 * be referenced, and swapped in/out of memory,  to secondary storage. This is useful
		 * for very large images that cannot be stored in-memory. ReImageData objects can be
		 * indexed in 1-,2- or 3D, and each ReImageData chunk is cloned from a source ReImageData
		 * object, at setup. Fields added to ReImageData chunks after setup will only be added
		 * into that chunk, and is not recommended.
		 * @return the created object, of type spChunkedImageData
		 */
		virtual CountedPointer<IChunkedImageData> CreateChunkedImageData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IFieldData
		 * Documentation from IFieldData:
		 * IFieldData represents multiple fields of data. Each  field is implemented as an IValueArray
		 * object, that has a unique  name, and can have complex components (such as scalars,
		 * vectors,  quaternions, tensors or matrices).  All fields are assumed to be of the
		 * same length. IFieldData can be  seen as an array with complex tuples, where the component
		 * can be of  different types.
		 * @return the created object, of type spFieldData
		 */
		virtual CountedPointer<IFieldData> CreateFieldData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryData
		 * Documentation from IGeometryData:
		 * IGeometryData represents a geometric structure  consisting of point data (Vertices)
		 * and topological data (Triangles). IGeometryData may represent a whole geometric object,
		 * but can also be used by streaming data filters, and in this way, only represents
		 * a part of the object. <br><br> Different fields in the Vertices and Triangles fields
		 * data  objects will contain point data and topological data. The standard  naming
		 * convention used in the filters/renderers are as follows: (Case sensitive naming,
		 * other fields may also be present) <br><br> 'Coords' <br> Positional coordinates of
		 * a vertex, expressed with a 3-component real field (XYZ). <br><br> 'TexCoords0' -
		 * 'TexCoords255' <br> Texture coordinates of a vertex, expressed with a 2 components
		 * real field. By convention, the existing fields must be sequential, and  must start
		 * with 'TexCoord0'. <br><br> 'Normals'	 <br> Normal vector for the vertex,	expressed
		 * with a 3-component real field, a  normalized (XYZ) vector. <br><br> 'VertexIds'	
		 * <br> The id of the primitive's current vertex.  This field is present even if the
		 * vertex data	is directly specified in the  primitive's data, to specify topology.
		 * The field is of type rid. <br><br> 'MaterialIds' <br> The material of the primitive.
		 * The field is of type rid. <br><br> The 'Coords' and 'VertexIds' fields always exist
		 * in the object, but the other fields are optional. Also, there can exist user fields.
		 * @return the created object, of type spGeometryData
		 */
		virtual CountedPointer<IGeometryData> CreateGeometryData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IPackedGeometryData
		 * Documentation from IPackedGeometryData:
		 * IPackedGeometryData keeps the same information as IGeometryData, but with all corner
		 * data fields moved into per-vertex fields. No per-corner fields exist, apart from
		 * the VertexIds field.  Please note that the number of vertices in an IPackedGeometryData
		 * is commonly higher than in an IGeometryData, as vertices must be split to accommodate
		 * for different corner data.
		 * @return the created object, of type spPackedGeometryData
		 */
		virtual CountedPointer<IPackedGeometryData> CreatePackedGeometryData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageData
		 * Documentation from IImageData:
		 * IImageData holds unpacked image data. The data is  stored in an IFieldData object
		 * as value fields. For simplicity all  images are implemented as 3D images, but has
		 * an extent of 1 in Z for 2D images, and an extent of 1 in both Y and Z for 1D images.
		 * Cube maps are stored as a 3D image with Z-depth of 6 (one for each side)
		 * @return the created object, of type spImageData
		 */
		virtual CountedPointer<IImageData> CreateImageData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITable
		 * Documentation from ITable:
		 * ITable is the base class for tables objects, where items are added into an id-indexed
		 * array of objects. 
		 * @return the created object, of type spTable
		 */
		virtual CountedPointer<ITable> CreateTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMaterial
		 * Documentation from IMaterial:
		 * IMaterial keeps information on materials used while rendering.
		 * @return the created object, of type spMaterial
		 */
		virtual CountedPointer<IMaterial> CreateMaterial() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMaterialTable
		 * Documentation from IMaterialTable:
		 * IMaterialTable keeps information on materials used while rendering.
		 * @return the created object, of type spMaterialTable
		 */
		virtual CountedPointer<IMaterialTable> CreateMaterialTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMatrix4x4
		 * Documentation from IMatrix4x4:
		 * IMatrix4x4 is used to represent and manipulate 4x4  transformation matrices, which
		 * can be either standard matrices, or  homogeneous 4x4 matrices used to transform 3D
		 * homogeneous coordinates  [x y z w]. The transformations are defined in row-major
		 * order.
		 * @return the created object, of type spMatrix4x4
		 */
		virtual CountedPointer<IMatrix4x4> CreateMatrix4x4() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITransform3
		 * Documentation from ITransform3:
		 * ITransform3 handles homogeneous 4x4  transforms, i.e. transformations which can be
		 * represented by  multiplying a 4x4 matrix with a homogeneous 3D coordinate. <br> ITransform3
		 * can either pre-multiply a matrix onto the transformation, which will add a transform
		 * around the current transform, or it can post-multiply the matrix, which will add
		 * a transform inside the current transform. Post-multiply is the default mode.
		 * @return the created object, of type spTransform3
		 */
		virtual CountedPointer<ITransform3> CreateTransform3() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMappingImage
		 * Documentation from IMappingImage:
		 * IMappingImage stores the mapping between a processed geometry and the source geometry
		 * it is based on. The mapping image object also stores multisampling settings. It can
		 * be used to cast information from the original geometry to the processed geometry,
		 * such as surface transfer or calculating normal maps. See IMaterialCaster and subclasses
		 * for casting uses.
		 * @return the created object, of type spMappingImage
		 */
		virtual CountedPointer<IMappingImage> CreateMappingImage() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IParameterizer
		 * Documentation from IParameterizer:
		 * Computes texture coordinates for arbitrary geometry.
		 * @return the created object, of type spParameterizer
		 */
		virtual CountedPointer<IParameterizer> CreateParameterizer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryGroup
		 * Documentation from IGeometryGroup:
		 * A grouping of objects that process in conjunction.
		 * @return the created object, of type spGeometryGroup
		 */
		virtual CountedPointer<IGeometryGroup> CreateGeometryGroup() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IObjectCollection
		 * Documentation from IObjectCollection:
		 * IObjectCollection and its specializations handles a collection of  IObjects. There
		 * are methods for adding, removing and iterating through  the objects.
		 * @return the created object, of type spObjectCollection
		 */
		virtual CountedPointer<IObjectCollection> CreateObjectCollection() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryDataCollection
		 * Documentation from IGeometryDataCollection:
		 * IGeometryDataCollection holds a number of IGeometryData  objects. The objects can
		 * be looked up by their names (if they have  been named through IObject::SetName()
		 * ).
		 * @return the created object, of type spGeometryDataCollection
		 */
		virtual CountedPointer<IGeometryDataCollection> CreateGeometryDataCollection() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IWavefrontImporter
		 * Documentation from IWavefrontImporter:
		 * base class for graphics import classes
		 * @return the created object, of type spWavefrontImporter
		 */
		virtual CountedPointer<IWavefrontImporter> CreateWavefrontImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IWavefrontExporter
		 * Documentation from IWavefrontExporter:
		 * Wavefront .obj geometry exporter
		 * @return the created object, of type spWavefrontExporter
		 */
		virtual CountedPointer<IWavefrontExporter> CreateWavefrontExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBinaryImporter
		 * Documentation from IBinaryImporter:
		 * IBinaryImporter loads the geometry data from a binary file, that is specific for
		 * Simplygon. Please note that the binary file is only intended for temporary storage,
		 * and that no compatibility between versions of Simplygon is guaranteed.
		 * @return the created object, of type spBinaryImporter
		 */
		virtual CountedPointer<IBinaryImporter> CreateBinaryImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBinaryExporter
		 * Documentation from IBinaryExporter:
		 * IBinaryExporter stores the geometry data into a binary file, that is specific for
		 * Simplygon. Please note that the binary file is only intended for temporary storage,
		 * and that no compatibility between versions of Simplygon is guaranteed.
		 * @return the created object, of type spBinaryExporter
		 */
		virtual CountedPointer<IBinaryExporter> CreateBinaryExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryValidator
		 * Documentation from IGeometryValidator:
		 * Checks the geometry for consistent indices, number of triangles etc.
		 * @return the created object, of type spGeometryValidator
		 */
		virtual CountedPointer<IGeometryValidator> CreateGeometryValidator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IColorCaster
		 * Documentation from IColorCaster:
		 * IColorCaster is the interface used to cast basic color values. Currently supported
		 * material color value types are Ambient,  Diffuse and Specular + Shininess.
		 * @return the created object, of type spColorCaster
		 */
		virtual CountedPointer<IColorCaster> CreateColorCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IOpacityCaster
		 * Documentation from IOpacityCaster:
		 * IOpacityCaster is the interface used to cast opacity values. To be used when opacity
		 * is needed as a separate texture.
		 * @return the created object, of type spOpacityCaster
		 */
		virtual CountedPointer<IOpacityCaster> CreateOpacityCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalCaster
		 * Documentation from INormalCaster:
		 * INormalCaster is the interface used to cast normals data onto the receiving geometry.
		 * @return the created object, of type spNormalCaster
		 */
		virtual CountedPointer<INormalCaster> CreateNormalCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalRepairer
		 * Documentation from INormalRepairer:
		 * Repairs normals on a processed geometry.
		 * @return the created object, of type spNormalRepairer
		 */
		virtual CountedPointer<INormalRepairer> CreateNormalRepairer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDisplacementCaster
		 * Documentation from IDisplacementCaster:
		 * IDisplacementCaster is used to store the delta-values between the original and processed
		 * geometries. The values are divided by a scaling value, and clamped into the -1 ->
		 * 1 range before being  stored into an image.
		 * @return the created object, of type spDisplacementCaster
		 */
		virtual CountedPointer<IDisplacementCaster> CreateDisplacementCaster() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryTangentCalculator
		 * Documentation from IGeometryTangentCalculator:
		 * IGeometryTangentCalculator calculates tangent vectors for geometry data objects.
		 * One corner field of texture coordinates must exist, as well as normals. The Tangents
		 * are placed into two corner fields called "Tangents" and "Bitangents". If any of these
		 * fields already exists, it is replaced by the new field.
		 * @return the created object, of type spGeometryTangentCalculator
		 */
		virtual CountedPointer<IGeometryTangentCalculator> CreateGeometryTangentCalculator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRepairSettings
		 * Documentation from IRepairSettings:
		 * Settings for handling unconnected parts and unwanted gaps in the geometry. It consists
		 * of two parts, Welding and T-junction removal. Welding merges vertices that are closer
		 * than a set distance from each other. T-junction removal finds open edges that lies
		 * within a set distance from other open edges, but without matching vertices. It then
		 * splits those triangles into smaller, matching triangles and fuses them together.
		 * @return the created object, of type spRepairSettings
		 */
		virtual CountedPointer<IRepairSettings> CreateRepairSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IBoneSettings
		 * Documentation from IBoneSettings:
		 * Settings for the Simplygon Reduction/Remeshing classes  With the BoneSettings object,
		 * the user can setup all the parameters for how the BoneLOD processor should simplify
		 * the links between geometries  and bones.   Bones can be un-linked from the geometry
		 * either with a set ratio or  depending on a selected pixel size on screen.
		 * @return the created object, of type spBoneSettings
		 */
		virtual CountedPointer<IBoneSettings> CreateBoneSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IReductionSettings
		 * Documentation from IReductionSettings:
		 * Settings for the IReductionProcessor class. Handles all the settings for Simplygons
		 * simplification algorithms. The user can tell the reduction processor which features
		 * are important by using the FeatureFlags?parameter, and also the relative importance
		 * of these features using the Set{feature}Importance methods. Also settings for things
		 * like symmetry are set here.
		 * @return the created object, of type spReductionSettings
		 */
		virtual CountedPointer<IReductionSettings> CreateReductionSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalCalculationSettings
		 * Documentation from INormalCalculationSettings:
		 * Settings for the normal recalculation 
		 * @return the created object, of type spNormalCalculationSettings
		 */
		virtual CountedPointer<INormalCalculationSettings> CreateNormalCalculationSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMappingImageSettings
		 * Documentation from IMappingImageSettings:
		 * Settings for the Simplygon mapping classes  These settings control the properties
		 * of the mapping image that will be generated in the current simplification processor
		 * (reducer/remesher  etc).   The mapping image will be used when casting a new texture
		 * on the  simplified geometry. In the settings object, the user is able to set  the
		 * dimensions of the image (width/height) as well as whether the LOD should have new
		 * texture coordinates and some parameters for how they  should be generated and all
		 * other settings regarding the mapping image.
		 * @return the created object, of type spMappingImageSettings
		 */
		virtual CountedPointer<IMappingImageSettings> CreateMappingImageSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IVisibilitySettings
		 * Documentation from IVisibilitySettings:
		 * Visibility settings contains the parameters for how to compute the visibility of
		 * a scene and how to use it, both in the  IReductionProcessor and the IRemeshingProcessor.
		 * The visibility information is computed for each part of the mesh  determined by the
		 * visibility from a collection of cameras contained  in the CameraPath.   The visibility
		 * can be used to guide the reducer and/or texture  coordinates generator (parameterizer)
		 * with the flags UseVisibilityWeightsInReducer respective  UseVisibilityWeightsInTexcoordGenerator.
		 * There is also an option to completely throw away triangles that are deemed not visible,
		 * using the CullOccludedGeometry flag.
		 * @return the created object, of type spVisibilitySettings
		 */
		virtual CountedPointer<IVisibilitySettings> CreateVisibilitySettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IReductionProcessor
		 * Documentation from IReductionProcessor:
		 * IReductionProcessor welds, removes t-junctions, removes double-triangles and reduces
		 * the trianglecount of the Geometry. It also calculates new normals for the reduced
		 * and optimized Geometry.
		 * @return the created object, of type spReductionProcessor
		 */
		virtual CountedPointer<IReductionProcessor> CreateReductionProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRemeshingSettings
		 * Documentation from IRemeshingSettings:
		 * Remeshing settings for the IRemeshingProcessor class. The remesher creates a completely
		 * new lightweight mesh from the input geometry, and is intended to be viewed from the
		 * outside. Here you will set the OnScreenSize (larger numbers means a more detailed
		 * mesh), merge distance (which fills in smaller gaps) and a cutting plane (where all
		 * parts of the input mesh on the far side of that plane will be culled). 
		 * @return the created object, of type spRemeshingSettings
		 */
		virtual CountedPointer<IRemeshingSettings> CreateRemeshingSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IRemeshingProcessor
		 * Documentation from IRemeshingProcessor:
		 * IRemeshingProcessor creates a new geometry that is based on the input geometry, but
		 * that is topologically based on the size of the input geometry rendered at a specific
		 * screen size, and allowed pixel error. The remesher will on demand also add texture
		 * coordinates and a mapping texture to the output remeshed geometry. The geometry 
		 * that is to be remeshed can be defined either using an in-memory  geometry data object,
		 * or using a geometry file placed on disk, the latter being the preferred method, if
		 * the source geometry is very large as it can be swapped in/out of memory as needed.
		 * @return the created object, of type spRemeshingProcessor
		 */
		virtual CountedPointer<IRemeshingProcessor> CreateRemeshingProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IScene
		 * Documentation from IScene:
		 * IScene is the main keeper of a scene and scene graph in simplygon. The scene is self-contained,
		 * with materials, textures, etc. to describe a full scene. 
		 * @return the created object, of type spScene
		 */
		virtual CountedPointer<IScene> CreateScene() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneNode
		 * Documentation from ISceneNode:
		 * ISceneNode is the base class for all scene graph nodes in simplygon. It has relative
		 * transformation to its parent, and functions to add children to the node.
		 * @return the created object, of type spSceneNode
		 */
		virtual CountedPointer<ISceneNode> CreateSceneNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneNodeCollection
		 * Documentation from ISceneNodeCollection:
		 * ISceneNodeCollection holds a number of ISceneNode  objects. The objects can be looked
		 * up by their names (if they have  been named through IObject::SetName() ).
		 * @return the created object, of type spSceneNodeCollection
		 */
		virtual CountedPointer<ISceneNodeCollection> CreateSceneNodeCollection() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneMesh
		 * Documentation from ISceneMesh:
		 * ISceneMesh is the mesh node in the simplygon scene graph
		 * @return the created object, of type spSceneMesh
		 */
		virtual CountedPointer<ISceneMesh> CreateSceneMesh() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneLodGroup
		 * Documentation from ISceneLodGroup:
		 * ISceneLodGroup is a LOD grouping for the scene graph
		 * @return the created object, of type spSceneLodGroup
		 */
		virtual CountedPointer<ISceneLodGroup> CreateSceneLodGroup() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneBone
		 * Documentation from ISceneBone:
		 * ISceneBone is the bone node in the simplygon scene graph
		 * @return the created object, of type spSceneBone
		 */
		virtual CountedPointer<ISceneBone> CreateSceneBone() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneBoneTable
		 * Documentation from ISceneBoneTable:
		 * ISceneBoneTable keeps information on bones used while rendering.
		 * @return the created object, of type spSceneBoneTable
		 */
		virtual CountedPointer<ISceneBoneTable> CreateSceneBoneTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITexture
		 * Documentation from ITexture:
		 * IMaterial keeps information on materials used while rendering.
		 * @return the created object, of type spTexture
		 */
		virtual CountedPointer<ITexture> CreateTexture() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ITextureTable
		 * Documentation from ITextureTable:
		 * ITextureTable keeps information on textures used while rendering.
		 * @return the created object, of type spTextureTable
		 */
		virtual CountedPointer<ITextureTable> CreateTextureTable() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageDataImporter
		 * Documentation from IImageDataImporter:
		 * Class for loading image data from different file formats.
		 * @return the created object, of type spImageDataImporter
		 */
		virtual CountedPointer<IImageDataImporter> CreateImageDataImporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IMappingImageMeshData
		 * Documentation from IMappingImageMeshData:
		 * IMappingImageMeshData stores the mapped meshes and their paths in the original scene.
		 * This can be used to find a specific triangle on the original mesh in the scene from
		 * the combined id in the mapping image.
		 * @return the created object, of type spMappingImageMeshData
		 */
		virtual CountedPointer<IMappingImageMeshData> CreateMappingImageMeshData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IDirectXRenderer
		 * Documentation from IDirectXRenderer:
		 * A Renderer using DirectX 11 that can be used to preview an  IGeometryData object
		 * by rendering it from the ICamera objects in an  ICameraPath and then storing the
		 * frames to disc.   If using a Shading Node Network (having an IShadingNode assigned
		 * to the  IMaterial), then the material can be previewed with the generated HLSL shader.
		 * @return the created object, of type spDirectXRenderer
		 */
		virtual CountedPointer<IDirectXRenderer> CreateDirectXRenderer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ICameraPath
		 * Documentation from ICameraPath:
		 * A Camera path object that can contain a number of ICamera objects. The ICamera objects
		 * are either added to the path by the user or created from a few default member functions
		 * that creates parameterized  procedural camera paths.
		 * @return the created object, of type spCameraPath
		 */
		virtual CountedPointer<ICameraPath> CreateCameraPath() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ICamera
		 * Documentation from ICamera:
		 * A Camera object that has an XYZ-position. It can either be an omni directional camera
		 * or a target camera. The camera can be put into a camera path.  The camera has a quadratic
		 * FOV.
		 * @return the created object, of type spCamera
		 */
		virtual CountedPointer<ICamera> CreateCamera() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingTextureNode
		 * Documentation from IShadingTextureNode:
		 * ITextureNode describes a texture source node in a shading network.
		 * @return the created object, of type spShadingTextureNode
		 */
		virtual CountedPointer<IShadingTextureNode> CreateShadingTextureNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingSwizzlingNode
		 * Documentation from IShadingSwizzlingNode:
		 * IInterpolateNode describes a single interpolating shading node node in a shading
		 * network.  Input 1 and Input 2 is interpolated per-component using Input 3. Blend
		 * values below 0 and over 1 will be clamped.
		 * @return the created object, of type spShadingSwizzlingNode
		 */
		virtual CountedPointer<IShadingSwizzlingNode> CreateShadingSwizzlingNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingColorNode
		 * Documentation from IShadingColorNode:
		 * IColorNode describes a single color source node in a shading network
		 * @return the created object, of type spShadingColorNode
		 */
		virtual CountedPointer<IShadingColorNode> CreateShadingColorNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingAddNode
		 * Documentation from IShadingAddNode:
		 * IAddNode describes a single addition shading node in a shading network. Input 1 and
		 * 2 are added per-component to produce the output.
		 * @return the created object, of type spShadingAddNode
		 */
		virtual CountedPointer<IShadingAddNode> CreateShadingAddNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingSubtractNode
		 * Documentation from IShadingSubtractNode:
		 * ISubtractNode describes a single subtracting shading node in a shading network. 
		 * Input 2 is subtracted from Input 1 per-component.
		 * @return the created object, of type spShadingSubtractNode
		 */
		virtual CountedPointer<IShadingSubtractNode> CreateShadingSubtractNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingMultiplyNode
		 * Documentation from IShadingMultiplyNode:
		 * IMultiplyNode describes a single multiplying shading node in a shading network. 
		 * Input 1 and Input 2 is multiplied per-component.
		 * @return the created object, of type spShadingMultiplyNode
		 */
		virtual CountedPointer<IShadingMultiplyNode> CreateShadingMultiplyNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingDivideNode
		 * Documentation from IShadingDivideNode:
		 * IDivideNode describes a single division shading node node in a shading network. 
		 * Input 1 is divided by Input 2 per-component to produce the output.
		 * @return the created object, of type spShadingDivideNode
		 */
		virtual CountedPointer<IShadingDivideNode> CreateShadingDivideNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingClampNode
		 * Documentation from IShadingClampNode:
		 * IClampNode describes a single clamp shading node in a shading network.  Input 1 is
		 * clamped per-component between Input 2 and 3.
		 * @return the created object, of type spShadingClampNode
		 */
		virtual CountedPointer<IShadingClampNode> CreateShadingClampNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingMaxNode
		 * Documentation from IShadingMaxNode:
		 * IMaxNode describes a single max shading node in a shading network.  The output has
		 * the per-channel max values of the two inputs.
		 * @return the created object, of type spShadingMaxNode
		 */
		virtual CountedPointer<IShadingMaxNode> CreateShadingMaxNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingMinNode
		 * Documentation from IShadingMinNode:
		 * IMinNode describes a single min shading node in a shading network.  The output has
		 * the per-channel min values of the two inputs.
		 * @return the created object, of type spShadingMinNode
		 */
		virtual CountedPointer<IShadingMinNode> CreateShadingMinNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingStepNode
		 * Documentation from IShadingStepNode:
		 * IMaxNode describes a single step shading node, where the per-component output is
		 * either 1 or 0 depending on if input0 is larger or smaller than input1. Basically,
		 * (Input0 >= Input1) ? 1 : 0
		 * @return the created object, of type spShadingStepNode
		 */
		virtual CountedPointer<IShadingStepNode> CreateShadingStepNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingVertexColorNode
		 * Documentation from IShadingVertexColorNode:
		 * IVertexColorNode describes a vertex color source node in a shading network.
		 * @return the created object, of type spShadingVertexColorNode
		 */
		virtual CountedPointer<IShadingVertexColorNode> CreateShadingVertexColorNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingInterpolateNode
		 * Documentation from IShadingInterpolateNode:
		 * IInterpolateNode describes a single interpolating shading node node in a shading
		 * network.  Input 1 and Input 2 is interpolated per-component using Input 3. Blend
		 * values below 0 and over 1 will be clamped.
		 * @return the created object, of type spShadingInterpolateNode
		 */
		virtual CountedPointer<IShadingInterpolateNode> CreateShadingInterpolateNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShadingCustomNode
		 * Documentation from IShadingCustomNode:
		 * ICustomNode describes a custom shading node in a shading  network. The output is
		 * produced based on customizable user specified  operations.  The custom node has a
		 * user specified amount of input parameters. Use  SetInputCount() to specify the number
		 * of inputs.  The user has to assign and implement event handlers (called observers)
		 * for the custom node to be able to evaluate to colors.  See CustomNodeExample and
		 * API documentation for further explanations  and code samples.
		 * @return the created object, of type spShadingCustomNode
		 */
		virtual CountedPointer<IShadingCustomNode> CreateShadingCustomNode() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IShaderData
		 * Documentation from IShaderData:
		 * Given a material, the shader data class keeps the relevant shader data and is able
		 * to generate a GLSL/HLSL shader.
		 * @return the created object, of type spShaderData
		 */
		virtual CountedPointer<IShaderData> CreateShaderData() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneAggregator
		 * Documentation from ISceneAggregator:
		 * ISceneAggregator combines all specified  geometries in the scene into one geometry.
		 * All materials are combined and receive a new shared texture atlas.
		 * @return the created object, of type spSceneAggregator
		 */
		virtual CountedPointer<ISceneAggregator> CreateSceneAggregator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISceneAggregatorSettings
		 * Documentation from ISceneAggregatorSettings:
		 * Settings for the ISceneAggregatorSettings class. The SceneAggregator converts entire
		 * scenes containing multiple draw calls into a single new object with a single texture
		 * per material channel.  The user can set whether or not the SceneAggregator should
		 * create new UVs based on the old UVs or create a completely new UV parameterization.
		 * @return the created object, of type spSceneAggregatorSettings
		 */
		virtual CountedPointer<ISceneAggregatorSettings> CreateSceneAggregatorSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IChartAggregator
		 * Documentation from IChartAggregator:
		 * Computes new texture coordinates for a geometry with overlapping UV charts.
		 * @return the created object, of type spChartAggregator
		 */
		virtual CountedPointer<IChartAggregator> CreateChartAggregator() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IVertexColorBaker
		 * Documentation from IVertexColorBaker:
		 * IVertexColorBaker
		 * @return the created object, of type spVertexColorBaker
		 */
		virtual CountedPointer<IVertexColorBaker> CreateVertexColorBaker() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IGeometryAnalyzer
		 * Documentation from IGeometryAnalyzer:
		 * ...
		 * @return the created object, of type spGeometryAnalyzer
		 */
		virtual CountedPointer<IGeometryAnalyzer> CreateGeometryAnalyzer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type INormalAnalyzer
		 * Documentation from INormalAnalyzer:
		 * ...
		 * @return the created object, of type spNormalAnalyzer
		 */
		virtual CountedPointer<INormalAnalyzer> CreateNormalAnalyzer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IUVAnalyzer
		 * Documentation from IUVAnalyzer:
		 * ...
		 * @return the created object, of type spUVAnalyzer
		 */
		virtual CountedPointer<IUVAnalyzer> CreateUVAnalyzer() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImageDataExporter
		 * Documentation from IImageDataExporter:
		 * Class for loading image data from different file formats.
		 * @return the created object, of type spImageDataExporter
		 */
		virtual CountedPointer<IImageDataExporter> CreateImageDataExporter() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImpostorProcessor
		 * Documentation from IImpostorProcessor:
		 * The ImpostorProcessor generates a two-triangle billboard impostor  geometry of an
		 * input geometry from a specific viewing angle, and  casts textures and normals from
		 * the original geometry to the impostor.
		 * @return the created object, of type spImpostorProcessor
		 */
		virtual CountedPointer<IImpostorProcessor> CreateImpostorProcessor() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type IImpostorSettings
		 * Documentation from IImpostorSettings:
		 * Settings for the ImpostorProccessor
		 * @return the created object, of type spImpostorSettings
		 */
		virtual CountedPointer<IImpostorSettings> CreateImpostorSettings() = 0;

		/**
		 * Creates and returns a counted pointer to an object of type ISurfaceMapper
		 * Documentation from ISurfaceMapper:
		 * ISurfaceMapper creates a mapping image between two user-defined geometries. The mapper
		 * basically looks for the source geometry in the inverse normal direction from the
		 * outwardly offset destination geometry, and maps pixels accordingly. This means that
		 * you can modify the normals of the destination geometry to adjust the search direction
		 * to your liking.  The geometries can either be set as IGeometryDatas or as the root
		 * nodes of scenes. If both are set, the scene is used.
		 * @return the created object, of type spSurfaceMapper
		 */
		virtual CountedPointer<ISurfaceMapper> CreateSurfaceMapper() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IBoolData interface
		 * @return the created object
		 */
		virtual rdata<IBoolData> CreateBoolData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an ICharData interface
		 * @return the created object
		 */
		virtual rdata<ICharData> CreateCharData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IUnsignedCharData interface
		 * @return the created object
		 */
		virtual rdata<IUnsignedCharData> CreateUnsignedCharData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IShortData interface
		 * @return the created object
		 */
		virtual rdata<IShortData> CreateShortData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IUnsignedShortData interface
		 * @return the created object
		 */
		virtual rdata<IUnsignedShortData> CreateUnsignedShortData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IIntData interface
		 * @return the created object
		 */
		virtual rdata<IIntData> CreateIntData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IUnsignedIntData interface
		 * @return the created object
		 */
		virtual rdata<IUnsignedIntData> CreateUnsignedIntData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an ILongData interface
		 * @return the created object
		 */
		virtual rdata<ILongData> CreateLongData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IUnsignedLongData interface
		 * @return the created object
		 */
		virtual rdata<IUnsignedLongData> CreateUnsignedLongData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IFloatData interface
		 * @return the created object
		 */
		virtual rdata<IFloatData> CreateFloatData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IDoubleData interface
		 * @return the created object
		 */
		virtual rdata<IDoubleData> CreateDoubleData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IRealData interface
		 * @return the created object
		 */
		virtual rdata<IRealData> CreateRealData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IRidData interface
		 * @return the created object
		 */
		virtual rdata<IRidData> CreateRidData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IRcharData interface
		 * @return the created object
		 */
		virtual rdata<IRcharData> CreateRcharData() = 0;

		/**
		 * Creates and returns an rdata counted pointer to an IRhandleData interface
		 * @return the created object
		 */
		virtual rdata<IRhandleData> CreateRhandleData() = 0;

		/**
		 * Sets the callback used to report errors
		 * @param handler is the new error handler object
		 * @return the previously registered handler object
		 */
		virtual rerrorhandler *SetErrorHandler( rerrorhandler *handler ) = 0;
		/**
		 * Returns the version of the Simplygon library as a string
		 * @return the library version
		 */
		virtual const rchar *GetVersion() const = 0;
		/**
		 * Sets a named global library setting
		  * @param setting_name is the name of the global setting we want to set.
		 * @param value is the value we want to set the chosen global setting to.
		 */
		virtual void SetGlobalSetting( const char *setting_name , intptr_t value ) const = 0;
		/**
		 * Gets a named global library setting
		  * @param setting_name is the name of the global setting we want to get.
		 * @return the value of the chosen setting.
		 */
		virtual intptr_t GetGlobalSetting( const char *setting_name ) const = 0;
		/**
		 * Sets a named library setting that is local to the current thread
		  * @param setting_name is the name of the setting we want to set.
		 * @param value is the value we want to set the chosen setting to.
		 */
		virtual void SetThreadLocalSetting( const char *setting_name , intptr_t value ) const = 0;
		/**
		 * Gets a named library setting that is local to the current thread
		  * @param setting_name is the name of the setting we want to get.
		 * @return the value of the chosen setting.
		 */
		virtual intptr_t GetThreadLocalSetting( const char *setting_name ) const = 0;
	};

	/**
	 * SafeCast casts a pointer to an API object into a pointer to another API class type. The cast is only 
	 * made if the object is of the type it is cast into, else NULL is returned.
	 * @param ptr is the pointer that is to be cast
	 * @return a counted pointer of the template T cast type 
	 */
	template <class T> CountedPointer<T> SafeCast( IObject *ptr )
		{
		return CountedPointer<T>(T::SafeCast(ptr)); 
		}

	/**
	 * UnsafeCast casts a pointer to an API object into a pointer to another API class type. The pointer is cast
	 * using static_cast, and is done regardless of if the object is actually of the type it is cast into
	 * @param ptr is the pointer that is to be cast
	 * @return a counted pointer of the template T cast type 
	 */
	 template <class T> CountedPointer<T> UnsafeCast( IObject *ptr )
		{
		return CountedPointer<T>(static_cast<T*>(ptr));
		}

	/**
	 * Cast casts a pointer to an API object into a pointer to another API class type. In debug 
	 * mode (where the _DEBUG define exists), the cast is only made if the object is of the 
	 * type it is cast into, else NULL is returned.
	 * In release mode, the pointer is cast statically without checking.
	 * @param ptr is the pointer that is to be cast
	 * @return a counted pointer of the template T cast type 
	 */
	template <class T> CountedPointer<T> Cast( IObject *ptr )
		{
	#ifdef _DEBUG
		return SafeCast<T>(ptr);
	#else
		return UnsafeCast<T>(ptr);
	#endif
		}	

	/**
	 * Returns the API interface version hash as a string
	 * @return the API interface version hash
	 */
	inline const rchar *GetInterfaceVersionHash()
		{
		return "0604716F8E96B24BE6F853D26B65B2B509D07565320BE396BE80E331441C490D";
		}

	/**
	 * Returns the SDK version number of the header file as a string. This may not match the .dll, because headers and .dll files that have the same interface will work properly.
	 * @return the API version string
	 */
	inline const rchar *GetHeaderVersion()
		{
		return "6.2.300";
		}

};

#endif//__SimplygonSDK_h__
